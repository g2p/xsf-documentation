<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<rfc ipr="full3978" category='std' docName="draft-saintandre-rfc3921bis-03" obsoletes="3921">

  <front>
    <title abbrev="XMPP IM">Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre" role="editor">
      <organization>XMPP Standards Foundation</organization>
      <address>
        <postal>
          <street>P.O. Box 1641</street>
          <city>Denver</city>
          <region>CO</region>
          <code>80201</code>
          <country>US</country>
        </postal>
        <email>stpeter@jabber.org</email>
        <uri>xmpp:stpeter@jabber.org</uri>
      </address>
    </author>
    <date year="2007" month="June" day="15"/>
    <area>Applications</area>
    <workgroup>XMPP Working Group</workgroup>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>XMPP</keyword>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>Jabber</keyword>
    <keyword>IM</keyword>
    <keyword>Instant Messaging</keyword>
    <keyword>Presence</keyword>
    <keyword>XML</keyword>
    <keyword>Extensible Markup Language</keyword>
    <abstract>
      <t>This document describes extensions to the core features of the Extensible Messaging and Presence Protocol (XMPP) that provide basic instant messaging (IM) and presence functionality in conformance with RFC 2779.</t>
      <t>This document obseletes RFC 3921.</t>
    </abstract>
  </front>

  <middle>

  <section title="Introduction" anchor="intro">
    <section title="Overview" anchor="intro-overview">
      <t>The Extensible Messaging and Presence Protocol (XMPP) is a technology for streaming <xref target="XML">Extensible Markup Language</xref> elements in order to exchange messages, presence information, and other structured data in close to real time.  The core features of XMPP are defined in <xref target="XMPP-CORE"/>.  These features -- mainly XML streams, use of Transport Layer Security (<xref target='TLS'/>) and Simple Authentication and Security Layer (<xref target='SASL'/>), and the &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt; children of the stream root -- provide the building blocks for many types of near-real-time applications, which may be layered on top of the core by sending application-specific data qualified by particular XML namespaces (see <xref target="XML-NAMES"/>).  This document describes extensions to the core features of XMPP that provide the basic functionality expected of an instant messaging (IM) and presence application as defined in <xref target="IMP-REQS"/>.</t>
      <t>This document obsoletes RFC 3921.</t>
    </section>
    <section title="Requirements" anchor="intro-requirements">
      <t>Traditionally, instant messaging applications have combined the following factors:</t>
      <t>
        <list style='numbers'>
          <t>The central point of focus is a list of one's contacts or "buddies" (in XMPP this list is called a ROSTER).</t>
          <t>The purpose of using such an application is to exchange relatively brief text messages with each of one's contacts in close to real time -- often relatively large numbers of such messages in rapid succession, in the form of one-to-one "chat sessions".</t>
          <t>The catalyst for exchanging messages is PRESENCE -- i.e., knowledge about the network availability of each of one's contacts (thus knowing who is online and available for a chat session).</t>
          <t>Presence information is provided only to contacts that a user has authorized via a presence subscription.</t>
        </list>
      </t>
      <t>Thus at a high level this document assumes that a user must be able to complete the following use cases:</t>
      <t><list style="symbols">
        <t>Manage items in a contact list</t>
        <t>Exchange messages with one's contacts</t>
        <t>Exchange presence information with one's contacts</t>
        <t>Manage presence subscriptions to and from one's contacts</t>
      </list></t>
      <t>Detailed definitions of these functionality areas are contained in <xref target="IMP-REQS"/>, and the interested reader should refer to that document regarding the requirements addressed herein.  While the XMPP instant messaging and presence extensions specified herein meet the requirements of <xref target="IMP-REQS"/>, they were not designed explicitly with that specification in mind, since the base protocol evolved through an open development process within the Jabber open-source community before RFC 2779 was written.  Although XMPP protocol extensions addressing many other functionality areas have been defined in the XMPP Standards Foundation's XEP series (e.g., multi-user text chat as specified in <xref target='XEP-0045'/>), such extensions are not included in this document because they are not required by <xref target="IMP-REQS"/>.</t>
      <t>Note: <xref target="IMP-REQS"/> stipulates that presence services must be separable from instant messaging services and vice-versa; i.e., it must be possible to use the protocol to provide a presence service, an instant messaging service, or both.  Although the text of this document assumes that implementations and deployments will want to offer a unified instant messaging and presence service, there is no requirement that a service must offer both a presence service and an instant messaging service, and the protocol makes it possible to offer separate and distinct services for presence and for instant messaging.  (For example, a presence-only service could return &lt;service-unavailable/&gt; errors in response to attempts to send &lt;message/&gt; stanzas.)</t>
      <t>Note: For convenience, this document employs the term "user" to refer to the owner of an XMPP account; however, account owners need not be human persons and may be bots, devices, or other non-human applications.</t>
    </section>
    <section title="Typical Session Flow" anchor="intro-session">
      <t><xref target="XMPP-CORE"/> specifies how an XMPP client connects to an XMPP server.  In particular, it specifies the preconditions (including XML stream establishment, authentication, and binding of a resource to the stream) that must be fulfilled before a client is allowed to send XML stanzas (the basic unit of meaning in XMPP) to other entities on an XMPP network.  The reader is referred to <xref target="XMPP-CORE"/> for details, and knowledge of <xref target="XMPP-CORE"/> is assumed herein.</t>
      <t>Upon fulfillment of the preconditions specified in <xref target="XMPP-CORE"/>, an XMPP client has a long-lived XML stream with an XMPP server, which enables the user to send and receive a potentially unlimited number of XML stanzas over the stream.  Such a stream can be used as the basis for the exchange of instant messaging, presence, and other information in close to real time.  The typical flow for an instant messaging and presence session is as follows:</t>
      <t>
        <list style='numbers'>
          <t>Negotiate an XML stream with one's server.  (See <xref target='XMPP-CORE'/>.)</t>
          <t>Retrieve one's roster.  (See <xref target='roster-login'/>.)</t>
          <t>Send initial presence to the server for broadcasting to all subscribed contacts, thus "going online" from the perspective of XMPP communications.  (See <xref target='presence-initial'/>.)</t>
          <t>Exchange messages, manage presence subscriptions, perform roster updates, and in general process and generate other XML stanzas with particular semantics throughout the life of the session.  (See <xref target='message'/> and <xref target='iq'/>.)</t>
          <t>Terminate the session when desired by sending unavailable presence and closing the underlying XML stream. (See <xref target='presence-unavailable'/>.)</t>
        </list>
      </t>
    </section>
    <section title="Conventions" anchor="intro-conventions">
      <t>This document inherits the terminology defined in <xref target="XMPP-CORE"/>.</t>
      <t>The following keywords are to be interpreted as described in <xref target="TERMS"/>: "MUST", "SHALL", "REQUIRED"; "MUST NOT", "SHALL NOT"; "SHOULD", "RECOMMENDED"; "SHOULD NOT", "NOT RECOMMENDED"; "MAY", "OPTIONAL".</t>
      <t>In examples, lines have been wrapped for improved readability.</t>
    </section>
  </section>

  <section title="Managing the Roster" anchor="roster">
    <t>In XMPP, one's roster contains any number of specific contacts.  A user's roster is stored by the user's server on the user's behalf so that the user may access roster information from any resource.</t>
    <t>Note: There are important interactions between rosters and subscriptions; these are defined under <xref target="int">Integration of Managing the Roster and Presence Subscriptions</xref>, and the reader must refer to that section for a complete understanding of roster management (however, such an understanding is necessary only for developers of XMPP servers, since most of the complexity is shielded from clients).</t>
    <section title="Syntax and Semantics" anchor="roster-syntax">
      <t>Rosters are managed using IQ stanzas, specifically by means of a &lt;query/&gt; child element qualified by the 'jabber:iq:roster' namespace.  The &lt;query/&gt; element MAY contain one or more &lt;item/&gt; children, each describing a unique roster item or "contact".  The following rules apply:</t>
      <t>
        <list style="symbols">
          <t>An IQ stanza of type "get" sent from client to server and containing a &lt;query/&gt; element is defined as a ROSTER GET.  The &lt;query/&gt; element in a roster get MUST be empty (i.e., contain no child elements).</t>
          <t>An IQ stanza of type "set" sent from client to server and containing a &lt;query/&gt; element is defined as a ROSTER SET.  The &lt;query/&gt; element in a roster set MUST contain one and only one &lt;item/&gt; element.</t>
          <t>An IQ stanza of type "set" sent from server to client and containing a &lt;query/&gt; element is defined as a ROSTER PUSH.  The &lt;query/&gt; element in a roster get MUST contain one and only one &lt;item/&gt; element.</t>
          <t>An IQ stanza of type "result" sent from server to client and containing a &lt;query/&gt; element is defined as a ROSTER RESULT.  The &lt;query/&gt; element in a roster result MUST contain at least one &lt;item/&gt; element and MAY contain multiple &lt;item/&gt; elements.</t>
        </list>
      </t>
      <t>The "key" or unique identifier for each roster item is a Jabber Identifier or JID, encapsulated in the 'jid' attribute of the &lt;item/&gt; element, which is REQUIRED.  Note: When the item added represents another IM user, the value of the 'jid' attribute MUST be a bare JID (&lt;contact@domain&gt;) rather a full JID (&lt;contact@domain/resource&gt;).</t>
      <t>The state of the presence subscription in relation to a roster item is captured in the 'subscription' attribute of the &lt;item/&gt; element.  Allowable values for this attribute are:</t>
      <t>
        <list style="symbols">
          <t>"none" -- the user does not have a subscription to the contact's presence information, and the contact does not have a subscription to the user's presence information</t>
          <t>"to" -- the user has a subscription to the contact's presence information, but the contact does not have a subscription to the user's presence information</t>
          <t>"from" -- the contact has a subscription to the user's presence information, but the user does not have a subscription to the contact's presence information</t>
          <t>"both" -- both the user and the contact have subscriptions to each other's presence information (also called a "mutual subscription")</t>
        </list>
      </t>
      <t>Each &lt;item/&gt; element MAY possess a 'name' attribute, which specifies the "handle" to be associated with the JID, as determined by the user (not the contact).  The value of the 'name' attribute is opaque to the server but may have meaning to a human user.</t>
      <t>Each &lt;item/&gt; element MAY contain one or more &lt;group/&gt; child elements, for use in collecting roster items into various categories.  The XML character data of the &lt;group/&gt; element is opaque to the server but may have meaning to a human user.</t>
    </section>
    <section title="Retrieving One's Roster on Login" anchor="roster-login">
      <t>Upon authenticating with a server and binding a resource (thus becoming a connected resource), a client SHOULD request the roster before sending initial presence (however, because receiving the roster may not be desirable for all resources, e.g., a connection with limited bandwidth, the client's request for the roster is recommended and not required).  After a connected resource sends initial presence (see <xref target='presence-initial'/>), it is referred to as an AVAILABLE RESOURCE.  If a connected resource requests the roster but does not send initial presence, the server SHOULD NOT send it presence subscriptions and SHOULD NOT send it associated roster updates.  If an available resource does not request the roster during a session, the server SHOULD NOT send it presence subscriptions and MUST NOT associated roster updates.  For the sake of brevity, the term INTERESTED RESOURCE is used herein to refer to the concept of "an available resource that has requested the roster".</t>
      <t>A client requests the roster by sending a roster get over its stream to the server.</t>
      <figure>
        <preamble>Example: Client requests roster from server:</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/balcony' type='get' id='roster_1'>
  <query xmlns='jabber:iq:roster'/>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Example: Client receives roster from server:</preamble>
        <artwork><![CDATA[
<iq to='juliet@example.com/balcony' type='result' id='roster_1'>
  <query xmlns='jabber:iq:roster'>
    <item jid='romeo@example.net'
          name='Romeo'
          subscription='both'>
      <group>Friends</group>
    </item>
    <item jid='mercutio@example.org'
          name='Mercutio'
          subscription='from'/>
    <item jid='benvolio@example.org'
          name='Benvolio'
          subscription='both'/>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <t>If the server cannot process the roster get, it MUST return an appropriate stanza error as described in <xref target='XMPP-CORE'/> (such as &lt;service-unavailable/&gt; if the roster namespace is not supported or &lt;internal-server-error/&gt; if the server experiences trouble returning the roster).</t>
    </section>
    <section title="Adding a Roster Item" anchor="roster-add">
      <t>At any time, a user MAY add an item to his or her roster by sending an IQ stanza of type "set" containing a &lt;query/&gt; element that in turn contains one &lt;item/&gt; element.</t>
      <figure>
        <preamble>Example: Client adds a new item:</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/balcony' type='set' id='roster_2'>
  <query xmlns='jabber:iq:roster'>
    <item jid='nurse@example.com'
          name='Nurse'>
      <group>Servants</group>
    </item>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <t>Note: The &lt;query/&gt; element MUST NOT contain more than one &lt;item/&gt; child element when the client sends an IQ set to the server.  In addition, the &lt;item/&gt; element MAY contain more than one &lt;group/&gt; element but the XML character data of each &lt;group/&gt; element MUST specify distinct groups (where duplicates are to be determined using the Resourceprep profile of stringprep as defined in <xref target='XMPP-CORE'/>).  If either of these rules is violated, the server MUST return a &lt;bad-format/&gt; error to the client.</t>
      <t>Note: A client MUST NOT add itself to its own roster; i.e., the value of the &lt;item/&gt; element's 'jid' attribute MUST NOT match the bare JID (node@domain) portion of the &lt;iq/&gt; element's 'from' attribute.  If this rule is violated, the server MUST return a &lt;not-allowed/&gt; error to the client.</t>
      <t>If the server can successfully process the roster addition, it MUST update the roster information in persistent storage and push the change out to all of the user's interested resources.  This "roster push" consists of an IQ stanza of type "set" from the server to the client and enables all interested resources to remain in sync with the server-based roster information.</t>
      <figure>
        <preamble>Example: Server (1) pushes the updated roster information to all interested resources and (2) replies with an IQ result to the sending resource:</preamble>
        <artwork><![CDATA[
<iq to='juliet@example.com/balcony'
    type='set'
    id='a78b4q6ha463'>
  <query xmlns='jabber:iq:roster'>
    <item jid='nurse@example.com'
          name='Nurse'
          subscription='none'>
      <group>Servants</group>
    </item>
  </query>
</iq>

<iq to='juliet@example.com/chamber'
    type='set'
    id='a78b4q6ha464'>
  <query xmlns='jabber:iq:roster'>
    <item jid='nurse@example.com'
          name='Nurse'
          subscription='none'>
      <group>Servants</group>
    </item>
  </query>
</iq>

<iq to='juliet@example.com/balcony' type='result' id='roster_2'/>
        ]]></artwork>
      </figure>
      <t>As required by the semantics of the IQ stanza kind as defined in <xref target="XMPP-CORE"/>, each resource that received the roster push MUST reply with an IQ stanza of type "result" (or "error").</t>
      <figure>
        <preamble>Example: Resources reply with an IQ result to the server:</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/balcony'
    to='example.com'
    type='result'
    id='a78b4q6ha463'/>
<iq from='juliet@example.com/chamber'
    to='example.com'
    type='result'
    id='a78b4q6ha464'/>
        ]]></artwork>
      </figure>
    </section>
    <section title="Updating a Roster Item" anchor="roster-update">
      <t>Updating an existing roster item (e.g., changing the group) is done in the same way as adding a new roster item, i.e., by sending the roster item in an IQ set to the server.</t>
      <figure>
        <preamble>Example: User updates roster item (add group):</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/chamber' type='set' id='roster_3'>
  <query xmlns='jabber:iq:roster'>
    <item jid='romeo@example.net'
          name='Romeo'>
      <group>Friends</group>
      <group>Lovers</group>
    </item>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Example: User updates roster item (remove group):</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/chamber' type='set' id='roster_4'>
  <query xmlns='jabber:iq:roster'>
    <item jid='romeo@example.net'
          name='Romeo'>
      <group>Lovers</group>
    </item>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Example: User updates roster item (change handle):</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/chamber' type='set' id='roster_5'>
  <query xmlns='jabber:iq:roster'>
    <item jid='romeo@example.net'
          name='MyRomeo'>
      <group>Lovers</group>
    </item>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Example: User updates roster item (remove handle):</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/chamber' type='set' id='roster_6'>
  <query xmlns='jabber:iq:roster'>
    <item jid='romeo@example.net'
          name=''>
      <group>Lovers</group>
    </item>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <t>As with adding a roster item, when updating a roster item the server MUST update the roster information in persistent storage, initiate a roster push to all of the user's interested resources, and send an IQ result to the initiating resource.</t>
    </section>
    <section title="Deleting a Roster Item" anchor="roster-delete">
      <t>At any time, a user MAY delete an item from his or her roster by sending an IQ set to the server and setting the value of the 'subscription' attribute to "remove" (a compliant server MUST ignore any other values of the 'subscription' attribute when received from a client).</t>
      <figure>
        <preamble>Example: Client removes an item:</preamble>
        <artwork><![CDATA[
<iq from='juliet@example.com/balcony' type='set' id='roster_7'>
  <query xmlns='jabber:iq:roster'>
    <item jid='nurse@example.com' subscription='remove'/>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <t>As with adding a roster item, when deleting a roster item the server MUST update the roster information in persistent storage, initiate a roster push to all of the user's interested resources (with the 'subscription' attribute set to a value of "remove"), and send an IQ result to the initiating resource.</t>
      <t>This command will result in cancellation of existing presence subscriptions; for details, see <xref target="int-remove">Removing a Roster Item and Cancelling All Subscriptions</xref>.</t>
    </section>
    <section title="Business Rules" anchor="roster-rules">
      <t>A server MUST ignore any 'to' address on a roster set and MUST treat any roster set as applying to the sender's bare JID.</t>
      <t>A client MUST ignore a roster push unless it has no 'from' attribute (i.e., implicitly from the server) or it has a 'from' attribute whose value matches the user's bare JID (of the form &lt;user@domain&gt;) or full JID (of the form &lt;user@domain/resource&gt;).</t>
    </section>
  </section>

  <section title="Managing Presence Subscriptions" anchor="sub">
    <t>In order to protect the privacy of instant messaging users and any other entities, presence and availability information is disclosed only to other entities that the user has approved.  When a user has agreed that another entity may view its presence, the entity is said to have a subscription to the user's presence information.  A subscription lasts across sessions; indeed, it lasts until the subscriber unsubscribes or the subscribee cancels the previously-granted subscription.</t>
    <t>Subscriptions are managed within XMPP by sending presence stanzas containing specially-defined attributes.  In particular, a SUBSCRIPTION REQUEST is a presence stanza whose 'type' attribute has a value of "subscribe".  If the subscription request is being sent to an instant messaging contact, the JID supplied in the 'to' attribute SHOULD be of the form &lt;contact@domain&gt; rather than &lt;contact@domain/resource&gt;, since the desired result is normally for the user to receive presence from all of the contact's resources, not merely the particular resource specified in the 'to' attribute.</t>
    <t>Note: There are important interactions between subscriptions and rosters; these are defined under <xref target="int">Integration of Managing the Roster and Presence Subscriptions</xref>, and the reader must refer to that section for a complete understanding of presence subscriptions.</t>
    <section title="Requesting a Subscription" anchor="sub-request">
      <t>A request to subscribe to another entity's presence is made by sending a presence stanza of type "subscribe".</t>
      <figure>
        <preamble>Example: Sending a subscription request:</preamble>
        <artwork><![CDATA[
<presence from='romeo@example.net' 
          to='juliet@example.com' 
          type='subscribe'/>
        ]]></artwork>
      </figure>
      <t>If the user does not exist, the user's server SHOULD automatically return a presence stanza of type "unsubscribed" to the requesting entity.</t>
      <figure>
        <preamble>Example: User does not exist</preamble>
        <artwork><![CDATA[
<presence from='juliet@example.com' 
          to='romeo@example.net' 
          type='unsubscribed'/>
        ]]></artwork>
      </figure>
      <t>A user's server MUST NOT automatically approve subscription requests on the user's behalf.  All subscription requests MUST be delivered to the user's client, specifically to one or more of the user's interested resources.  If the user has no interested resources when the subscription request is received by the user's server, the user's server MUST keep a record of the complete subscription request (including any extended namespaces contained therein) and deliver the request when the user next has an interested resource, until the user either approves or denies the request; however, the server MUST NOT deliver more than one subscription request from any given entity when the user next has an interested resource (e.g., if an entity sends multiple subscription requests to the user while the user is offline, the server SHOULD store only one of those requests, such as the first request or last request, and MUST deliver only one of the requests when the user next has an interested resource).  If there is more than one interested resource associated with the user when the subscription request is received by the user's server, the user's server MUST broadcast that subscription request to all interested resources in accordance with <xref target="rules">Server Rules for Handling XML Stanzas</xref>.  However, if the user receives a presence stanza of type "subscribe" from a contact to whom the user has already granted permission to see the user's presence information (e.g., in cases when the contact is seeking to resynchronize subscription states), the user's server SHOULD auto-reply on behalf of the user.  In addition, the user's server MAY choose to re-send an unapproved pending subscription request to the contact based on an implementation-specific algorithm (e.g., whenever a new resource becomes available for the user, or after a certain amount of time has elapsed); this helps to recover from transient, silent errors that may have occurred in relation to the original subscription request.</t>
      <t>Note: When a contact generates a subscription request to a user, the contact's server MUST stamp the outgoing presence stanza with the bare JID (&lt;contact@domain&gt;) of the contact, not the full JID (&lt;contact@domain/resource&gt;).  The same is true for presence stanzas of type "subscribed", "unsubscribe", and "unsubscribed".</t>
      <t>Note: If a user sends a presence subscription request to a contact but has not already added the contact to the user's roster, the user's server MUST send a roster push to all of the user's interested resources.  Thus a client MAY simply wait for the roster push rather than proactively adding to the contact to the user's roster.</t>
    </section>
    <section title="Handling a Subscription Request" anchor="sub-handle">
      <t>When a client receives a subscription request from another entity, it SHOULD either approve the request by sending a presence stanza of type "subscribed" or refuse the request by sending a presence stanza of type "unsubscribed".</t>
      <figure>
        <preamble>Example: Approving a subscription request:</preamble>
        <artwork><![CDATA[
<presence from='juliet@example.com'
          to='romeo@example.net' 
          type='subscribed'/>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Example: Refusing a presence subscription request:</preamble>
        <artwork><![CDATA[
<presence from='juliet@example.com'
          to='romeo@example.net' 
          type='unsubscribed'/>
        ]]></artwork>
      </figure>
    </section>
    <section title="Cancelling a Subscription from Another Entity" anchor="sub-cancel">
      <t>If a user would like to cancel a previously-granted subscription request, it sends a presence stanza of type "unsubscribed".</t>
      <figure>
        <preamble>Example: Cancelling a previously granted subscription request:</preamble>
        <artwork><![CDATA[
<presence from='juliet@example.com'
          to='romeo@example.net' 
          type='unsubscribed'/>
        ]]></artwork>
      </figure>
    </section>
    <section title="Unsubscribing from Another Entity's Presence" anchor="sub-unsub">
      <t>If a user would like to unsubscribe from the presence of another entity, it sends a presence stanza of type "unsubscribe".</t>
      <figure>
        <preamble>Example: Unsubscribing from an entity's presence:</preamble>
        <artwork><![CDATA[
<presence from='romeo@example.net'
          to='juliet@example.com' 
          type='unsubscribe'/>
        ]]></artwork>
      </figure>
    </section>
  </section>

  <section title="Exchanging Presence Information" anchor="presence">
    <section title="Overview" anchor="presence-overview">
      <t>The concept of presence refers to an entity's availability for communication over a network.  At the most basic level, presence is a boolean "on/off" variable that signals whether an entity is available or unavailable for communication; the terms "online" and "offline" are also used.  In XMPP, a principal's availability is signalled when a client controlled by the principal generates a &lt;presence/&gt; stanza with no 'type' attribute, and an entity's lack of availability is signalled when a client or entity generates a &lt;presence/&gt; stanza whose 'type' attribute has a value of "unavailable".  In XMPP-based applications that combine messaging and presence functionality, the default type of communication for which presence signals availability is messaging; however, XMPP-based applications are not required to combine messaging and presence functionality, and can provide standalone presence features without messaging (in addition, XMPP servers do not require presence information in order to successfully route message and IQ stanzas).</t>
      <t>XMPP presence typically follows a "publish-subscribe" or "observer" pattern, wherein an entity sends presence information to its server, and its server then broadcasts or multiplexes that information to all of the entity's contacts who have a subscription to the entity's presence (in the terminology of <xref target="IMP-MODEL"/>, an entity that generates presence information is a "presentity" and the entities that receive presence information are "subscribers").  A client generates presence for broadcasting to all subscribed entities by sending a presence stanza to its server with no 'to' address, where the presence stanza has either no 'type' attribute or a 'type' attribute whose value is "unavailable".  A user's server MUST NOT leak the user's network availability to entities who are not authorized to know the user's presence, either via an explicit subscription as described herein or via an existing trust relationship (such as presence-enabled user directories within organizations).  However, a client MAY also send <xref target='presence-directed'>directed presence</xref> to entities that are not subscribed to the principal's presence (this does not constitute a presence leak, since it is initiated by the client); this is done by specifying a 'to' address on the relevant presence stanza.  (Note: While presence information MAY be provided on a user's behalf by an automated service, normally it is provided by the user's client.)</t>
      <t>After a client completes the preconditions specified in <xref target="XMPP-CORE"/>, it can establish a "presence session" at its server by sending "initial presence" as described under <xref target='presence-initial'/>, that is by sending a presence stanza with to 'type' or 'to' attribute.</t>
      <t>The XMPP presence stanza is also used to negotiate and manage subscriptions to the presence of other entities.  These tasks are completed via presence stanzas of type "subscribe", "unsubscribe", "subscribed", and "unsubscribed" as described under <xref target='sub'/>.</t>
      <t>If a user and contact are associated with different XMPP servers, those servers also use a special presence stanza of type "probe" in order to determine the availability of the entity on the peer server.  Clients SHOULD NOT send presence stanzas of type "probe".</t>
      <t>Naturally, a presence stanza may also be of type "error".</t>
      <t>The values of the 'type' attribute are summarized in the following list (the reader is reminded that a presence stanza with no 'type' attribute signals that the relevant entity is available for communication):</t>
      <t>
        <list style="symbols">
          <t>unavailable -- Signals that the entity is no longer available for communication.</t>
          <t>subscribe -- The sender wishes to subscribe to the recipient's presence.</t>
          <t>subscribed -- The sender has allowed the recipient to receive their presence.</t>
          <t>unsubscribe -- The sender is unsubscribing from another entity's presence.</t>
          <t>unsubscribed -- The subscription request has been denied or a previously-granted subscription has been cancelled.</t>
          <t>probe -- A request for an entity's current presence; SHOULD be generated only by a server on behalf of a user.</t>
          <t>error -- An error has occurred regarding processing or delivery of a previously-sent presence stanza.</t>
        </list>
      </t>
    </section>
    <section title="Initial Presence" anchor="presence-initial">
      <t>After completing the preconditions described in <xref target="XMPP-CORE"/> (REQUIRED) and requesting the roster (RECOMMENDED), a client SHOULD send INITIAL PRESENCE to its server in order to signal its availability for communications.  As defined herein, the initial presence stanza (1) MUST possess no 'to' address (signalling that it is meant to be broadcasted by the server on behalf of the client) and (2) MUST possess no 'type' attribute (signalling the user's availability).  After sending initial presence, a connected resource (in the terminology of <xref target="XMPP-CORE"/>) is said to be an AVAILABLE RESOURCE.</t>
      <t>Upon receiving initial presence from a client, the user's server MUST do the following if there is not already one or more available resources for the user (if there is already one or more available resources for the user, the server obviously does not need to send the presence probes, since it already possesses the requisite information):</t>
      <t>
        <list style="numbers">
          <t>Send a PRESENCE PROBE (i.e., presence stanza whose 'type' attribute is set to a value of "probe") from the full JID (e.g., &lt;juliet@example.com/balcony&gt;) of the user to each contact to which the user is subscribed in order to determine if they are available; such contacts are those for which a JID is present in the user's roster with the 'subscription' attribute set to a value of "to" or "both".</t>
          <t>Broadcast initial presence from the full JID (e.g., &lt;juliet@example.com/balcony&gt;) of the user to all contacts that are subscribed to the user's presence information; such contacts are those for which a JID is present in the user's roster with the 'subscription' attribute set to a value of "from" or "both".</t>
        </list>
      </t>
      <t>In addition, the user's server MUST broadcast initial presence from the user's newly available resource to the user's existing available resources (if any).</t>
      <t>Upon receiving initial presence from the user, if the contact address does not exist or the user is not in the contact's roster with a subscription state of "to" or "both", then the contact's server MUST return a presence stanza of type "unsubscribe" to the user.  Otherwise, if the user is in the contact's roster with a subscription state of "to" or "both", then the contact's server MUST deliver the user's presence stanza to the full JIDs (e.g., &lt;romeo@example.net/orchard&gt;) associated with all of the contact's available resources.</t>
      <t>If the user's server receives a presence stanza of type "error" in response to the initial presence that it sent to a contact on behalf of the user, it SHOULD NOT send further presence updates to that contact (until and unless it receives a presence stanza from the contact).</t>
    </section>
    <section title="Presence Probes" anchor="presence-probes">
      <t>Upon receiving a presence probe from the user's server on behalf of the user, the contact's server SHOULD reply as follows:</t>
      <t>
        <list style="numbers">
          <t>If the contact account does not exist or the user is in the contact's roster with a subscription state other than "From", "From + Pending Out", or "Both" (as defined under <xref target='substates'>Subscription States</xref>), the contact's server MUST return a presence stanza of type "unsubscribed" in response to the presence probe (however, if a server receives a presence probe from a subdomain of the server's hostname or another such trusted service, it MAY provide presence information about the user to that entity).</t>
          <t>Else, if the contact has no available resources, the server MUST either (1) reply to the presence probe by sending to the user the full XML of the last presence stanza of type "unavailable" received by the server from the contact, or (2) not reply at all.</t>
          <t>Else, if the contact has at least one available resource, the server MUST reply to the presence probe by sending to the user the full XML of the last presence stanza with no 'to' attribute received by the server from each of the contact's available resources.</t>
        </list>
      </t>
    </section>
    <section title="Subsequent Presence Broadcast" anchor="presence-broadcast">
      <t>After sending initial presence, the user MAY update its availability for broadcasting at any time during its session by sending a presence stanza with no 'to' address and no 'type' attribute.  (Note: A user's client SHOULD NOT send a presence update to broadcast information that changes independently of the user's presence and availability.)</t>
      <t>Upon receiving such a presence stanza expressing updated availability, the user's server MUST broadcast the full XML of that presence stanza to all contacts (1) that are in the user's roster with a subscription type of "from" or "both" and (2) from whom the server has not received unavailable presence, presence of type "unsubscribe", or a presence error during the user's session, as well as to the user's other available resources.  (Note: Regarding rule 2 above, if the subscription state is "both" then the server MAY broadcast subsequent presence only if the server has received available presence from the contact at some point during the user's session; i.e., if the server never received available presence from the contact and the user has a mutual presence subscription with the contact, it MAY decline to send subsequent presence to the contact.)</t>
      <t>Upon receiving subsequent presence from the user, if the contact address does not exist or the user is not in the contact's roster with a subscription state of "to" or "both", then the contact's server MUST return a presence stanza of type "unsubscribe" to the user.  Otherwise, if the user is in the contact's roster with a subscription state of "to" or "both", then the contact's server MUST deliver the user's presence stanza to the full JIDs (e.g., &lt;romeo@example.net/orchard&gt;) associated with all of the contact's available resources.</t>
    </section>
    <section title="Unavailable Presence" anchor="presence-unavailable">
      <t>Before ending its session with a server, a client SHOULD gracefully become unavailable by sending UNAVAILABLE PRESENCE, i.e., a presence stanza that possesses no 'to' attribute and that possesses a 'type' attribute whose value is "unavailable" (optionally, the final presence stanza MAY contain one or more &lt;status/&gt; elements specifying the reason why the user is no longer available).  However, the user's server MUST NOT depend on receiving final presence from an available resource, since the resource may become unavailable unexpectedly or may be timed out by the server.  If one of the user's resources becomes unavailable for any reason (either gracefully or ungracefully), the user's server MUST broadcast unavailable presence to all contacts (1) that are in the user's roster with a subscription type of "from" or "both" and (2) from whom the server has not received unavailable presence, presence of type "unsubscribe", or a presence error during the user's session; the user's server MUST also send that unavailable presence stanza to the user's other available resources.  (Note: Regarding rule 2 above, if the subscription state is "both" then the server MAY broadcast unavailable presence only if the server has received available presence from the contact at some point during the user's session; i.e., if the server never received available presence from the contact and the user has a mutual presence subscription with the contact, it MAY decline to send unavailable presence to the contact).  If the unavailable presence stanza was received from the client, the server MUST broadcast the full XML of that presence stanza to all entities that fit the above description.</t>
      <t>Any presence stanza with no 'type' attribute and no 'to' attribute that is sent after sending broadcasted unavailable presence MUST be broadcasted by the server to all subscribers (i.e., MUST be treated as equivalent to "initial presence" for a new presence session).</t>
    </section>
    <section title="Directed Presence" anchor="presence-directed">
      <t>This section supplements and in some respects modifies the rules defined above, but only for the special case of "directed presence".</t>
      <t>BROADCASTED PRESENCE is generated when a client sends a presence stanza with no type (or with type "unavailable") and no 'to' address over the XML to its server.  However, a user MAY also send DIRECTED PRESENCE to another entity -- i.e., a presence stanza with a 'to' attribute whose value is the JID of the other entity and with either no 'type' attribute or a 'type' attribute whose value is "unavailable".  There are three possible cases:</t>
      <t>
        <list style="numbers">
          <t>If the user sends directed available or unavailable presence to a contact that is in the user's roster with a subscription type of "from" or "both" after having sent initial presence and before sending broadcasted unavailable presence, the user's server MUST route or deliver the full XML of that presence stanza but SHOULD NOT otherwise modify the contact's status regarding broadcasted presence (i.e., it SHOULD include the contact's JID in any subsequent presence broadcasts initiated by the user).</t>
          <t>If the user sends directed presence to an entity that is not in the user's roster with a subscription type of "from" or "both" after having sent initial presence and before sending broadcasted unavailable presence, the user's server MUST route or deliver the full XML of that presence stanza to the entity but MUST NOT modify the contact's status regarding available presence broadcast (i.e., it MUST NOT include the entity's JID in any subsequent broadcasts of available presence initiated by the user); however, if the available resource from which the user sent the directed presence become unavailable, the user's server MUST route that unavailable presence to the entity (if the user has not yet sent directed unavailable presence to that entity).</t>
          <t>If the user sends directed presence without first sending initial presence or after having sent unavailable presence broadcast (i.e., the resource is connected but not available), the user's server MUST treat the entities to which the user sends directed presence in the same way that it treats the entities listed in case #2 above.</t>
        </list>
      </t>
      <t>A server SHOULD respond to presence probes from entities to which a user has sent directed presence (before sending directed or broadcasted unavailable presence), even if such entities are not in the user's roster with a subscription type of "from" or "both".  For instance, a user may join a multi-user chat room (see <xref target='XEP-0045'/>) by sending directed presence to the room:</t>
      <figure>
        <artwork><![CDATA[
<presence from='romeo@example.net/orchard'
          to='shakespeare@chat.example.com/RM'/>
        ]]></artwork>
      </figure>
       <t>In order to discover if the user remains online, the chat service might send a presence probe to the user on behalf of the room:</t>
      <figure>
        <artwork><![CDATA[
<presence from='shakespeare@chat.example.com'
          to='romeo@example.net'
          type='probe'/>
        ]]></artwork>
      </figure>
      <t>If the user is still online, the user's server SHOULD send an empty available presence to the requesting entity:</t>
      <figure>
        <artwork><![CDATA[
<presence from='romeo@example.net/orchard'
          to='shakespeare@chat.example.com'/>
        ]]></artwork>
      </figure>
      <t>If the user is now offline, the user's server SHOULD send an empty unavailable presence to the requesting entity:</t>
      <figure>
        <artwork><![CDATA[
<presence from='romeo@example.net/orchard'
          to='shakespeare@chat.example.com'
          type='unavailable'/>
        ]]></artwork>
      </figure>
    </section>
    <section title="Presence Syntax" anchor="presence-syntax">
      <t>In accordance with the default namespace declaration, a presence stanza is qualified by the 'jabber:client' or 'jabber:server' namespace, which defines certain allowable children of presence stanzas, in particular the &lt;show/&gt;, &lt;status/&gt;, and &lt;priority/&gt; elements.  These child elements are used to provide more detailed information about an entity's availability.  Typically these child elements are provided only if the presence stanza possesses no 'type' attribute, although exceptions are noted in the text that follows.</t>
      <section title="Availability States" anchor="presence-show">
        <t>The OPTIONAL &lt;show/&gt; element contains non-human-readable XML character data that specifies the particular availability sub-state of an entity or a specific resource thereof.  A presence stanza MUST NOT contain more than one &lt;show/&gt; element.  The &lt;show/&gt; element MUST NOT possess any attributes.  If provided, the XML character data value MUST be one of the following (additional availability types could be defined through a properly-namespaced child element of the presence stanza):</t>
        <t>
          <list style="symbols">
            <t>away -- The entity or resource is temporarily away.</t>
            <t>chat -- The entity or resource is actively interested in chatting.</t>
            <t>dnd -- The entity or resource is busy (dnd = "Do Not Disturb").</t>
            <t>xa -- The entity or resource is away for an extended period (xa = "eXtended Away").</t>
          </list>
        </t>
        <t>If no &lt;show/&gt; element is provided, the entity is assumed to be online and available.</t>
        <figure>
          <preamble>Example: Availability status:</preamble>
          <artwork><![CDATA[
<presence>
  <show>dnd</show>
</presence>
          ]]></artwork>
        </figure>
      </section>
      <section title="Availability Description" anchor="presence-status">
        <t>The OPTIONAL &lt;status/&gt; element contains XML character data specifying a natural-language description of an entity's availability.  It is normally used in conjunction with the show element to provide a detailed description of an availability state (e.g., "In a meeting") when the presence stanza has no 'type' attribute.  The &lt;status/&gt; element MUST NOT possess any attributes, with the exception of the 'xml:lang' attribute.  Multiple instances of the &lt;status/&gt; element MAY be included, but only if each instance possesses an 'xml:lang' attribute with a distinct language value (either explicitly or by inheritance of the 'xml:lang' value of an element farther up in the XML hierarchy, which may include the XML stream header as described in Section 4.4 of <xref target="XMPP-CORE"/>).</t>
        <figure>
          <preamble>Example: Availability description:</preamble>
          <artwork><![CDATA[
<presence from='romeo@example.net/orchard'
          xml:lang='en'>
  <show>dnd</show>
  <status>Wooing Juliet</status>
  <status xml:lang='cs'>Dvo&#x0159;&#x00ED;m se Julii</status>
</presence>
          ]]></artwork>
        </figure>
        <t>A presence stanza of type "unavailable" MAY also include a &lt;status/&gt; element to provide detailed information about why the entity is going offline.</t>
        <figure>
          <preamble>Example: Unavailability description:</preamble>
          <artwork><![CDATA[
<presence from='romeo@example.net/orchard'
          type='unavailable'>
  <status>Busy IRL</status>
</presence>
          ]]></artwork>
        </figure>
        <t>The &lt;status/&gt; child MAY also be sent in a subscription-related presence stanza (i.e., type "subscribe", "subscribed", "unsubscribe", or "unsubscribed") to provide a description of the action:</t>
        <figure>
          <preamble>Example: Description of subscription request:</preamble>
          <artwork><![CDATA[
<presence from='romeo@example.net'
          to='nurse@example.com'
          type='subscribe'>
  <status>Hi, Juliet said I should add you to my buddy list.</status>
</presence>
          ]]></artwork>
        </figure>
      </section>
      <section title="Resource Priority" anchor="presence-priority">
        <t>The OPTIONAL &lt;priority/&gt; element contains non-human-readable XML character data that specifies the priority level of the resource.  The value MUST be an integer between -128 and +127.  A presence stanza MUST NOT contain more than one &lt;priority/&gt; element.  The &lt;priority/&gt; element MUST NOT possess any attributes.  If no priority is provided, a server SHOULD consider the priority to be zero.</t>
        <figure>
          <preamble>Example: Presence priority:</preamble>
          <artwork><![CDATA[
<presence xml:lang='en'>
  <show>dnd</show>
  <status>Wooing Juliet</status>
  <status xml:lang='cs'>Dvo&#x0159;&#x00ED;m se Julii</status>
  <priority>1</priority>
</presence>
          ]]></artwork>
        </figure>
        <t>For information regarding the semantics of priority values in stanza routing within instant messaging and presence applications, refer to <xref target="rules">Server Rules for Handling XML Stanzas</xref>.</t>
      </section>
      <section title="Presence Errors" anchor="presence-errors">
        <t>If the presence stanza is of type "error", it MUST include an &lt;error/&gt; child element; for details, see <xref target="XMPP-CORE"/>.</t>
      </section>
      <section title="Extended Namespaces" anchor="presence-extended">
        <t>As described in <xref target="XMPP-CORE"/>, an XML stanza MAY contain any properly-namespaced child element; this applies to the presence stanza as well.</t>
      </section>
    </section>
  </section>

  <section title="Exchanging Messages" anchor="message">
    <section title="Overview" anchor="message-overview">
      <t>Once a client has authenticated with a server and bound a resource to an XML stream as described in <xref target="XMPP-CORE"/>, an XMPP server will route XML stanzas to and from that client.  One type of stanza that may be exchanged is &lt;message/&gt;.  Exchanging messages is a basic use of XMPP and is brought about when a user generates a message stanza that is addressed to another entity.  As defined under <xref target="rules">Server Rules for Handling XML Stanzas</xref>, the sender's server is responsible for delivering the message to the intended recipient (if the recipient is on the same server) or for routing the message to the recipient's server (if the recipient is on a different server).  Thus the message stanza is used to "push" information to another entity.</t>
      <t>An instant messaging client SHOULD specify an intended recipient for a message by providing the JID of an entity other than the sender in the 'to' attribute of the &lt;message/&gt; stanza.  If the message is being sent in reply to a message previously received from an address of the form &lt;user@domain/resource&gt; (e.g., within the context of a chat session), the value of the 'to' address SHOULD be of the form &lt;user@domain/resource&gt; rather than of the form &lt;user@domain&gt; unless the sender has knowledge (via presence) that the intended recipient's resource is no longer available.  If the message is being sent outside the context of any existing chat session or received message, the value of the 'to' address SHOULD be of the form &lt;user@domain&gt; rather than of the form &lt;user@domain/resource&gt;.</t>
      <t>Common uses of the message stanza in instant messaging applications include single messages, messages sent in the context of a chat conversation, messages sent in the context of a multi-user chat room, headlines and other alerts, and errors.  These uses are differentiated via 'type' attribute.  Inclusion of the 'type' attribute is RECOMMENDED.  If included, the 'type' attribute MUST have one of the following values:</t>
      <t>
        <list style="symbols">
          <t>chat -- The message is sent in the context of a one-to-one chat conversation.  A compliant client SHOULD present the message in an interface enabling one-to-one chat between the two parties, including an appropriate conversation history.</t>
          <t>error -- An error has occurred related to a previous message sent by the sender (for details regarding stanza error syntax, refer to <xref target="XMPP-CORE"/>).  A compliant client SHOULD present an appropriate interface informing the sender of the nature of the error.</t>
          <t>groupchat -- The message is sent in the context of a multi-user chat environment (similar to that of <xref target="IRC"/>).  A compliant client SHOULD present the message in an interface enabling many-to-many chat between the parties, including a roster of parties in the chatroom and an appropriate conversation history.  Full definition of XMPP-based groupchat protocols is out of scope for this document (for details see <xref target="XEP-0045"/>).</t>
          <t>headline -- The message is probably generated by an automated service that delivers or broadcasts content (news, sports, market information, syndicated content, etc.).  No reply to the message is expected, and a compliant client SHOULD present the message in an interface that appropriately differentiates the message from standalone messages, chat sessions, or groupchat sessions (e.g., by not providing the recipient with the ability to reply).</t>
          <t>normal -- The message is a single message that is sent outside the context of a one-to-one conversation or groupchat, and to which it is expected that the recipient will reply.  A compliant client SHOULD present the message in an interface enabling the recipient to reply, but without a conversation history.  This is the default value of the 'type' attribute.</t>
        </list>
      </t>
      <t>An IM application SHOULD support all of the foregoing message types; if an application receives a message with no 'type' attribute or the application does not understand the value of the 'type' attribute provided, it MUST consider the message to be of type "normal" (i.e., "normal" is the default).  The "error" type MUST be generated only in response to an error related to a message received from another entity.</t>
      <t>Although the 'type' attribute is OPTIONAL, it is considered polite to mirror the type in any replies to a message; furthermore, some specialized applications (e.g., a multi-user chat service) MAY at their discretion enforce the use of a particular message type (e.g., type='groupchat').</t>
      <t>In addition to the 'type' attribute (which differentiates the conversational context of the message), an XMPP message stanza MAY contain any allowable child elements qualified by the 'jabber:client' (or 'jabber:server') namespace, as well as any other properly-namespaced child element.  These payloads are described in the text that follows.</t>
    </section>
    <section title="Specifying a Message Body" anchor="message-body">
      <t>The &lt;body/&gt; element contains human-readable XML character data that specifies the textual contents of the message; this child element is normally included but is OPTIONAL.  The &lt;body/&gt; element MUST NOT possess any attributes, with the exception of the 'xml:lang' attribute.  Multiple instances of the &lt;body/&gt; element MAY be included, but only if each instance possesses an 'xml:lang' attribute with a distinct language value (either explicitly or by inheritance of the 'xml:lang' value of an element farther up in the XML hierarchy, which may include the XML stream header as described in Section 4.4 of <xref target="XMPP-CORE"/>).  The &lt;body/&gt; element MUST NOT contain mixed content (as defined in Section 3.2.2 of <xref target="XML"/>).</t>
      <t>A message stanza often will contain a child &lt;body/&gt; element whose XML character data specifies the primary meaning of the message.</t>
      <figure>
        <preamble>Example: A message with a body:</preamble>
        <artwork><![CDATA[
<message
    to='romeo@example.net'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  <body>Wherefore art thou, Romeo?</body>
  <body xml:lang='cs'>Pro&#x010D;e&#x017D; jsi ty, Romeo?</body>
</message>
        ]]></artwork>
      </figure>
    </section>
    <section title="Specifying a Message Subject" anchor="message-subject">
      <t>The &lt;subject/&gt; element contains human-readable XML character data that specifies the topic of the message.  The &lt;subject/&gt; element MUST NOT possess any attributes, with the exception of the 'xml:lang' attribute.  Multiple instances of the &lt;subject/&gt; element MAY be included for the purpose of providing alternate versions of the same subject, but only if each instance possesses an 'xml:lang' attribute with a distinct language value (either explicitly or by inheritance of the 'xml:lang' value of an element farther up in the XML hierarchy, which may include the XML stream header as described in Section 4.4 of <xref target="XMPP-CORE"/>).  The &lt;subject/&gt; element MUST NOT contain mixed content (as defined in Section 3.2.2 of <xref target="XML"/>).</t>
      <figure>
        <preamble>Example: A message with a subject:</preamble>
        <artwork><![CDATA[
<message
    to='romeo@example.net'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  <subject>I implore you!</subject>
  <subject xml:lang='cs'>
    &#x00DA;p&#x011B;nliv&#x011B; pros&#x00EDm!
  </subject>
  <body>Wherefore art thou, Romeo?</body>
  <body xml:lang='cs'>Pro&#x010D;e&#x017E; jsi ty, Romeo?</body>
</message>
        ]]></artwork>
      </figure>
    </section>
    <section title="Specifying a Conversation Thread" anchor="message-thread">
      <t>The primary use of the XMPP &lt;thread/&gt; element is to uniquely identify a conversation thread or "chat session" between two entities instantiated by &lt;message/&gt; stanzas of type 'chat'.  However, the XMPP &lt;thread/&gt; element may also be used to uniquely identify an analogous thread between two entities instantiated by &lt;message/&gt; stanzas of type 'headline' or 'normal', or among multiple entities in the context of a multi-user chat room instantiated by &lt;message/&gt; stanzas of type 'groupchat'. It may also be used for &lt;message/&gt; stanzas not related to a conversation, such as a game session or between plugins.</t>
      <t>The value of the &lt;thread/&gt; element MUST be a universally unique identifier (UUID) as described in <xref target='UUID'/>.</t>
      <t>The use of the &lt;thread/&gt; element is OPTIONAL and is not used to identify individual messages, only conversations.  A message stanza MUST NOT contain more than one &lt;thread/&gt; element.  The &lt;thread/&gt; element MUST NOT possess any attributes.  The value of the &lt;thread/&gt; element MUST be treated as opaque by entities; no semantic meaning may be derived from it, and only exact comparisons may be made against it.  The &lt;thread/&gt; element MUST NOT contain mixed content (as defined in Section 3.2.2 of <xref target="XML"/>).</t>
    </section>

    <section title="Message Errors" anchor="message-errors">
      <t>If the message stanza is of type "error", it MUST include an &lt;error/&gt; child; for details, see <xref target="XMPP-CORE"/>.</t>
    </section>

    <section title="Extended Namespaces" anchor="message-extended">
      <t>As described in <xref target="XMPP-CORE"/>, an XML stanza MAY contain any properly-namespaced child element; this applies to the message stanza as well.</t>
    </section>

  </section>

  <section title="Exchanging IQ Stanzas" anchor="iq">
    <t>As described in <xref target="XMPP-CORE"/>, IQ stanzas provide a structured request-response mechanism.  The basic semantics of that mechanism (e.g., that the 'id' attribute is required) are defined in <xref target="XMPP-CORE"/>, whereas the specific semantics required to complete particular use cases are defined in all cases by an extended namespace.  Note that the 'jabber:client' and 'jabber:server' namespaces do not define any children of IQ stanzas other than the common &lt;error/&gt;.  This document defines such an extended namespace, for <xref target="roster">Managing the Roster</xref>.  However, an IQ stanza MAY contain structured information qualified by any extended namespace.</t>
  </section>

  <section title="Examples" anchor="examples">
    <t>The examples in this section illustrate a possible instant messaging and presence session.  The user is romeo@example.net, he has an available resource whose resource identifier is "orchard", and he has the following individuals in his roster:</t>
    <t><list style="symbols">
      <t>juliet@example.com (subscription="both" and she has two available resources, one whose resource is "chamber" and another whose resource is "balcony")</t>
      <t>benvolio@example.org (subscription="to")</t>
      <t>mercutio@example.org (subscription="from")</t>
    </list></t>
    <t>First, the user completes the preconditions (stream establishment, TLS and SASL negotiation, and resource binding) described in <xref target='XMPP-CORE'/>; those packet flows are not reproduced here.</t>
    <t>Next, the user requests his roster:</t>
    <figure>
      <preamble>Example 1: Client requests current roster from server:</preamble>
      <artwork><![CDATA[
<iq from='romeo@example.net/balcony' type='get' id='ex1'>
  <query xmlns='jabber:iq:roster'/>
</iq>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 2: Client receives roster from server:</preamble>
      <artwork><![CDATA[
<iq to='romeo@example.com/balcony' type='result' id='ex1'>
  <query xmlns='jabber:iq:roster'>
    <item jid='romeo@example.net'
          name='Juliet'
          subscription='both'>
      <group>Friends</group>
    </item>
    <item jid='benvolio@example.org'
          name='Benvolio'
          subscription='to'/>
    <item jid='mercutio@example.org'
          name='Mercutio'
          subscription='from'/>
  </query>
</iq>
      ]]></artwork>
    </figure>
    <t>Now the user sends initial presence.</t>
    <figure>
      <preamble>Example 3: User sends initial presence:</preamble>
      <artwork><![CDATA[
<presence from='romeo@example.net/orchard'/>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 4: User's server sends presence probes to contacts with subscription="to" and subscription="both" on behalf of the user's available resource:</preamble>
      <artwork><![CDATA[
<presence
    type='probe'
    from='romeo@example.net/orchard'
    to='juliet@example.com'/>

<presence
    type='probe'
    from='romeo@example.net/orchard'
    to='benvolio@example.org'/>
        ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 5: User's server sends initial presence to contacts with subscription="from" and subscription="both" on behalf of the user's available resource:</preamble>
      <artwork><![CDATA[
<presence
    from='romeo@example.net/orchard'
    to='juliet@example.com'/>

<presence
    from='romeo@example.net/orchard'
    to='mercutio@example.org'/>
        ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 6: Contacts' servers reply to presence probe on behalf of all available resources:</preamble>
      <artwork><![CDATA[
<presence
    from='juliet@example.com/balcony'
    to='romeo@example.net/orchard'
    xml:lang='en'>
  <show>away</show>
  <status>be right back</status>
  <priority>0</priority>
</presence>

<presence
    from='juliet@example.com/chamber'
    to='romeo@example.net/orchard'>
  <priority>1</priority>
</presence>

<presence
    from='benvolio@example.org/pda'
    to='romeo@example.net/orchard'
    xml:lang='en'>
  <show>dnd</show>
  <status>gallivanting</status>
</presence>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 7: Contacts' servers deliver user's initial presence to all available resources or return error to user:</preamble>
      <artwork><![CDATA[
<presence
    from='romeo@example.net/orchard'
    to='juliet@example.com/chamber'/>

<presence
    from='romeo@example.net/orchard'
    to='juliet@example.com/balcony'/>

<presence
    type='error'
    from='mercutio@example.org'
    to='romeo@example.net/orchard'>
  <error type='cancel'>
    <gone xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  </error>
</presence>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 8: User sends directed presence to another user not in his roster:</preamble>
      <artwork><![CDATA[
<presence
    from='romeo@example.net/orchard'
    to='nurse@example.com'
    xml:lang='en'>
  <show>dnd</show>
  <status>courting Juliet</status>
  <priority>0</priority>
</presence>
      ]]></artwork>
    </figure>
    <t>Now the user has a threaded conversation (chat session) with one of his contacts.</t>
    <figure>
      <preamble>Example 9: A threaded conversation</preamble>
      <artwork><![CDATA[
<message
    to='romeo@example.net/orchard'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  <body>Art thou not Romeo, and a Montague?</body>
  <thread>e0ffe42b28561960c6b12b944a092794b9683a38</thread>
</message>

<message
    to='juliet@example.com/balcony'
    from='romeo@example.net/orchard'
    type='chat'
    xml:lang='en'>
  <body>Neither, fair saint, if either thee dislike.</body>
  <thread>e0ffe42b28561960c6b12b944a092794b9683a38</thread>
</message>

<message
    to='romeo@example.net/orchard'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  <body>How cam'st thou hither, tell me, and wherefore?</body>
  <thread>e0ffe42b28561960c6b12b944a092794b9683a38</thread>
</message>
      ]]></artwork>
    </figure>
    <t>And so on.</t>
    <t>The user can also send subsequent presence broadcast.</t>
    <figure>
      <preamble>Example 10: User sends updated available presence information for broadcasting:</preamble>
      <artwork><![CDATA[
<presence xml:lang='en'>
  <show>away</show>
  <status>I shall return!</status>
  <priority>1</priority>
</presence>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 11: User's server broadcasts updated presence information only to one contact (not those from whom an error was received or to whom the user sent directed presence):</preamble>
      <artwork><![CDATA[
<presence
    from='romeo@example.net/orchard'
    to='juliet@example.com'
    xml:lang='en'>
  <show>away</show>
  <status>I shall return!</status>
  <priority>1</priority>
</presence>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 12: Contact's server delivers updated presence information to all of the contact's available resources:</preamble>
      <artwork><![CDATA[
[to "balcony" resource...]

<presence
    from='romeo@example.net/orchard'
    to='juliet@example.com'
    xml:lang='en'>
  <show>away</show>
  <status>I shall return!</status>
  <priority>1</priority>
</presence>

[to "chamber" resource...]

<presence
    from='romeo@example.net/orchard'
    to='juliet@example.com'
    xml:lang='en'>
  <show>away</show>
  <status>I shall return!</status>
  <priority>1</priority>
</presence>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 13: One of the contact's resources broadcasts final presence:</preamble>
      <artwork><![CDATA[
<presence from='juliet@example.com/balcony' type='unavailable'/>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 14: Contact's server sends unavailable presence information to user:</preamble>
      <artwork><![CDATA[
<presence
    type='unavailable'
    from='juliet@example.com/balcony'
    to='romeo@example.net/orchard'/>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 15: User sends unavailable presence:</preamble>
      <artwork><![CDATA[
<presence from='romeo@example.net/orchard'
          type='unavailable'
          xml:lang='en'>
  <status>gone home</status>
</presence>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Example 16: User's server broadcasts unavailable presence information to contact as well as to the person to whom the user sent directed presence:</preamble>
      <artwork><![CDATA[
<presence
    type='unavailable'
    from='romeo@example.net/orchard'
    to='juliet@example.com'
    xml:lang='en'>
  <status>gone home</status>
</presence>

<presence
    type='unavailable'
    from='romeo@example.net/orchard'
    to='nurse@example.com'
    xml:lang='en'>
  <status>gone home</status>
</presence>
      ]]></artwork>
    </figure>
    <t>Now the user closes his stream:</t>
    <figure>
      <artwork><![CDATA[
</stream:stream>
      ]]></artwork>
    </figure>
    <t>And the user's server closes its stream as well:</t>
    <figure>
      <artwork><![CDATA[
</stream:stream>
      ]]></artwork>
    </figure>
    <t>THE END</t>
  </section>

  <section title="Server Rules for Handling XML Stanzas" anchor="rules">
    <t>Basic routing and delivery rules for servers are defined in <xref target="XMPP-CORE"/>.  This section defines additional rules for XMPP-compliant instant messaging and presence servers.</t>
    <section title="Inbound Stanzas" anchor="rules-inbound">
      <t>If the hostname of the domain identifier portion of the JID contained in the 'to' attribute of an inbound stanza matches a hostname of the server itself and the JID contained in the 'to' attribute is of the form &lt;user@example.com&gt; or &lt;user@example.com/resource&gt;, the server MUST follow the rules defined in the following list:</t>
      <t><list style="numbers">
        <t>If the JID is of the form &lt;user@domain/resource&gt; and an available resource exactly matches the full JID, the recipient's server MUST deliver the stanza to that resource.</t>
        <t>Else if the JID is of the form &lt;user@domain&gt; or &lt;user@domain/resource&gt; and the associated user account does not exist, the recipient's server (a) SHOULD silently ignore the stanza (i.e., neither deliver it nor return an error) if it is a presence stanza, (b) MUST return a &lt;service-unavailable/&gt; stanza error to the sender if it is an IQ stanza, and (c) SHOULD return a &lt;service-unavailable/&gt; stanza error to the sender if it is a message stanza.</t>
        <t>Else if the JID is of the form &lt;user@domain/resource&gt; and no connected or available resource exactly matches the full JID, the recipient's server (a) SHOULD silently ignore the stanza (i.e., neither deliver it nor return an error) if it is a presence stanza, (b) MUST return a &lt;service-unavailable/&gt; stanza error to the sender if it is an IQ stanza, and (c) SHOULD treat the stanza as if it were addressed to &lt;user@domain&gt; if it is a message stanza.</t>
        <t>Else if the JID is of the form &lt;user@domain&gt; and there is at least one available resource available for the user, the recipient's server MUST follow these rules:
        <list style="numbers">
          <t>For a message stanza of type "headline", the server SHOULD deliver the stanza to all available resources.  For a message stanza of type "chat", "error", "groupchat", or "normal", the server SHOULD deliver the stanza to the highest-priority available resource (if the resource did not provide a value for the &lt;priority/&gt; element, the server SHOULD consider it to have provided a value of zero).  If two or more available resources have the same priority, the server MAY use some other rule (e.g., most recent connect time, most recent activity time, or highest availability as determined by some hierarchy of &lt;show/&gt; values) to choose between them or MAY deliver the message to all such resources.  However, the server MUST NOT deliver the stanza to an available resource with a negative priority; if the only available resource has a negative priority, the server SHOULD handle the message as if there were no available resources (defined in the text that follows).  In addition, the server MUST NOT rewrite the 'to' attribute (i.e., it MUST leave it as &lt;user@domain&gt; rather than change it to &lt;user@domain/resource&gt;).</t>
          <t>For presence stanzas other than those of type "probe", the server MUST deliver the stanza to all available resources; for presence probes, the server SHOULD reply based on the rules defined under <xref target="presence-probes">Presence Probes</xref>.  In addition, the server MUST NOT rewrite the 'to' attribute (i.e., it MUST leave it as &lt;user@domain&gt; rather than change it to &lt;user@domain/resource&gt;).</t>
          <t>For IQ stanzas, the server itself MUST reply on behalf of the user with either an IQ result or an IQ error, and MUST NOT deliver the IQ stanza to the available resources.  Specifically, if the semantics of the qualifying namespace define a reply that the server can provide, the server MUST reply to the stanza on behalf of the user; if not, the server MUST reply with a &lt;service-unavailable/&gt; stanza error.</t>
        </list></t>
        <t>Else if the JID is of the form &lt;user@domain&gt; and there are no available resources associated with the user, how the stanza shall be handled depends on the stanza type:
        <list style="numbers">
          <t>For presence stanzas of type "subscribe", "subscribed", "unsubscribe", and "unsubscribed", the server MUST maintain a record of the stanza and deliver the stanza at least once (i.e., when the user next creates an available resource and requests the roster); in addition, the server MUST continue to deliver presence stanzas of type "subscribe" until the user either approves or denies the subscription request (see also <xref target="sub">Managing Presence Subscriptions</xref>).</t>
          <t>For all other presence stanzas, the server SHOULD silently ignore the stanza by not storing it for later delivery or replying to it on behalf of the user.</t>
          <t>For message stanzas, the server MAY choose to store the stanza on behalf of the user and deliver it when the user next becomes available, or forward the message to the user via some other means (e.g., to the user's email account).  However, if offline message storage or message forwarding is not enabled, the server MUST return to the sender a &lt;service-unavailable/&gt; stanza error.  (Note: Offline message storage and message forwarding are not defined in XMPP, since they are strictly a matter of implementation and service provisioning.)</t>
          <t>For IQ stanzas, the server itself MUST reply on behalf of the user with either an IQ result or an IQ error.  Specifically, if the semantics of the qualifying namespace define a reply that the server can provide, the server MUST reply to the stanza on behalf of the user; if not, the server MUST reply with a &lt;service-unavailable/&gt; stanza error.</t>
        </list></t>
      </list></t>
    </section>
    <section title="Outbound Stanzas" anchor="rules-outbound">
      <t>If the hostname of the domain identifier portion of the address contained in the 'to' attribute of an outbound stanza matches a hostname of the server itself, the server MUST deliver the stanza to a local entity according the rules for <xref target="rules-inbound">Inbound Stanzas</xref>.</t>
      <t>If the hostname of the domain identifier portion of the address contained in the 'to' attribute of an outbound stanza does not match a hostname of the server itself, the server MUST attempt to route the stanza to the foreign domain.  The recommended order of actions is as follows:</t>
      <t><list style='numbers'>
        <t>First attempt to resolve the foreign hostname using an <xref target="SRV"/> Service of "xmpp-server" and Proto of "tcp", resulting in resource records such as "_xmpp-server._tcp.example.com.", as specified in <xref target="XMPP-CORE"/>.</t>
        <t>If the "xmpp-server" address record resolution fails, attempt to resolve the "_im" or "_pres" <xref target="SRV"/> Service as specified in <xref target="IMP-SRV"/>, using the "_im" Service for &lt;message/&gt; stanzas and the "_pres" Service for &lt;presence/&gt; stanzas (it is up to the implementation how to handle &lt;iq/&gt; stanzas).  This will result in one or more resolutions of the form "_im.&lt;proto&gt;.example.com." or "_pres.&lt;proto&gt;.example.com.", where "&lt;proto&gt;" would be a label registered in the Instant Messaging SRV Protocol Label registry or the Presence SRV Protocol Label registry: either "_xmpp" for an XMPP-aware domain or some other IANA-registered label (e.g., "_simple") for a non-XMPP-aware domain.</t>
        <t>If both SRV address record resolutions fail, attempt to perform a normal IPv4/IPv6 address record resolution to determine the IP address using the "xmpp-server" port of 5269 registered with the IANA, as specified in <xref target="XMPP-CORE"/>.</t>
      </list></t>
      <t>Administrators of server deployments are strongly encouraged to keep the _im._xmpp, _pres._xmpp, and _xmpp._tcp SRV records properly synchronized, since different implementations might perform the "_im" and "_pres" lookups before the "xmpp-server" lookup.</t>
    </section>
  </section>

  <section title="IM and Presence Compliance Requirements" anchor="compliance">
    <t>This section summarizes the specific aspects of the Extensible Messaging and Presence Protocol that MUST be supported by instant messaging and presence servers and clients in order to be considered compliant implementations.  All such applications MUST comply with the requirements specified in <xref target="XMPP-CORE"/>.  The text in this section specifies additional compliance requirements for instant messaging and presence servers and clients; note well that the requirements described here supplement but do not supersede the core requirements.  Note also that a server or client MAY support only presence or instant messaging, and is not required to support both if only a presence service or an instant messaging service is desired.</t>
    <section title="Servers" anchor="compliance-server">
      <t>In addition to core server compliance requirements, an instant messaging and presence server MUST additionally support the following protocols:</t>
      <t><list style='symbols'>
        <t>All server-related instant messaging and presence syntax and semantics defined in this document, including presence broadcast on behalf of clients, presence subscriptions, roster storage and manipulation, and IM-specific routing and delivery rules</t>
      </list></t>
    </section>
    <section title="Clients" anchor="compliance-client">
      <t>In addition to core client compliance requirements, an instant messaging and presence client MUST additionally support the following protocols:</t>
      <t><list style='symbols'>
        <t>Generation and handling of the IM-specific semantics of XML stanzas as defined by the XML schemas, including the 'type' attribute of message and presence stanzas as well as their child elements</t>
        <t>All client-related instant messaging syntax and semantics defined in this document, including presence subscriptions and roster management</t>
        <t>End-to-end object encryption as defined in <xref target="XMPP-E2E"/></t>
      </list></t>
      <t>A client MUST also handle addresses that are encoded as "im:" URIs as specified in <xref target="CPIM"/>, and MAY do so by removing the "im:" scheme and entrusting address resolution to the server as specified under <xref target="rules-outbound">Outbound Stanzas</xref>.</t>
    </section>
  </section>

  <section title="Internationalization Considerations" anchor="i18n">
    <t>For internationalization considerations, refer to the relevant section of <xref target="XMPP-CORE"/>.</t>
  </section>

  <section title="Security Considerations" anchor="security">
    <t>Core security considerations for XMPP are defined in the relevant section of <xref target="XMPP-CORE"/>.</t>
    <t>Additional considerations that apply only to instant messaging and presence applications of XMPP are defined in several places within this document; specifically:</t>
    <t><list style="symbols">
      <t>When a server processes an inbound presence stanza of type "probe" whose intended recipient is a user associated with one of the server's hostnames, the server MUST NOT reveal the user's presence information if the sender is an entity that is not authorized to receive that information as determined by presence subscriptions (see <xref target="presence">Exchanging Presence Information</xref>).</t>
      <t>When a server processes an outbound presence stanza with no type or of type "unavailable", it MUST follow the rules defined under <xref target="presence">Exchanging Presence Information</xref> in order to ensure that such presence information is not broadcasted to entities that are not authorized to know such information.</t>
      <t>When a server generates an error stanza in response to receiving a stanza for a user who does not exist, the use of the &lt;service-unavailable/&gt; error condition helps protect against well-known dictionary attacks, since this is the same error condition that is returned if, for instance, the namespace of an IQ child element is not understood, or if offline message storage or message forwarding is not enabled for a domain.</t>
    </list></t>
  </section>

  <section title="IANA Considerations" anchor="ref">
    <t>For a number of related IANA considerations, refer to the relevant section of <xref target="XMPP-CORE"/>.</t>
    <section title="Instant Messaging SRV Protocol Label Registration" anchor="iana-reg-im">
      <t><xref target="IMP-SRV">Address Resolution for Instant Messaging and Presence</xref> defines an Instant Messaging SRV Protocol Label registry for protocols that can provide services that conform to the "_im" SRV Service label.  Because XMPP is one such protocol, the IANA registers the "_xmpp" protocol label in the appropriate registry, as follows:</t>
      <t><list style='hanging'>
        <t hangText='Protocol label:'>_xmpp</t>
        <t hangText='Specification:'>RFC 3921</t>
        <t hangText='Description:'>Instant messaging protocol label for the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3921.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</t>
      </list></t>
    </section>
    <section title="Presence SRV Protocol Label Registration" anchor="iana-reg-pres">
      <t><xref target="IMP-SRV">Address Resolution for Instant Messaging and Presence</xref> defines a Presence SRV Protocol Label registry for protocols that can provide services that conform to the "_pres" SRV Service label.  Because XMPP is one such protocol, the IANA registers the "_xmpp" protocol label in the appropriate registry, as follows:</t>
      <t><list style='hanging'>
        <t hangText='Protocol label:'>_xmpp</t>
        <t hangText='Specification:'>RFC 3921</t>
        <t hangText='Description:'>Presence protocol label for the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3921.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;</t>
      </list></t>
    </section>
  </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor="IMP-REQS">
<front>
<title abbrev='Instant Messaging/Presence Protocol'>Instant Messaging / Presence Protocol Requirements</title>
<author initials='M.' surname='Day' fullname='Mark Day'>
<organization>SightPath, Inc.</organization>
<address>
<postal>
<street>135 Beaver Street</street>
<city>Waltham</city>
<region>MA</region>
<code>02452</code>
<country>US</country></postal>
<email>mday@alum.mit.edu</email></address></author>
<author initials='S.' surname='Aggarwal' fullname='Sonu Aggarwal'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>sonuag@microsoft.com</email></address></author>
<author initials='J.' surname='Vincent' fullname='Jesse Vincent'>
<organization>Into Networks, Inc.</organization>
<address>
<postal>
<street>150 Cambridgepark Drive</street>
<city>Cambridge</city>
<region>MA</region>
<code>02140</code>
<country>US</country></postal>
<email>jesse@intonet.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>Presence and Instant Messaging have recently emerged as a new medium of communications over the Internet.  Presence is a means for finding, retrieving, and subscribing to changes in the presence information (e.g.  "online" or "offline") of other users.  Instant messaging is a means for sending small, simple messages that are delivered immediately to online users.</t>
<t>Applications of presence and instant messaging currently use independent, non-standard and non-interoperable protocols developed by various vendors.  The goal of the Instant Messaging and Presence Protocol (IMPP) Working Group is to define a standard protocol so that independently developed applications of instant messaging and/or   presence can interoperate across the Internet.  This document defines a minimal set of requirements that IMPP must meet.</t></abstract></front>
<seriesInfo name='RFC' value='2779' />
<format type='TXT' octets='47420' target='ftp://ftp.isi.edu/in-notes/rfc2779.txt' />
</reference>

<reference anchor="IMP-SRV">
<front>
<title>Address Resolution for Instant Messaging and Presence</title>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<date year='2004' month='August' /></front>
<seriesInfo name='RFC' value='3861' />
<format type='TXT' octets='15764' target='ftp://ftp.isi.edu/in-notes/rfc3861.txt' />
</reference>

<reference anchor='SRV'>
<front>
<title abbrev='DNS SRV RR'>A DNS RR for specifying the location of services (DNS SRV)</title>
<author initials='A.' surname='Gulbrandsen' fullname='Arnt Gulbrandsen'>
<organization>Troll Tech</organization>
<address>
<postal>
<street>Waldemar Thranes gate 98B</street>
<city>Oslo</city>
<region />
<code>N-0175</code>
<country>NO</country></postal>
<phone>+47 22 806390</phone>
<facsimile>+47 22 806380</facsimile>
<email>arnt@troll.no</email></address></author>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>950 Charter Street</street>
<city>Redwood City</city>
<region>CA</region>
<code>94063</code>
<country>US</country></postal>
<phone>+1 650 779 7001</phone></address></author>
<author initials='L.' surname='Esibov' fullname='Levon Esibov'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>levone@microsoft.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>This document describes a DNS RR which specifies the location of the
   server(s) for a specific protocol and domain.</t></abstract></front>
<seriesInfo name='RFC' value='2782' />
<format type='TXT' octets='24013' target='ftp://ftp.isi.edu/in-notes/rfc2782.txt' />
</reference>

<reference anchor="TERMS">
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass.  Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date month='March' year='1997' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
      NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
      &quot;OPTIONAL&quot; in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='14486' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5661' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<reference anchor='UUID'>
<front>
<title abbrev='UUID URN'>A Universally Unique IDentifier (UUID) URN Namespace</title>
<author initials='P.' surname='Leach' fullname='Paul J. Leach'>
<organization>Microsoft</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<phone>+1 425-882-8080</phone>
<email>paulle@microsoft.com</email></address></author>
<author initials='M.' surname='Mealling' fullname='Michael Mealling'>
<organization>Refactored Networks, LLC</organization>
<address>
<postal>
<street>1635 Old Hwy 41</street>
<street>Suite 112, Box 138</street>
<city>Kennesaw</city>
<region>GA</region>
<code>30152</code>
<country>US</country></postal>
<phone>+1-678-581-9656</phone>
<email>michael@refactored-networks.com</email>
<uri>http://www.refactored-networks.com</uri></address></author>
<author initials='R.' surname='Salz' fullname='Rich Salz'>
<organization>DataPower Technology, Inc.</organization>
<address>
<postal>
<street>1 Alewife Center</street>
<city>Cambridge</city>
<region>MA</region>
<code>02142</code>
<country>US</country></postal>
<phone>+1 617-864-0455</phone>
<email>rsalz@datapower.com</email>
<uri>http://www.datapower.com</uri></address></author>
<date year='2005' month='July' />
<keyword>URN, UUID</keyword>
<abstract>
<t>This specification defines a Uniform Resource Name namespace for
      UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally
      Unique IDentifier). A UUID is 128 bits long, and can
      guarantee uniqueness across space and time. UUIDs were originally
      used in the Apollo Network Computing System and later in the Open
      Software Foundation's (OSF) Distributed Computing Environment (DCE),
      and then in Microsoft Windows platforms.</t>
<t>This specification is derived from the DCE specification with the
      kind permission of the OSF (now known as The Open Group).  Information from earlier versions of the DCE specification have been	
      incorporated into this document.</t></abstract></front>
<seriesInfo name='RFC' value='4122' />
<format type='TXT' octets='59319' target='ftp://ftp.isi.edu/in-notes/rfc4122.txt' />
<format type='HTML' octets='81761' target='http://xml.resource.org/public/rfc/html/rfc4122.html' />
<format type='XML' octets='62848' target='http://xml.resource.org/public/rfc/xml/rfc4122.xml' />
</reference>

<reference anchor="XML" target="http://www.w3.org/TR/REC-xml">
  <front>
    <title>Extensible Markup Language (XML) 1.0 (2nd ed)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray">
      <organization>Textuality and Netscape</organization>
      <address>
        <email>tbray@textuality.com</email>
      </address>
    </author>
    <author initials="J." surname="Paoli" fullname="Jean Paoli">
      <organization>Microsoft</organization>
      <address>
        <email>jeanpa@microsoft.com</email>
      </address>
    </author>
    <author initials="C.M." surname="Sperberg-McQueen" fullname="C.  M.  Sperberg-McQueen">
      <organization>University of Illinois at Chicago and Text Encoding Initiative</organization>
      <address>
        <email>cmsmcq@uic.edu</email>
      </address>
    </author>
    <author initials="E." surname="Maler" fullname="Eve Maler">
      <organization>Sun Microsystems</organization>
      <address>
        <email>eve.maler@east.sun.com</email>
      </address>
    </author>
    <date day="6" month="October" year="2000"/>
  </front>
  <seriesInfo name="W3C" value="REC-xml"/>
</reference>

<reference anchor="XML-NAMES" target="http://www.w3.org/TR/REC-xml-names">
  <front>
    <title>Namespaces in XML</title>
    <author initials="T." surname="Bray" fullname="Tim Bray">
      <organization>Textuality</organization>
      <address>
        <email>tbray@textuality.com</email>
      </address>
    </author>
    <author initials="D." surname="Hollander" fullname="Dave Hollander">
      <organization>Hewlett-Packard Company</organization>
      <address>
        <email>dmh@corp.hp.com</email>
      </address>
    </author>
    <author initials="A." surname="Layman" fullname="Andrew Layman">
      <organization>Microsoft</organization>
      <address>
        <email>andrewl@microsoft.com</email>
      </address>
    </author>
    <date day="14" month="January" year="1999"/>
  </front>
  <seriesInfo name="W3C" value="REC-xml-names"/>
</reference>

<reference anchor="XMPP-CORE">
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='April' day='17' year='2007' />
<abstract><t>This memo defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a technology for streaming Extensible Markup Language (XML) elements in order to exchange structured information in close to real time between any two network-aware entities. XMPP provides a generalized, extensible framework for incrementally exchanging XML data, upon which a variety of applications can be built. The framework includes methods for stream setup and teardown, channel encryption, authentication of a client to a server and of one server to another server, and primitives for push-style messages, publication of presence and availability information, and request-response interactions between any two XMPP entities. This document also specifies the format for XMPP addresses, which are fully internationalizable. This document obsoletes RFC 3920.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-saintandre-rfc3920bis-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-saintandre-rfc3920bis-02.txt' />
</reference>

<reference anchor="XMPP-E2E">
  <front>
    <title>End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP)</title>
    <author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'>
      <organization>Jabber Software Foundation</organization>
    </author>
    <date year='2004' month='October' />
  </front>
  <seriesInfo name='RFC' value='3923' />
  <format type='TXT' octets='51828' target='ftp://ftp.isi.edu/in-notes/rfc3923.txt' />
</reference>

    </references>

    <references title="Informative References">

<reference anchor="CPIM">
<front>
<title>Common Profile for Instant Messaging (CPIM)</title>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<date year='2004' month='August' /></front>
<seriesInfo name='RFC' value='3860' />
<format type='TXT' octets='26486' target='ftp://ftp.isi.edu/in-notes/rfc3860.txt' />
</reference>

<reference anchor="IMP-MODEL">
<front>
<title>A Model for Presence and Instant Messaging</title>
<author initials='M.' surname='Day' fullname='Mark Day'>
<organization>SightPath, Inc.</organization>
<address>
<postal>
<street>135 Beaver Street</street>
<city>Waltham</city>
<region>MA</region>
<code>02452</code>
<country>US</country></postal>
<email>mday@alum.mit.edu</email></address></author>
<author initials='J.' surname='Rosenberg' fullname='Jonathan Rosenberg'>
<organization>dynamicsoft</organization>
<address>
<postal>
<street>200 Executive Drive</street>
<street>Suite 120</street>
<city>West Orange</city>
<region>NJ</region>
<code>07046</code>
<country>US</country></postal>
<email>jdrosen@dynamicsoft.com</email></address></author>
<author initials='H.' surname='Sugano' fullname='Hiroyasu Sugano'>
<organization>Fujitsu Laboratories Ltd.</organization>
<address>
<postal>
<street>64 Nishiwaki</street>
<street>Ohkubo-cho</street>
<city>Akashi</city>
<region />
<code>674-8555</code>
<country>JP</country></postal>
<email>suga@flab.fujitsu.co.jp</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>This document defines an abstract model for a presence and instant messaging system.  It defines the various entities involved, defines terminology, and outlines the services provided by the system.  The goal is to provide a common vocabulary for further work on requirements for protocols and markup for presence and instant messaging.</t></abstract></front>
<seriesInfo name='RFC' value='2778' />
</reference>

<reference anchor='IRC'>
<front>
<title>Internet Relay Chat: Architecture</title>
<author initials='C.' surname='Kalt' fullname='C. Kalt'>
<organization /></author>
<date year='2000' month='April' />
<abstract>
<t>&lt;p>This document is an update describing the architecture of the current IRC protocol and the role of its different components. Other documents describe in detail the protocol used between the various components defined here. This memo provides information for the Internet community. &lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='2810' />
<format type='TXT' octets='19087' target='ftp://ftp.isi.edu/in-notes/rfc2810.txt' />
</reference>

<reference anchor="SASL">
<front>
<title>Simple Authentication and Security Layer (SASL)</title>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'>
<organization /></author>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>&lt;p>The Simple Authentication and Security Layer (SASL) is a framework for providing authentication and data security services in connection-oriented protocols via replaceable mechanisms. It provides a structured interface between protocols and mechanisms. The resulting framework allows new protocols to reuse existing mechanisms and allows old protocols to make use of new mechanisms. The framework also provides a protocol for securing subsequent protocol exchanges within a data security layer.&lt;/p>&lt;p> This document describes how a SASL mechanism is structured, describes how protocols include support for SASL, and defines the protocol for carrying a data security layer over a connection. In addition, this document defines one SASL mechanism, the EXTERNAL mechanism.&lt;/p>&lt;p> This document obsoletes RFC 2222. [STANDARDS TRACK]&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='4422' />
<format type='TXT' octets='73206' target='ftp://ftp.isi.edu/in-notes/rfc4422.txt' />
</reference>

<reference anchor='TLS'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.1</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2006' month='April' />
<abstract>
<t>&lt;p>This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='4346' />
<format type='TXT' octets='187041' target='ftp://ftp.isi.edu/in-notes/rfc4346.txt' />
</reference>

<reference anchor="XEP-0016">
  <front>
    <title>Privacy Lists</title>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address/>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="15" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0016"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0016.html"/>
</reference>

<reference anchor="XEP-0045">
  <front>
    <title>Multi-User Chat</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="10" month="April" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0045"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0045.html"/>
</reference>

<reference anchor="XEP-0054">
  <front>
    <title>vcard-temp</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="26" month="March" year="2003"/>
  </front>
  <seriesInfo name="XSF XEP" value="0054"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0054.html"/>
</reference>

<reference anchor="XEP-0191">
  <front>
    <title>Simple Communications Blocking</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="15" month="February" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0191"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0191.html"/>
</reference>

<reference anchor="VCARD">
<front>
<title>vCard MIME Directory Profile</title>
<author initials='F.' surname='Dawson' fullname='Frank Dawson'>
<organization>Lotus Development Corporation</organization>
<address>
<postal>
<street>6544 Battleford Drive</street>
<street>Raleigh</street>
<street>NC 27613</street>
<country>USA</country></postal>
<phone>+1-919-676-9515</phone>
<email>frank_dawson@lotus.com</email></address></author>
<author initials='T.' surname='Howes' fullname='Tim Howes'>
<organization>Netscape Communications Corp.</organization>
<address>
<postal>
<street>501 East Middlefield Rd.</street>
<street>Mountain View</street>
<street>CA 94041</street>
<country>USA</country></postal>
<phone>+1.415.937.3419</phone>
<email>howes@netscape.com</email></address></author>
<date month='September' year='1998' />
<area>Applications</area>
<keyword>MIME</keyword>
<keyword>audio</keyword>
<keyword>content-type</keyword>
<keyword>directory</keyword>
<keyword>multipurpose internet mail extensions</keyword>
<abstract>
<t>
   This memo defines the profile of the MIME Content-Type  for
   directory information for a white-pages person object, based on a
   vCard electronic business card.  The profile definition is independent
   of any particular directory service or protocol.  The profile is
   defined for representing and exchanging a variety of information
   about an individual (e.g., formatted and structured name and delivery
   addresses, email address, multiple telephone numbers, photograph,
   logo, audio clips, etc.).  The directory information used by this
   profile is based on the attributes for the person object defined in
   the X.520 and X.521 directory services recommendations.  The profile
   also provides the method for including a  representation of a
   white-pages directory entry within the MIME Content-Type defined by
   the  document.
</t>
<t>
   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in .
</t></abstract></front>
<seriesInfo name='RFC' value='2426' />
<format type='HTML' octets='96516' target='http://xml.resource.org/public/rfc/html/rfc2426.html' />
<format type='XML' octets='77828' target='http://xml.resource.org/public/rfc/xml/rfc2426.xml' />
</reference>

    </references>

  <section title="Integration of Roster Management and Presence Subscriptions" anchor="int">
    <t>This Appendix provides a detailed description of how roster management and presence subscriptions are integrated in XMPP-based instant messaging and presence applications, mainly for the benefit of server developers (most of the complexity specified here can be safely ignored by client developers).</t>
    <section title="Overview" anchor="int-overview">
      <t>Some level of integration between roster items and presence subscriptions is normally expected by an instant messaging user regarding the user's subscriptions to and from other contacts.  This section describes the level of integration that MUST be supported within XMPP instant messaging applications.</t>
      <t>There are four primary subscription states:</t>
      <t><list style='symbols'>
        <t>None -- the user does not have a subscription to the contact's presence information, and the contact does not have a subscription to the user's presence information</t>
        <t>To -- the user has a subscription to the contact's presence information, but the contact does not have a subscription to the user's presence information</t>
        <t>From -- the contact has a subscription to the user's presence information, but the user does not have a subscription to the contact's presence information</t>
        <t>Both -- both the user and the contact have subscriptions to each other's presence information (i.e., the union of 'from' and 'to')</t>
      </list></t>
      <t>Each of these states is reflected in the roster of both the user and the contact, thus resulting in durable subscription states.  Narrative explanations of how these subscription states interact with roster items in order to complete certain defined use cases are provided in the following sub-sections.  Full details regarding server and client handling of all subscription states (including pending states between the primary states listed above) is provided in <xref target='substates'>Subscription States</xref>.</t>
      <t>The server MUST NOT send presence subscription requests or roster pushes to unavailable resources, nor to available resources that have not requested the roster.</t>
      <t>The 'from' and 'to' addresses are OPTIONAL in roster pushes; if included, their values SHOULD be the full JID of the resource for that session.  A client MUST acknowledge each roster push with an IQ stanza of type "result" (for the sake of brevity, these stanzas are not shown in the following examples but are required by the IQ semantics defined in <xref target="XMPP-CORE"/>).</t>
    </section>
    <section title="User Subscribes to Contact" anchor="int-sub">
      <t>The process by which a user subscribes to a contact, including the interaction between roster items and subscription states, is as follows.</t>
      <t><list style="numbers">
        <t>In preparation for being able to render the contact in the user's client interface and for the server to keep track of the subscription, the user's client SHOULD perform a "roster set" for the new roster item.  This request consists of sending an IQ stanza of type='set' containing a &lt;query/&gt; element qualified by the 'jabber:iq:roster' namespace, which in turn contains an &lt;item/&gt; element that defines the new roster item; the &lt;item/&gt; element MUST possess a 'jid' attribute, MAY possess a 'name' attribute, MUST NOT possess a 'subscription' attribute, and MAY contain one or more &lt;group/&gt; child elements:
          <figure><artwork><![CDATA[
<iq type='set' id='set1'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>
          ]]></artwork></figure>
        </t>
        <t>As a result, the user's server (1) MUST initiate a roster push for the new roster item to all available resources associated with this user that have requested the roster, setting the 'subscription' attribute to a value of "none"; and (2) MUST reply to the sending resource with an IQ result indicating the success of the roster set:
          <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='none'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<iq type='result' id='set1'/>
          ]]></artwork></figure>
        </t>
        <t>If the user wants to request a subscription to the contact's presence information, the user's client MUST send a presence stanza of type='subscribe' to the contact:
          <figure><artwork><![CDATA[
<presence to='contact@example.org' type='subscribe'/>
          ]]></artwork></figure>
        </t>
        <t>As a result, the user's server MUST initiate a second roster push to all of the user's interested resources, setting the contact to the pending sub-state of the 'none' subscription state; this pending sub-state is denoted by the inclusion of the ask='subscribe' attribute in the roster item:
          <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='none'
        ask='subscribe'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>
          ]]></artwork>
          <postamble>Note: If the user did not create a roster item before sending the subscription request, the server MUST now create one on behalf of the user, then send a roster push to all of the user's interested resources, absent the 'name' attribute and the &lt;group/&gt; child shown above.</postamble>
          </figure>
        </t>
        <t>The user's server MUST also stamp the presence stanza of type "subscribe" with the user's bare JID (i.e., &lt;user@example.com&gt;) as the 'from' address (if the user provided a 'from' address set to the user's full JID, the server SHOULD remove the resource identifier).  If the contact is served by a different host than the user, the user's server MUST route the presence stanza to the contact's server for delivery to the contact (this case is assumed throughout; however, if the contact is served by the same host, then the server can simply deliver the presence stanza directly):
          <figure><artwork><![CDATA[
<presence
    from='user@example.com'
    to='contact@example.org'
    type='subscribe'/>
            ]]></artwork>
            <postamble>Note: If the user's server receives a presence stanza of type "error" from the contact's server, it MUST deliver the error stanza to the user, whose client MAY determine that the error is in response to the outgoing presence stanza of type "subscribe" it sent previously (e.g., by tracking an 'id' attribute) and then choose to resend the "subscribe" request or revert the roster to its previous state by sending a presence stanza of type "unsubscribe" to the contact.</postamble>
          </figure>
        </t>
        <t>Upon receiving the presence stanza of type "subscribe" addressed to the contact, the contact's server MUST determine if there is at least one available resource from which the contact has requested the roster.  If so, it MUST deliver the subscription request to the contact (if not, the contact's server MUST store the subscription request offline for delivery when this condition is next met; normally this is done by adding a roster item for the contact to the user's roster, with a state of "None + Pending In" as defined under <xref target="substates">Subscription States</xref>, however a server SHOULD NOT push or deliver roster items in that state to the contact).  No matter when the subscription request is delivered, the contact must decide whether or not to approve it (subject to the contact's configured preferences, the contact's client MAY approve or refuse the subscription request without presenting it to the contact).  Here we assume the "happy path" that the contact approves the subscription request (the alternate flow of declining the subscription request is defined in <xref target="int-sub-alt"/>).  In this case, the contact's client (1) SHOULD perform a roster set specifying the desired handle and group for the user (if any); and (2) MUST send a presence stanza of type "subscribed" to the user in order to approve the subscription request.
          <figure><artwork><![CDATA[
<iq type='set' id='set2'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence to='user@example.com' type='subscribed'/>
          ]]></artwork></figure>
        </t>
        <t>As a result, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing a roster item for the user with the subscription state set to 'from' (the server MUST send this even if the contact did not perform a roster set); (2) MUST return an IQ result to the sending resource indicating the success of the roster set; (3) MUST route the presence stanza of type "subscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@example.org&gt;) of the contact; and (4) MUST send available presence from all of the contact's available resources to the user:
          <figure><artwork><![CDATA[
<iq type='set' to='contact@example.org/resource'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='from'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<iq type='result' to='contact@example.org/resource' id='set2'/>

<presence
    from='contact@example.org'
    to='user@example.com'
    type='subscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'/>
            ]]></artwork>
            <postamble>Note: If the contact's server receives a presence stanza of type "error" from the user's server, it MUST deliver the error stanza to the contact, whose client MAY determine that the error is in response to the outgoing presence stanza of type "subscribed" it sent previously (e.g., by tracking an 'id' attribute) and then choose to resend the "subscribed" notification or revert the roster to its previous state by sending a presence stanza of type "unsubscribed" to the user.</postamble>
          </figure>
        </t>
        <t>Upon receiving the presence stanza of type "subscribed" addressed to the user, the user's server MUST first verify that the contact is in the user's roster with either of the following states: (a) subscription='none' and ask='subscribe' or (b) subscription='from' and ask='subscribe'.  If the contact is not in the user's roster with either of those states, the user's server MUST silently ignore the presence stanza of type "subscribed" (i.e., it MUST NOT route it to the user, modify the user's roster, or generate a roster push to the user's available resources).  If the contact is in the user's roster with either of those states, the user's server (1) MUST deliver the presence stanza of type "subscribed" from the contact to the user; (2) MUST initiate a roster push to all of the user's interested resources, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "to"; and (3) MUST deliver the available presence stanza received from each of the contact's available resources to each of the user's available resources:
          <figure><artwork><![CDATA[
<presence
    to='user@example.com'
    from='contact@example.org'
    type='subscribed'/>

<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='to'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<presence
    from='contact@example.org/resource'
    to='user@example.com/resource'/>
          ]]></artwork></figure>
        </t>
      </list></t>
      <t>From the perspective of the user, there now exists a subscription to the contact's presence information; from the perspective of the contact, there now exists a subscription from the user.</t>
      <section title="Alternate Flow: Contact Declines Subscription Request" anchor="int-sub-alt">
        <t>The above activity flow represents the "happy path" regarding the user's subscription request to the contact.  The main alternate flow occurs if the contact refuses the user's subscription request, as follows:</t>
        <t><list style="numbers">
          <t>If the contact wants to refuse the request, the contact's client MUST send a presence stanza of type "unsubscribed" to the user (instead of the presence stanza of type "subscribed" sent in Step 6 of <xref target="int-sub"/>):
            <figure><artwork><![CDATA[
<presence to='user@example.com' type='unsubscribed'/>
            ]]></artwork></figure>
          </t>
          <t>As a result, the contact's server MUST route the presence stanza of type "unsubscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@example.org&gt;) of the contact:
            <figure>
              <artwork><![CDATA[
<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>
              ]]></artwork>
              <postamble>Note: If the contact's server previously added the user to the contact's roster for tracking purposes, it MUST remove the relevant item at this time.</postamble>
            </figure>
          </t>
          <t>Upon receiving the presence stanza of type "unsubscribed" addressed to the user, the user's server (1) MUST deliver that presence stanza to the user and (2) MUST initiate a roster push to all of the user's interested resources, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "none" and with no 'ask' attribute:
            <figure><artwork><![CDATA[
<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='none'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>
            ]]></artwork></figure>
          </t>
        </list></t>
        <t>As a result of this activity, the contact is now in the user's roster with a subscription state of "none", whereas the user is not in the contact's roster at all.</t>
      </section>
    </section>
    <section title="Creating a Mutual Subscription" anchor="int-mutual">
      <t>The user and contact can build on the "happy path" described above to create a mutual subscription (i.e., a subscription of type "both").  The process is as follows:</t>
      <t><list style="numbers">
        <t>If the contact wants to create a mutual subscription, the contact MUST send a subscription request to the user (subject to the contact's configured preferences, the contact's client MAY send this automatically):
          <figure><artwork><![CDATA[
<presence to='user@example.com' type='subscribe'/>
          ]]></artwork></figure>
        </t>
        <t>As a result, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, with the user still in the 'from' subscription state but with a pending 'to' subscription denoted by the inclusion of the ask='subscribe' attribute in the roster item; and (2) MUST route the presence stanza of type "subscribe" to the user, first stamping the 'from' address as the bare JID (&lt;contact@example.org&gt;) of the contact:
          <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='from'
        ask='subscribe'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='contact@example.org'
    to='user@example.com'
    type='subscribe'/>
            ]]></artwork>
            <postamble>Note: If the contact's server receives a presence stanza of type "error" from the user's server, it MUST deliver the error stanza to the contact, whose client MAY determine that the error is in response to the outgoing presence stanza of type "subscribe" it sent previously (e.g., by tracking an 'id' attribute) and then choose to resend the "subscribe" request or revert the roster to its previous state by sending a presence stanza of type "unsubscribe" to the user.</postamble>
          </figure>
        </t>
        <t>Upon receiving the presence stanza of type "subscribe" addressed to the user, the user's server must determine if there is at least one available resource for which the user has requested the roster.  If so, the user's server MUST deliver the subscription request to the user (if not, it MUST store the subscription request offline for delivery when this condition is next met).  No matter when the subscription request is delivered, the user must then decide whether or not to approve it (subject to the user's configured preferences, the user's client MAY approve or refuse the subscription request without presenting it to the user).  Here we assume the "happy path" that the user approves the subscription request (the alternate flow of declining the subscription request is defined in <xref target="int-mutual-alt"/>).  In this case, the user's client MUST send a presence stanza of type "subscribed" to the contact in order to approve the subscription request.
          <figure><artwork><![CDATA[
<presence to='contact@example.org' type='subscribed'/>
          ]]></artwork></figure>
        </t>
        <t>As a result, the user's server (1) MUST initiate a roster push to all of the user's interested resources, containing a roster item for the contact with the 'subscription' attribute set to a value of "both"; (2) MUST route the presence stanza of type "subscribed" to the contact, first stamping the 'from' address as the bare JID (&lt;user@example.com&gt;) of the user; and (3) MUST send to the contact the full XML of the last presence stanza with no 'to' attribute received by the server from each of the user's available resources:
          <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='both'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='subscribed'/>

<presence
    from='user@example.com/resource'
    to='contact@example.org'/>
            ]]></artwork>
            <postamble>Note: If the user's server receives a presence stanza of type "error" from the contact's server, it MUST deliver the error stanza to the user, whose client MAY determine that the error is in response to the outgoing presence stanza of type "subscribed" it sent previously (e.g., by tracking an 'id' attribute) and then choose to resend the subscription request or revert the roster to its previous state by sending a presence stanza of type "unsubscribed" to the contact.</postamble>
          </figure>
        </t>
        <t>Upon receiving the presence stanza of type "subscribed" addressed to the contact, the contact's server MUST first verify that the user is in the contact's roster with either of the following states: (a) subscription='none' and ask='subscribe' or (b) subscription='from' and ask='subscribe'.  If the user is not in the contact's roster with either of those states, the contact's server MUST silently ignore the presence stanza of type "subscribed" (i.e., it MUST NOT route it to the contact, modify the contact's roster, or generate a roster push to the contact's available resources).  If the user is in the contact's roster with either of those states, the contact's server (1) MUST deliver the presence stanza of type "subscribed" from the user to the contact; (2) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "both"; and (3) MUST deliver the available presence stanza received from each of the user's available resources to each of the contact's available resources:
          <figure><artwork><![CDATA[
<presence
    from='user@example.com'
    to='contact@example.org'
    type='subscribed'/>

<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='both'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com/resource'
    to='contact@example.org/resource'/>
          ]]></artwork></figure>
        </t>
      </list></t>
      <t>The user and the contact now have a mutual subscription to each other's presence -- i.e., the subscription is of type "both".</t>
      <section title="Alternate Flow: User Declines Subscription Request" anchor="int-mutual-alt">
        <t>The above activity flow represents the "happy path" regarding the contact's subscription request to the user.  The main alternate flow occurs if the user refuses the contact's subscription request, as follows:</t>
        <t><list style="numbers">
          <t>If the user wants to refuse the request, the user's client MUST send a presence stanza of type "unsubscribed" to the contact (instead of the presence stanza of type "subscribed" sent in Step 3 of <xref target="int-mutual"/>):
            <figure><artwork><![CDATA[
<presence to='contact@example.org' type='unsubscribed'/>
            ]]></artwork></figure>
          </t>
          <t>As a result, the user's server MUST route the presence stanza of type "unsubscribed" to the contact, first stamping the 'from' address as the bare JID (&lt;user@example.com&gt;) of the user:
            <figure><artwork><![CDATA[
<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribed'/>
            ]]></artwork></figure>
          </t>
          <t>Upon receiving the presence stanza of type "unsubscribed" addressed to the contact, the contact's server (1) MUST deliver that presence stanza to the contact; and (2) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "from" and with no 'ask' attribute:
            <figure><artwork><![CDATA[
<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribed'/>

<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='from'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>
            ]]></artwork></figure>
          </t>
        </list></t>
        <t>As a result of this activity, there has been no change in the subscription state; i.e., the contact is in the user's roster with a subscription state of "to" and the user is in the contact's roster with a subscription state of "from".</t>
      </section>
    </section>
    <section title="Unsubscribing" anchor="int-unsub">
      <t>At any time after subscribing to a contact's presence information, a user MAY unsubscribe.  While the XML that the user sends to make this happen is the same in all instances, the subsequent subscription state is different depending on the subscription state obtaining when the unsubscribe "command" is sent.  Both possible scenarios are described in the text that follows.</t>
      <section title="Case #1: Unsubscribing When Subscription is Not Mutual">
        <t>In the first case, the user has a subscription to the contact's presence information but the contact does not have a subscription to the user's presence information (i.e., the subscription is not yet mutual).</t>
        <t><list style="numbers">
          <t>If the user wants to unsubscribe from the contact's presence information, the user MUST send a presence stanza of type "unsubscribe" to the contact:
            <figure><artwork><![CDATA[
<presence to='contact@example.org' type='unsubscribe'/>
            ]]></artwork></figure>
          </t>
          <t>As a result, the user's server (1) MUST send a roster push to all of the user's interested resources, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "none"; and (2) MUST route the presence stanza of type "unsubscribe" to the contact, first stamping the 'from' address as the bare JID (&lt;user@example.com&gt;) of the user:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='none'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribe'/>
            ]]></artwork></figure>
          </t>
          <t>Upon receiving the presence stanza of type "unsubscribe" addressed to the contact, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "none" (if the contact is unavailable or has not requested the roster, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST deliver the "unsubscribe" state change notification to the contact:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='none'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribe'/>
            ]]></artwork></figure>
          </t>
          <t>The contact's server then (1) MUST send a presence stanza of type "unsubscribed" to the user; and (2) SHOULD send unavailable presence from all of the contact's available resources to the user:
            <figure><artwork><![CDATA[
<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
          <t>When the user's server receives the presence stanzas of type "unsubscribed" and "unavailable", it MUST deliver them to the user:
            <figure><artwork><![CDATA[
<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
        </list></t>
      </section>
      <section title="Case #2: Unsubscribing When Subscription is Mutual">
        <t>In the second case, the user has a subscription to the contact's presence information and the contact also has a subscription to the user's presence information (i.e., the subscription is mutual).</t>
        <t><list style="numbers">
          <t>If the user wants to unsubscribe from the contact's presence information, the user MUST send a presence stanza of type "unsubscribe" to the contact:
            <figure><artwork><![CDATA[
<presence to='contact@example.org' type='unsubscribe'/>
            ]]></artwork></figure>
          </t>
          <t>As a result, the user's server (1) MUST send a roster push to all of the user's interested resources, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "from"; and (2) MUST route the presence stanza of type "unsubscribe" to the contact, first stamping the 'from' address as the bare JID (&lt;user@example.com&gt;) of the user:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='from'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribe'/>
            ]]></artwork></figure>
          </t>
          <t>Upon receiving the presence stanza of type "unsubscribe" addressed to the contact, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "to" (if the contact is unavailable or has not requested the roster, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST deliver the "unsubscribe" state change notification to the contact:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='to'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribe'/>
            ]]></artwork></figure>
          </t>
          <t>The contact's server then (1) MUST send a presence stanza of type "unsubscribed" to the user; and (2) SHOULD send unavailable presence from all of the contact's available resources to the user:
            <figure><artwork><![CDATA[
<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
          <t>When the user's server receives the presence stanzas of type "unsubscribed" and "unavailable", it MUST deliver them to the user:
            <figure><artwork><![CDATA[
<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
        </list></t>
        <t>Note: Obviously this does not result in removal of the roster item from the user's roster, and the contact still has a subscription to the user's presence information.  In order to both completely cancel a mutual subscription and fully remove the roster item from the user's roster, the user SHOULD update the roster item with subscription='remove' as defined under <xref target="int-remove">Removing a Roster Item and Cancelling All Subscriptions</xref>.</t>
      </section>
    </section>
    <section title="Cancelling a Subscription" anchor="int-cancel">
      <t>At any time after approving a subscription request from a user, a contact MAY cancel that subscription.  While the XML that the contact sends to make this happen is the same in all instances, the subsequent subscription state is different depending on the subscription state obtaining when the cancellation was sent.  Both possible scenarios are described in the text that follows.</t>
      <section title="Case #1: Cancelling When Subscription is Not Mutual">
        <t>In the first case, the user has a subscription to the contact's presence information but the contact does not have a subscription to the user's presence information (i.e., the subscription is not yet mutual).</t>
        <t><list style="numbers">
          <t>If the contact wants to cancel the user's subscription, the contact MUST send a presence stanza of type "unsubscribed" to the user:
            <figure><artwork><![CDATA[
<presence to='user@example.com' type='unsubscribed'/>
            ]]></artwork></figure>
          </t>
          <t>As a result, the contact's server (1) MUST send a roster push to all of the contact's interested resources, containing an updated roster item for the user with the 'subscription' attribute set to a value of "none"; (2) MUST route the presence stanza of type "unsubscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@example.org&gt;) of the contact; and (3) SHOULD send unavailable presence from all of the contact's available resources to the user:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='none'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
          <t>Upon receiving the presence stanza of type "unsubscribed" addressed to the user, the user's server (1) MUST initiate a roster push to all of the user's interested resources, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "none" (if the user is unavailable or has not requested the roster, the user's server MUST modify the roster item and send that modified item the next time the user requests the roster); (2) MUST deliver the "unsubscribed" state change notification to all of the user's available resources; and (3) MUST deliver the unavailable presence to all of the user's available resources:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='none'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
        </list></t>
      </section>
      <section title="Case #2: Cancelling When Subscription is Mutual">
        <t>In the second case, the user has a subscription to the contact's presence information and the contact also has a subscription to the user's presence information (i.e., the subscription is mutual).</t>
        <t><list style="numbers">
          <t>If the contact wants to cancel the user's subscription, the contact MUST send a presence stanza of type "unsubscribed" to the user:
            <figure><artwork><![CDATA[
<presence to='user@example.com' type='unsubscribed'/>
            ]]></artwork></figure>
          </t>
          <t>As a result, the contact's server (1) MUST send a roster push to all of the contact's interested resources, containing an updated roster item for the user with the 'subscription' attribute set to a value of "to"; (2) MUST route the presence stanza of type "unsubscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@example.org&gt;) of the contact; and (3) SHOULD send unavailable presence from all of the contact's available resources to all of the user's available resources:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='to'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
          <t>Upon receiving the presence stanza of type "unsubscribed" addressed to the user, the user's server (1) MUST initiate a roster push to all of the user's interested resources, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "from" (if the user is unavailable or has not requested the roster, the user's server MUST modify the roster item and send that modified item the next time the user requests the roster); and (2) MUST deliver the "unsubscribed" state change notification to all of the user's available resources; and (3) MUST deliver the unavailable presence to all of the user's available resources:
            <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='from'
        name='MyContact'>
      <group>MyBuddies</group>
    </item>
  </query>
</iq>

<presence
    from='contact@example.org'
    to='user@example.com'
    type='unsubscribed'/>

<presence
    from='contact@example.org/resource'
    to='user@example.com'
    type='unavailable'/>
            ]]></artwork></figure>
          </t>
        </list></t>
        <t>Note: Obviously this does not result in removal of the roster item from the contact's roster, and the contact still has a subscription to the user's presence information.  In order to both completely cancel a mutual subscription and fully remove the roster item from the contact's roster, the contact should update the roster item with subscription='remove' as defined under <xref target="int-remove">Removing a Roster Item and Cancelling All Subscriptions</xref>.</t>
      </section>
    </section>
    <section title="Removing a Roster Item and Cancelling All Subscriptions" anchor="int-remove">
      <t>Because there may be many steps involved in completely removing a roster item and cancelling subscriptions in both directions, the roster management protocol includes a "shortcut" method for doing so.  The process may be initiated no matter what the current subscription state is by sending a roster set containing an item for the contact with the 'subscription' attribute set to a value of "remove":</t>
      <figure><artwork><![CDATA[
<iq type='set' id='remove1'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='remove'/>
  </query>
</iq>
      ]]></artwork></figure>
      <t>When the user removes a contact from his or her roster by setting the 'subscription' attribute to a value of "remove", the user's server (1) MUST automatically cancel any existing presence subscription between the user and the contact (both 'to' and 'from' as appropriate); (2) MUST remove the roster item from the user's roster and inform all of the user's interested resources of the roster item removal; (3) MUST inform the resource that initiated the removal of success; and (4) SHOULD send unavailable presence from all of the user's available resources to the contact:</t>
      <figure><artwork><![CDATA[
<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribe'/>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribed'/>

<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='contact@example.org'
        subscription='remove'/>
  </query>
</iq>

<iq type='result' id='remove1'/>

<presence
    from='user@example.com/resource'
    to='contact@example.org'
    type='unavailable'/>
      ]]></artwork></figure>
      <t>Upon receiving the presence stanza of type "unsubscribe", the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "to" (if the contact is unavailable or has not requested the roster, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST also deliver the "unsubscribe" state change notification to all of the contact's available resources:</t>
      <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='to'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribe'/>
      ]]></artwork></figure>
      <t>Upon receiving the presence stanza of type "unsubscribed", the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "none" (if the contact is unavailable or has not requested the roster, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST also deliver the "unsubscribe" state change notification to all of the contact's available resources:</t>
      <figure><artwork><![CDATA[
<iq type='set'>
  <query xmlns='jabber:iq:roster'>
    <item
        jid='user@example.com'
        subscription='none'
        name='SomeUser'>
      <group>SomeGroup</group>
    </item>
  </query>
</iq>

<presence
    from='user@example.com'
    to='contact@example.org'
    type='unsubscribed'/>
      ]]></artwork></figure>
      <t>Upon receiving the presence stanza of type "unavailable" addressed to the contact, the contact's server MUST deliver the unavailable presence to all of the user's available resources:</t>
      <figure><artwork><![CDATA[
<presence
    from='user@example.com/resource'
    to='contact@example.org'
    type='unavailable'/>
      ]]></artwork></figure>
      <t>Note: When the user removes the contact from the user's roster, the end state of the contact's roster is that the user is still in the contact's roster with a subscription state of "none"; in order to completely remove the roster item for the user, the contact needs to also send a roster removal request.</t>
    </section>
  </section>

  <section title="Subscription States" anchor="substates">
    <t>This section provides detailed information about subscription states and server handling of subscription-related presence stanzas (i.e., presence stanzas of type "subscribe", "subscribed", "unsubscribe", and "unsubscribed").</t>
    <section title="Defined States" anchor="substates-defined">
      <t>There are nine possible subscription states, which are described here from the user's (not contact's) perspective:</t>
      <t><list style='numbers'>
        <t>"None" = contact and user are not subscribed to each other, and neither has requested a subscription from the other; this is reflected in the roster by subscription='none'</t>
        <t>"None + Pending Out" = contact and user are not subscribed to each other, and user has sent contact a subscription request but contact has not replied yet; this is reflected in the roster by subscription='none' and ask='subscribe'</t>
        <t>"None + Pending In" = contact and user are not subscribed to each other, and contact has sent user a subscription request but user has not replied yet (note: contact's server SHOULD NOT push or deliver roster items in this state, but instead SHOULD wait until user has approved subscription request from contact); this is reflected in the roster by subscription='none'</t>
        <t>"None + Pending Out+In" = contact and user are not subscribed to each other, contact has sent user a subscription request but user has not replied yet, and user has sent contact a subscription request but contact has not replied yet; this is reflected in the roster by subscription='none' and ask='subscribe'</t>
        <t>"To" = user is subscribed to contact (one-way); this is reflected in the roster by subscription='to'</t>
        <t>"To + Pending In" = user is subscribed to contact, and contact has sent user a subscription request but user has not replied yet; this is reflected in the roster by subscription='to'</t>
        <t>"From" = contact is subscribed to user (one-way); this is reflected in the roster by subscription='from'</t>
        <t>"From + Pending Out" = contact is subscribed to user, and user has sent contact a subscription request but contact has not replied yet; this is reflected in the roster by subscription='none' and ask='subscribe'</t>
        <t>"Both" = user and contact are subscribed to each other (two-way); this is reflected in the roster by subscription='both'</t>
      </list></t>
    </section>
    <section title="Server Handling of Outbound Presence Subscription Stanzas" anchor="substates-out">
      <t>Outbound presence subscription stanzas enable the user to manage his or her subscription to the contact's presence information (via the "subscribe" and "unsubscribe" types), and to manage the contact's access to the user's presence information (via the "subscribed" and "unsubscribed" types).</t>
      <t>The following rules apply:</t>
      <t><list style='numbers'>
        <t>Regarding outbound presence stanzas of type "subscribe", the user's server MUST without exception route the stanza to the contact.</t>
        <t>Regarding outbound presence stanzas of type "unsubscribe", the user's server MUST without exception route the stanza to the contact.</t>
        <t>Regarding outbound presence stanzas of type "subscribed", if the stanza does not result in a subscription state change from the user's perspective then the user's server SHOULD NOT route the stanza to the contact; however, if the stanza results in a subscription state change, the user's server MUST route the stanza to the contact.</t>
        <t>Regarding outbound presence stanzas of type "unsubscribed", if the stanza does not result in a subscription state change from the user's perspective then the user's server SHOULD NOT route the stanza to the contact; however, if the stanza results in a subscription state change, the user's server MUST route the stanza to the contact.</t>
      </list></t>
      <t>The tables shown that follow summarize the state transitions associated with the handling of outbound presence subscription stanzas.</t>
      <figure>
        <preamble>Table 1: Recommended handling of outbound "subscribe" stanzas</preamble>
        <artwork><![CDATA[
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  yes     |  "None + Pending Out"    |
|  "None + Pending Out"    |  yes     |  no state change         |
|  "None + Pending In"     |  yes     |  "None + Pending Out+In" |
|  "None + Pending Out+In" |  yes     |  no state change         |
|  "To"                    |  yes     |  no state change         |
|  "To + Pending In"       |  yes     |  no state change         |
|  "From"                  |  yes     |  "From + Pending Out"    |
|  "From + Pending Out"    |  yes     |  no state change         |
|  "Both"                  |  yes     |  no state change         |
+----------------------------------------------------------------+
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Table 2: Recommended handling of outbound "unsubscribe" stanzas</preamble>
        <artwork><![CDATA[
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  yes     |  no state change         |
|  "None + Pending Out"    |  yes     |  "None"                  |
|  "None + Pending In"     |  yes     |  no state change         |
|  "None + Pending Out+In" |  yes     |  "None + Pending In"     |
|  "To"                    |  yes     |  "None"                  |
|  "To + Pending In"       |  yes     |  "Pending In"            |
|  "From"                  |  yes     |  no state change         |
|  "From + Pending Out"    |  yes     |  "From"                  |
|  "Both"                  |  yes     |  "From"                  |
+----------------------------------------------------------------+
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Table 3: Recommended handling of outbound "subscribed" stanzas</preamble>
        <artwork><![CDATA[
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  no      |  no state change         |
|  "None + Pending Out"    |  no      |  no state change         |
|  "None + Pending In"     |  yes     |  "From"                  |
|  "None + Pending Out+In" |  yes     |  "From + Pending Out"    |
|  "To"                    |  no      |  no state change         |
|  "To + Pending In"       |  yes     |  "Both"                  |
|  "From"                  |  no      |  no state change         |
|  "From + Pending Out"    |  no      |  no state change         |
|  "Both"                  |  no      |  no state change         |
+----------------------------------------------------------------+
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Table 4: Recommended handling of outbound "unsubscribed" stanzas</preamble>
        <artwork><![CDATA[
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  no      |  no state change         |
|  "None + Pending Out"    |  no      |  no state change         |
|  "None + Pending In"     |  yes     |  "None"                  |
|  "None + Pending Out+In" |  yes     |  "None + Pending Out"    |
|  "To"                    |  no      |  no state change         |
|  "To + Pending In"       |  yes     |  "To"                    |
|  "From"                  |  yes     |  "None"                  |
|  "From + Pending Out"    |  yes     |  "None + Pending Out"    |
|  "Both"                  |  yes     |  "To"                    |
+----------------------------------------------------------------+
        ]]></artwork>
      </figure>
    </section>
    <section title="Server Handling of Inbound Presence Subscription Stanzas" anchor="substates-in">
      <t>Inbound presence subscription stanzas request a subscription-related action from the user (via the "subscribe" type), inform the user of subscription-related actions taken by the contact (via the "unsubscribe" type), or enable the contact to manage the user's access to the contact's presence information (via the "subscribed" and "unsubscribed" types).</t>
      <t>The following rules apply:</t>
      <t><list style='numbers'>
        <t>Regarding inbound presence stanzas of type "subscribe", if the user has not already granted the contact access to the user's presence information and if there is no pending inbound subscription request then the user's server MUST route the stanza to the user; however, if there is a pending inbound subscription request then the user's server SHOULD NOT deliver the new request.  If the user has already granted the contact access to the user's presence information, the user's server SHOULD auto-reply by sending a presence stanza of type "subscribed" to the contact on behalf of the user; this rule enables the contact to resynchronize the subscription state if needed.</t>
        <t>Regarding inbound presence stanzas of type "unsubscribe", if the stanza does not result in a subscription state change from the user's perspective then the user's server SHOULD NOT route the stanza to the contact; however, if the stanza results in a subscription state change, the user's server MUST route the stanza to the contact.</t>
        <t>Regarding inbound presence stanzas of type "subscribed", if the stanza does not result in a subscription state change from the user's perspective then the user's server SHOULD NOT route the stanza to the contact; however, if the stanza results in a subscription state change, the user's server MUST route the stanza to the contact.</t>
        <t>Regarding inbound presence stanzas of type "unsubscribed", if the stanza does not result in a subscription state change from the user's perspective then the user's server SHOULD NOT route the stanza to the contact; however, if the stanza results in a subscription state change, the user's server MUST route the stanza to the contact.</t>
      </list></t>
      <t>The tables shown that follow summarize the state transitions associated with the handling of inbound presence subscription stanzas.</t>
      <figure>
        <preamble>Table 5: Recommended handling of inbound "subscribe" stanzas</preamble>
        <artwork><![CDATA[
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  yes       |  "None + Pending In"     |
|  "None + Pending Out"    |  yes       |  "None + Pending Out+In" |
|  "None + Pending In"     |  no        |  no state change         |
|  "None + Pending Out+In" |  no        |  no state change         |
|  "To"                    |  yes       |  "To + Pending In"       |
|  "To + Pending In"       |  no        |  no state change         |
|  "From"                  |  no *      |  no state change         |
|  "From + Pending Out"    |  no *      |  no state change         |
|  "Both"                  |  no *      |  no state change         |
+------------------------------------------------------------------+
        ]]></artwork>
        <postamble>* Server SHOULD auto-reply with "subscribed" stanza</postamble>
      </figure>
      <t>When the user's server receives a presence stanza of type "unsubscribe" for the user from the contact, if the stanza results in a subscription state change from the user's perspective then the user's server SHOULD auto-reply by sending a presence stanza of type "unsubscribed" to the contact on behalf of the user, MUST deliver the "unsubscribe" stanza to the user, and MUST change the state.  If no subscription state change results, the user's server SHOULD NOT deliver the stanza and MUST NOT change the state.  These rules are summarized in the following table.</t>
      <figure>
        <preamble>Table 6: Recommended handling of inbound "unsubscribe" stanzas</preamble>
        <artwork><![CDATA[
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  no        |  no state change         |
|  "None + Pending Out"    |  no        |  no state change         |
|  "None + Pending In"     |  yes *     |  "None"                  |
|  "None + Pending Out+In" |  yes *     |  "None + Pending Out"    |
|  "To"                    |  no        |  no state change         |
|  "To + Pending In"       |  yes *     |  "To"                    |
|  "From"                  |  yes *     |  "None"                  |
|  "From + Pending Out"    |  yes *     |  "None + Pending Out     |
|  "Both"                  |  yes *     |  "To"                    |
+------------------------------------------------------------------+
        ]]></artwork>
        <postamble>* Server SHOULD auto-reply with "unsubscribed" stanza</postamble>
      </figure>
      <t>When the user's server receives a presence stanza of type "subscribed" for the user from the contact, it MUST NOT deliver the stanza to the user and MUST NOT change the subscription state if there is no pending outbound request for access to the contact's presence information.  If there is a pending outbound request for access to the contact's presence information and the inbound presence stanza of type "subscribed" results in a subscription state change, the user's server MUST deliver the stanza to the user and MUST change the subscription state.  If the user already has access to the contact's presence information, the inbound presence stanza of type "subscribed" does not result in a subscription state change; therefore the user's server SHOULD NOT deliver the stanza to the user and MUST NOT change the subscription state.  These rules are summarized in the following table.</t>
      <figure>
        <preamble>Table 7: Recommended handling of inbound "subscribed" stanzas</preamble>
        <artwork><![CDATA[
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  no        |  no state change         |
|  "None + Pending Out"    |  yes       |  "To"                    |
|  "None + Pending In"     |  no        |  no state change         |
|  "None + Pending Out+In" |  yes       |  "To + Pending In"       |
|  "To"                    |  no        |  no state change         |
|  "To + Pending In"       |  no        |  no state change         |
|  "From"                  |  no        |  no state change         |
|  "From + Pending Out"    |  yes       |  "Both"                  |
|  "Both"                  |  no        |  no state change         |
+------------------------------------------------------------------+
        ]]></artwork>
      </figure>
      <t>When the user's server receives a presence stanza of type "unsubscribed" for the user from the contact, it MUST deliver the stanza to the user and MUST change the subscription state if there is a pending outbound request for access to the contact's presence information or if the user currently has access to the contact's presence information.  Otherwise, the user's server SHOULD NOT deliver the stanza and MUST NOT change the subscription state.  These rules are summarized in the following table.</t>
      <figure>
        <preamble>Table 8: Recommended handling of inbound "unsubscribed" stanzas</preamble>
        <artwork><![CDATA[
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  no        |  no state change         |
|  "None + Pending Out"    |  yes       |  "None"                  |
|  "None + Pending In"     |  no        |  no state change         |
|  "None + Pending Out+In" |  yes       |  "None + Pending In"     |
|  "To"                    |  yes       |  "None"                  |
|  "To + Pending In"       |  yes       |  "None + Pending In"     |
|  "From"                  |  no        |  no state change         |
|  "From + Pending Out"    |  yes       |  "From"                  |
|  "Both"                  |  yes       |  "From"                  |
+------------------------------------------------------------------+
        ]]></artwork>
      </figure>
    </section>
  </section>

  <section title="Blocking Communication" anchor="blocking">
    <t>Sections 2.3.5 and 5.4.10 of <xref target='IMP-REQS'/> requires that a compliant instant messaging and presence technology must enable a user to block communications from selected users.  A protocol for doing so is specified in <xref target='XEP-0016'/> and a simplified "front-end" to that protocol is specified in <xref target='XEP-0191'/>.</t>
  </section>

    <section title="vCards" anchor="vcard">
      <t>Sections 3.1.3 and 4.1.4 of <xref target="IMP-REQS"/> require that it be possible to retrieve out-of-band contact information for other users (e.g., telephone number or email address).  An XML representation of the vCard specification defined in <xref target="VCARD">RFC 2426</xref> is in common use within the Jabber community to provide such information but is out of scope for XMPP (documentation of this protocol is contained in <xref target="XEP-0054"/>).</t>
    </section>

    <section title="XML Schemas" anchor="def">
      <t>The following XML schemas are descriptive, not normative.  For schemas defining stream-related features of XMPP, refer to <xref target="XMPP-CORE"/>.</t>
      <section title="jabber:client" anchor="def-client">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:client'
    xmlns='jabber:client'
    elementFormDefault='qualified'>

  <xs:import namespace='urn:ietf:params:xml:ns:xmpp-stanzas'/>

  <xs:element name='message'>
     <xs:complexType>
        <xs:sequence>
          <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element ref='subject'/>
            <xs:element ref='body'/>
            <xs:element ref='thread'/>
          </xs:choice>
          <xs:any     namespace='##other'
                      minOccurs='0'
                      maxOccurs='unbounded'/>
          <xs:element ref='error'
                      minOccurs='0'/>
        </xs:sequence>
        <xs:attribute name='from'
                      type='xs:string'
                      use='optional'/>
        <xs:attribute name='id'
                      type='xs:NMTOKEN'
                      use='optional'/>
        <xs:attribute name='to'
                      type='xs:string'
                      use='optional'/>
        <xs:attribute name='type' use='optional' default='normal'>
          <xs:simpleType>
            <xs:restriction base='xs:NCName'>
              <xs:enumeration value='chat'/>
              <xs:enumeration value='error'/>
              <xs:enumeration value='groupchat'/>
              <xs:enumeration value='headline'/>
              <xs:enumeration value='normal'/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute ref='xml:lang' use='optional'/>
     </xs:complexType>
  </xs:element>

  <xs:element name='body'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='subject'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='thread' type='xs:NMTOKEN'/>

  <xs:element name='presence'>
    <xs:complexType>
      <xs:sequence>
        <xs:choice minOccurs='0' maxOccurs='unbounded'>
          <xs:element ref='show'/>
          <xs:element ref='status'/>
          <xs:element ref='priority'/>
        </xs:choice>
        <xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
        <xs:element ref='error'
                    minOccurs='0'/>
      </xs:sequence>
      <xs:attribute name='from'
                    type='xs:string'
                    use='optional'/>
      <xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='optional'/>
      <xs:attribute name='to'
                    type='xs:string'
                    use='optional'/>
      <xs:attribute name='type' use='optional'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='error'/>
            <xs:enumeration value='probe'/>
            <xs:enumeration value='subscribe'/>
            <xs:enumeration value='subscribed'/>
            <xs:enumeration value='unavailable'/>
            <xs:enumeration value='unsubscribe'/>
            <xs:enumeration value='unsubscribed'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute ref='xml:lang' use='optional'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='show'>
    <xs:simpleType>
      <xs:restriction base='xs:NCName'>
        <xs:enumeration value='away'/>
        <xs:enumeration value='chat'/>
        <xs:enumeration value='dnd'/>
        <xs:enumeration value='xa'/>
      </xs:restriction>
    </xs:simpleType>
  </xs:element>

  <xs:element name='status'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='string1024'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='string1024'>
    <xs:restriction base='xs:string'>
      <xs:minLength value='1'/>
      <xs:maxLength value='1024'/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name='priority' type='xs:byte'/>

  <xs:element name='iq'>
    <xs:complexType>
      <xs:sequence>
        <xs:any     namespace='##other'
                    minOccurs='0'/>
        <xs:element ref='error'
                    minOccurs='0'/>
      </xs:sequence>
      <xs:attribute name='from'
                    type='xs:string'
                    use='optional'/>
      <xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='required'/>
      <xs:attribute name='to'
                    type='xs:string'
                    use='optional'/>
      <xs:attribute name='type' use='required'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='error'/>
            <xs:enumeration value='get'/>
            <xs:enumeration value='result'/>
            <xs:enumeration value='set'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute ref='xml:lang' use='optional'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='error'>
    <xs:complexType>
      <xs:sequence  xmlns:err='urn:ietf:params:xml:ns:xmpp-stanzas'>
        <xs:group   ref='err:stanzaErrorGroup'/>
        <xs:element ref='err:text'
                    minOccurs='0'/>
      </xs:sequence>
      <xs:attribute name='code' type='xs:unsignedShort' use='optional'/>
      <xs:attribute name='type' use='required'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='auth'/>
            <xs:enumeration value='cancel'/>
            <xs:enumeration value='continue'/>
            <xs:enumeration value='modify'/>
            <xs:enumeration value='wait'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="jabber:server" anchor="def-server">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:server'
    xmlns='jabber:server'
    elementFormDefault='qualified'>

  <xs:import namespace='urn:ietf:params:xml:ns:xmpp-stanzas'/>

  <xs:element name='message'>
     <xs:complexType>
        <xs:sequence>
          <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element ref='subject'/>
            <xs:element ref='body'/>
            <xs:element ref='thread'/>
          </xs:choice>
          <xs:any     namespace='##other'
                      minOccurs='0'
                      maxOccurs='unbounded'/>
          <xs:element ref='error'
                      minOccurs='0'/>
        </xs:sequence>
        <xs:attribute name='from'
                      type='xs:string'
                      use='required'/>
        <xs:attribute name='id'
                      type='xs:NMTOKEN'
                      use='optional'/>
        <xs:attribute name='to'
                      type='xs:string'
                      use='required'/>
        <xs:attribute name='type' use='optional' default='normal'>
          <xs:simpleType>
            <xs:restriction base='xs:NCName'>
              <xs:enumeration value='chat'/>
              <xs:enumeration value='error'/>
              <xs:enumeration value='groupchat'/>
              <xs:enumeration value='headline'/>
              <xs:enumeration value='normal'/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute ref='xml:lang' use='optional'/>
     </xs:complexType>
  </xs:element>

  <xs:element name='body'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='subject'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='thread' type='xs:NMTOKEN'/>

  <xs:element name='presence'>
    <xs:complexType>
      <xs:sequence>
        <xs:choice minOccurs='0' maxOccurs='unbounded'>
          <xs:element ref='show'/>
          <xs:element ref='status'/>
          <xs:element ref='priority'/>
        </xs:choice>
        <xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
        <xs:element ref='error'
                    minOccurs='0'/>
      </xs:sequence>
      <xs:attribute name='from'
                    type='xs:string'
                    use='required'/>
      <xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='optional'/>
      <xs:attribute name='to'
                    type='xs:string'
                    use='required'/>
      <xs:attribute name='type' use='optional'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='error'/>
            <xs:enumeration value='probe'/>
            <xs:enumeration value='subscribe'/>
            <xs:enumeration value='subscribed'/>
            <xs:enumeration value='unavailable'/>
            <xs:enumeration value='unsubscribe'/>
            <xs:enumeration value='unsubscribed'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute ref='xml:lang' use='optional'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='show'>
    <xs:simpleType>
      <xs:restriction base='xs:NCName'>
        <xs:enumeration value='away'/>
        <xs:enumeration value='chat'/>
        <xs:enumeration value='dnd'/>
        <xs:enumeration value='xa'/>
      </xs:restriction>
    </xs:simpleType>
  </xs:element>

  <xs:element name='status'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='string1024'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='string1024'>
    <xs:restriction base='xs:string'>
      <xs:minLength value='1'/>
      <xs:maxLength value='1024'/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name='priority' type='xs:byte'/>

  <xs:element name='iq'>
    <xs:complexType>
      <xs:sequence>
        <xs:any     namespace='##other'
                    minOccurs='0'/>
        <xs:element ref='error'
                    minOccurs='0'/>
      </xs:sequence>
      <xs:attribute name='from'
                    type='xs:string'
                    use='required'/>
      <xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='required'/>
      <xs:attribute name='to'
                    type='xs:string'
                    use='required'/>
      <xs:attribute name='type' use='required'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='error'/>
            <xs:enumeration value='get'/>
            <xs:enumeration value='result'/>
            <xs:enumeration value='set'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute ref='xml:lang' use='optional'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='error'>
    <xs:complexType>
      <xs:sequence  xmlns:err='urn:ietf:params:xml:ns:xmpp-stanzas'>
        <xs:group   ref='err:stanzaErrorGroup'/>
        <xs:element ref='err:text'
                    minOccurs='0'/>
      </xs:sequence>
      <xs:attribute name='code' type='xs:unsignedShort' use='optional'/>
      <xs:attribute name='type' use='required'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='auth'/>
            <xs:enumeration value='cancel'/>
            <xs:enumeration value='continue'/>
            <xs:enumeration value='modify'/>
            <xs:enumeration value='wait'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>

      <section title="jabber:iq:roster" anchor="def-roster">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:iq:roster'
    xmlns='jabber:iq:roster'
    elementFormDefault='qualified'>

  <xs:element name='query'>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref='item'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='item'>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref='group'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='ask' use='optional'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='subscribe'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name='jid' type='xs:string' use='required'/>
      <xs:attribute name='name' type='xs:string' use='optional'/>
      <xs:attribute name='subscription' use='optional'>
        <xs:simpleType>
          <xs:restriction base='xs:NCName'>
            <xs:enumeration value='both'/>
            <xs:enumeration value='from'/>
            <xs:enumeration value='none'/>
            <xs:enumeration value='remove'/>
            <xs:enumeration value='to'/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name='group' type='xs:string'/>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Differences From RFC 3921" anchor="diffs">
      <t>This section is informative.</t>
      <t>Based on consensus derived from interoperability testing and implementation experience, the following modifications were made from RFC 3921.  In addition, several smaller changes were made to more clearly specify and explain the protocols.</t>
      <t>
        <list style='symbols'>
          <t>The protocol for session establishment was determined to be unnecessary and therefore the content previously defined in Section 3 of RFC 3921 was removed.  However, server implementations may still want to advertise support for the feature in order to ensure backward-compatibility, even though it is a "no-op".</t>
          <t>The protocol for communications blocking specified in Section 10 of RFC 3921 has been moved to <xref target='XEP-0016'/> and a simplified "front-end" to that functionality has been defined in <xref target='XEP-0191'/> to ease the task of implementing communications blocking in servers and clients.</t>
          <t>In order to more seamlessly repair lack of synchronization in subscription states between servers, error handling related to presence probes and presence notifications was modified to return presence stanzas of type "unbsubscribe" or "unsubscribed" rather than error stanzas.</t>
        </list>
      </t>
    </section>

  </back>

</rfc>
