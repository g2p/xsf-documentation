<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<rfc ipr="full3978" docName="draft-saintandre-rfc3920bis-01">

  <front>
    <title abbrev="XMPP Core">Extensible Messaging and Presence Protocol (XMPP): Core</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre" role="editor">
      <organization abbrev="XSF">XMPP Standards Foundation</organization>
      <address>
        <email>stpeter@jabber.org</email>
        <uri>xmpp:stpeter@jabber.org</uri>
      </address>
    </author>
    <date year="2006" month="January" day="26"/>
    <area>Applications</area>
    <workgroup>XMPP Working Group</workgroup>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>XMPP</keyword>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>Jabber</keyword>
    <keyword>XML</keyword>
    <keyword>Extensible Markup Language</keyword>
    <abstract>
      <t>This memo defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a technology for streaming Extensible Markup Language (XML) elements in order to exchange structured information in close to real time between any two network-aware entities.  XMPP provides a generalized, extensible framework for incrementally exchanging XML data, upon which a variety of applications can be built.  The framework includes methods for stream setup and teardown, channel encryption, authentication of a client to a server and of one server to another server, and primitives for push-style messages, publication of presence and availability information, and request-response interactions between any two XMPP entities.  This document also specifies the format for XMPP addresses, which are fully internationalizable.</t>
      <t>This document obsoletes RFC 3920.</t>
    </abstract>
  </front>

  <middle>

  <section title="Introduction" anchor="intro">
    <section title="Overview" anchor="intro-overview">
      <t>The Extensible Messaging and Presence Protocol (XMPP) is an Extensible Markup Language <xref target="XML">XML</xref> technology for near-real-time messaging, presence, and request-response services.  The basic syntax and semantics were developed originally within the Jabber open-source community, mainly in 1999.  In 2002, the XMPP WG was chartered with developing an adaptation of the core Jabber protocol that would be suitable as an IETF instant messaging (IM) and presence technology.  As a result of work by the XMPP WG as well as implementation experience and interoperability testing completed since the publication of RFC 3920, this document defines the core features of XMPP 1.0; the extensions required to provide the instant messaging and presence functionality defined in <xref target="IMP-REQS"/> are specified in <xref target="XMPP-IM"/>.</t>
      <t>This document obsoletes RFC 3920.</t>
    </section>
    <section title="Functional Summary" anchor="intro-summary">
      <t>The purpose of XMPP is to enable the exchange of relatively small pieces of structured data (called "XML stanzas") over a network between any two (or more) entities.  XMPP is implemented using a client-server architecture, wherein a client must connect to a server in order to gain access to the network and thus be allowed to exchange XML stanzas with other entities.  The process whereby a client connects to a server, exchanges XML stanzas, and ends the connection is as follows:</t>
      <t>
        <list style='numbers'>
          <t>Determine the hostname and port at which to connect</t>
          <t>Open a TCP connection</t>
          <t>Open an XML stream</t>
          <t>Complete TLS negotiation for channel encryption (RECOMMENDED)</t>
          <t>Complete SASL negotiation for authentication</t>
          <t>Bind a resource to the stream</t>
          <t>Exchange XML stanzas with other entities on the network</t>
          <t>Close the stream when further communications are not needed or desired</t>
          <t>Close the TCP connection.</t>
        </list>
      </t>
      <t>In the sections following discussion of XMPP architecture and XMPP addresses, this document specifies how clients connect to servers and specifies the basic semantics of XML stanzas, but does not define the "payloads" of the XML stanzas that might be exchanged once a connection is successfully established; instead, definition of such semantics is provided by various XMPP extensions (e.g., <xref target='XMPP-IM'/> for basic instant messaging and presence applications).</t>
      <t>Within the client-server architecture used by XMPP, one server may optionally connect to another server to enable inter-domain or inter-server communication.  For this to happen, the two servers must negotiate a connection between themselves and then exchange XML stanzas; the process for doing so is as follows:</t>
      <t>
        <list style='numbers'>
          <t>Determine the hostname and port at which to connect</t>
          <t>Open a TCP connection</t>
          <t>Open an XML stream</t>
          <t>Complete TLS negotiation for channel encryption (RECOMMENDED)</t>
          <t>Complete SASL negotiation for authentication</t>
          <t>Exchange XML stanzas both directly for the servers and indirectly on behalf of entities associated with each server (e.g., connected clients)</t>
          <t>Close the stream when further communications are not needed or desired</t>
          <t>Close the TCP connection.</t>
        </list>
      </t>
      <t>Note: Depending on local policies, a service may wish to use server dialback to provide weak verification in cases where SASL negotiation would not result in strong authentication (e.g., because the certificate presented by the peer service during TLS negotiation is self-signed and thus provides only weak identity); for details, see <xref target='dialback'/>.</t>
    </section>
    <section title="Conventions" anchor="intro-conventions">
      <t>The following keywords are to be interpreted as described in <xref target="TERMS"/>: "MUST", "SHALL", "REQUIRED"; "MUST NOT", "SHALL NOT"; "SHOULD", "RECOMMENDED"; "SHOULD NOT", "NOT RECOMMENDED"; "MAY", "OPTIONAL".</t>
      <t>In examples, lines have been wrapped for improved readability.</t>
    </section>

  </section>

  <section title="Architecture" anchor="arch">

    <section title="Overview" anchor="arch-overview">
      <t>XMPP assumes a client-server architecture, wherein a client utilizing XMPP accesses a server (normally over a <xref target="TCP"/> connection) and servers can also communicate with each other over TCP connections.  Architectures that use the syntax of <xref target="stanzas">XML stanzas</xref> but that establish peer-to-peer connections directly between clients using technologies based on <xref target='LINKLOCAL'/> have been deployed, but such architectures are not XMPP and are best described as "XMPP-like"; for details, see <xref target='XEP-0174'/>.</t>
        <t>An architectural diagram for a typical deployment is shown here, where the entities have the following significance:</t>
        <t>
          <list style='symbols'>
            <t>romeo@example.net -- an XMPP user.</t>
            <t>example.net -- an XMPP server.</t>
            <t>juliet@example.com -- an XMPP user.</t>
            <t>example.com -- an XMPP server.</t>
          </list>
        </t>
      <figure>
        <artwork><![CDATA[
  example.net----------------------example.com
     |                                |
     |                                |
romeo@example.net               juliet@example.com

        ]]></artwork>
      </figure>
    </section>

    <section title="Server" anchor="arch-server">
      <t>A server acts as an intelligent abstraction layer for XMPP communications.  Its primary responsibilities are:</t>
      <t><list style="symbols">
        <t>to manage connections from other entities, in the form of <xref target="streams">XML streams</xref> to and from authorized clients, servers, and other entities</t>
        <t>to route appropriately-addressed <xref target="stanzas">XML stanzas</xref> among such entities over XML streams</t>
      </list></t>
      <t>Most XMPP-compliant servers also assume responsibility for the storage of data that is used by clients (e.g., contact lists for users of XMPP-based instant messaging and presence applications); in this case, the XML data is processed directly by the server itself on behalf of the client and is not routed to another entity.</t>
    </section>

    <section title="Client" anchor="arch-client">
      <t>Most clients connect directly to a server over a <xref target="TCP"/> connection and use XMPP to take full advantage of the functionality provided by a server and any associated services.  Multiple resources (e.g., devices or locations) MAY connect simultaneously to a server on behalf of each authorized client, with each resource differentiated by the resource identifier of an XMPP address (e.g., &lt;node@domain/home&gt; vs. &lt;node@domain/work&gt;) as defined under <xref target="addressing">Addresses</xref> and <xref target="bind">Resource Binding</xref>.  The RECOMMENDED port for connections between a client and a server is 5222, as registered with the IANA (see <xref target="iana-ports">Port Numbers</xref>).</t>
    </section>

    <section title="Network" anchor="arch-network">
      <t>Because each server is identified by a network address and because server-to-server communications are a straightforward extension of the client-to-server protocol, in practice, the system consists of a network of servers that inter-communicate.  Thus, for example, &lt;juliet@example.com&gt; is able to exchange messages, presence, and other information with &lt;romeo@example.net&gt;.  This pattern is familiar from messaging protocols (such as <xref target="SMTP"/>) that make use of network addressing standards.  Communications between any two servers are OPTIONAL.  If enabled, such communications SHOULD occur over XML streams that are bound to <xref target="TCP"/> connections.  The RECOMMENDED port for connections between servers is 5269, as registered with the IANA (see <xref target="iana-ports">Port Numbers</xref>).</t>
    </section>
  </section>

  <section title="Addresses" anchor="addressing">

    <section title="Overview" anchor="addressing-overview">
      <t>An entity is anything that can be considered a network endpoint (i.e., an ID on the network) and that can communicate using XMPP.  All such entities are uniquely addressable on the network. For historical reasons, the address of an XMPP entity is called a Jabber Identifier or JID.  A valid JID contains a set of ordered elements formed of a domain identifier, node identifier, and resource identifier.</t>
      <t>The syntax for a JID is defined as follows using the Augmented Backus-Naur Form as defined in <xref target="ABNF"/>.</t>
      <figure>
        <artwork><![CDATA[
   jid             = [ node "@" ] domain [ "/" resource ]
   node            = 1*(nodepoint)
                     ; a "nodepoint" is a UTF-8 encoded Unicode code
                     ; point that satisfies the Nodeprep profile of
                     ; stringprep
   domain          = fqdn / address-literal / idnlabel
   fqdn            = (idnlabel 1*("." idnlabel))
                     ; an "idnlabel" is an internationalized domain
                     ; label as described in RFC 3490
   address-literal = IPv4address / IPv6address
                     ; the "IPv4address" and "IPv6address" rules are
                     ; defined in Appendix B of RFC 3513
   resource        = 1*(resourcepoint)
                     ; a "resourcepoint" is a UTF-8 encoded Unicode
                     ; code point that satisfies the Resourceprep
                     ; profile of stringprep
        ]]></artwork>
      </figure>
      <t>All JIDs are based on the foregoing structure.  One common use of this structure is to identify a messaging and presence account, the server that hosts the account, and a connected resource (e.g., a specific device) in the form of &lt;node@domain/resource&gt;.  However, node types other than clients are possible; for example, a specific chat room offered by a multi-user chat service (see <xref target='XEP-0045'/>) could be addressed as &lt;room@service&gt; (where "room" is the name of the chat room and "service" is the hostname of the multi-user chat service) and a specific occupant of such a room could be addressed as &lt;room@service/nick&gt; (where "nick" is the occupant's room nickname).  Many other JID types are possible (e.g., &lt;domain/resource&gt; could be a server-side script or service).</t>
      <t>Each allowable portion of a JID (node identifier, domain identifier, and resource identifier) MUST NOT be more than 1023 bytes in length, resulting in a maximum total size (including the '@' and '/' separators) of 3071 bytes.</t>
      <t>Note: While the format of a JID is consistent with <xref target="URI"/>, an entity's address on an XMPP network MUST be a JID (without a URI scheme) and not a <xref target="URI"/> or <xref target="IRI"/> as specified in <xref target="XMPP-URI"/>; the latter specification is provided only for use by non-XMPP applications.</t>
    </section>

    <section title="Domain Identifier" anchor="addressing-domain">
      <t>The DOMAIN IDENTIFIER is the primary identifier and is the only REQUIRED element of a JID (a mere domain identifier is a valid JID).  It usually represents the network or "home" server to which other entities connect for XML routing and data management capabilities.  However, the entity referenced by a domain identifier is not always a server, and may be a service that is addressed as a subdomain of a server that provides functionality above and beyond the capabilities of a server (e.g., a multi-user chat service or a user directory).</t>
      <t>The domain identifier for every server or service that will communicate over a network MAY be an IP address but SHOULD be a fully qualified domain name (see <xref target="DNS"/>).  A domain identifier MUST be an "internationalized domain name" as defined in <xref target="IDNA"/>, to which the <xref target="NAMEPREP"/> profile of <xref target="STRINGPREP"/> can be applied without failing.  Before comparing two domain identifiers, a server MUST (and a client SHOULD) first apply the Nameprep profile to the labels (as defined in <xref target="IDNA"/>) that make up each identifier.  Note: When applying the Nameprep profile, the UseSTD3ASCIIRules flag MUST be set to true.</t>
    </section>

    <section title="Node Identifier" anchor="addressing-node">
      <t>The NODE IDENTIFIER is an optional secondary identifier placed before the domain identifier and separated from the latter by the '@' character.  It usually represents the entity requesting and using network access provided by a server (i.e., a client), although it can also represent other kinds of entities (e.g., a chat room associated with a multi-user chat service).  The entity represented by a node identifier is addressed within the context of a specific domain; within instant messaging and presence applications of XMPP, this address is called a "bare JID" and is of the form &lt;node@domain&gt;.</t>
      <t>A node identifier MUST be formatted such that the Nodeprep profile of <xref target="STRINGPREP"/> can be applied without failing (see <xref target="nodeprep"/>).  Before comparing two node identifiers, a server MUST (and a client SHOULD) first apply the Nodeprep profile to each identifier.</t>
    </section>

    <section title="Resource Identifier" anchor="addressing-resource">
      <t>The RESOURCE IDENTIFIER is an optional tertiary identifier placed after the domain identifier and separated from the latter by the '/' character.  A resource identifier may modify either a &lt;node@domain&gt; address or a mere &lt;domain&gt; address.  It usually represents a specific connection (e.g., a device or location) or object (e.g., a participant in a multi-user chat room) belonging to the entity associated with a node identifier.  A resource identifier is opaque to both servers and other clients, and is typically defined by a client implementation when it provides the information necessary to complete <xref target="bind">Resource Binding</xref> (although it may be generated by a server on behalf of a client), after which the entity is referred to as a "connected resource" and its address is referrred to as a "full JID" (&lt;node@domain/resource&gt;).  An entity MAY maintain multiple connected resources simultaneously, with each connected resource differentiated by a distinct resource identifier.</t>
      <t>A resource identifier MUST be formatted such that the Resourceprep profile of <xref target="STRINGPREP"/> can be applied without failing (see <xref target="resourceprep"/>).  Before comparing two resource identifiers, a server MUST (and a client SHOULD) first apply the Resourceprep profile to each identifier.</t>
    </section>

    <section title="Determination of Addresses" anchor="addressing-determination">
      <t>After <xref target='sasl'>SASL negotiation</xref> and, if appropriate, <xref target="bind">Resource Binding</xref>, the receiving entity for a stream MUST determine the initiating entity's JID.</t>
      <t>For server-to-server communications, the initiating entity's JID SHOULD be the authorization identity, derived from the authentication identity, as defined by <xref target="SASL"/>, if no authorization identity was specified during <xref target='sasl'>SASL negotiation</xref>.</t>
      <t>For client-to-server communications, the "bare JID" (&lt;node@domain&gt;) SHOULD be the authorization identity, derived from the authentication identity, as defined in <xref target="SASL"/>, if no authorization identity was specified during <xref target='sasl'>SASL negotiation</xref>; the resource identifier portion of the "full JID" (&lt;node@domain/resource&gt;) SHOULD be the resource identifier negotiated by the client and server during <xref target="bind">Resource Binding</xref>.</t>
      <t>The receiving entity MUST ensure that the resulting JID (including node identifier, domain identifier, resource identifier, and separator characters) conforms to the rules and formats defined earlier in this section; to meet this restriction, the receiving entity may need to replace the JID sent by the initiating entity with the canonicalized JID as determined by the receiving entity.</t>
    </section>

  </section>

  <section title="TCP Binding" anchor="tcp">
    <t>Although there is no necessary coupling of an XML stream to a <xref target="TCP"/> connection (e.g., two entities could connect to each other via another transport, e.g. <xref target="HTTP"/> as specified in <xref target="XEP-0124"/>), this specification defines a binding of XMPP to TCP only.</t>
    <t>Therefore, as XMPP is defined herein, an initiating entity (client or server) MUST open a TCP connection at the receiving entity (server) before it negotiates XML streams with the receiving entity.  However, prior to opening the TCP connection the initiating entity first MUST resolve the Domain Name System (DNS) hostname associated with the receiving entity and determine the appropriate TCP port for communications with the receiving entity.  The process is as follows:</t>
    <t>
      <list style='numbers'>
        <t>Attempt to resolve the hostname using a <xref target="DNS-SRV"/> Service of "xmpp-client" (for client-to-server connections) or "xmpp-server" (for server-to-server connections) and Proto of "tcp", resulting in resource records such as "_xmpp-client._tcp.example.com." or "_xmpp-server._tcp.example.com."; the IP address and port at which the initiating entity attempts to connect to the receiving entity shall be those specified in the SRV lookup result.</t>
         <t>If the SRV lookup fails, the fallback SHOULD be a normal IPv4 or <xref target='IPv6'/> address record resolution to determine the IP address, where the port used is the "xmpp-client" port of 5222 for client-to-server connectionsn or the "xmpp-server" port 5269 for client-to-server connections.</t>
         <t>However, the fallback MAY be a DNS TXT lookup (see <xref target='DNS-TXT'/>) for alternative connection methods, for example as described in <xref target='XEP-0156'/>.</t>
      </list>
    </t>
    <t>TCP connections are handled differently in client-to-server communications and server-to-server communications.  Specifically:</t>
    <t>
      <list style='symbols'>
        <t>Because a client is subordinate to a server and therefore a client authenticates to the server but the server does not authenticate to the client, it is necessary to have only one TCP connection between client and server.  Thus the server MUST allow the client to share a single TCP connection for XML stanzas sent from client to server and from server to client (i.e., the inital stream and response stream as specified under <xref target='streams'>XML Streams</xref>).</t>
        <t>Because two servers are peers and therefore each peers must authenticate with the other, the servers MUST use two TCP connections: one for XML stanzas sent from the first server to the second server and another (initiated by the second server) for stanzas from the second server to the first server.</t>
      </list>
    </t>
  </section>

  <section title="XML Streams" anchor="streams">

    <section title="Overview" anchor="streams-overview">
      <t>Two fundamental concepts make possible the rapid, asynchronous exchange of relatively small payloads of structured information between presence-aware entities: XML streams and XML stanzas.  These terms are defined as follows:</t>
      <t><list style="hanging">
        <t hangText="Definition of XML Stream:">An XML STREAM is a container for the exchange of XML elements between any two entities over a network.  The start of an XML stream is denoted unambiguously by an opening XML &lt;stream&gt; tag (with appropriate attributes and namespace declarations), while the end of the XML stream is denoted unambiguously by a closing XML &lt;/stream&gt; tag.  During the life of the stream, the entity that initiated it can send an unbounded number of XML elements over the stream, either elements used to negotiate the stream (e.g., to complete <xref target='tls'>TLS negotiation</xref> or <xref target='sasl'>SASL negotiation</xref>) or XML stanzas.  The "initial stream" is negotiated from the initiating entity (usually a client or server) to the receiving entity (usually a server), and can be seen as corresponding to the initiating entity's "connection" with the receiving entity.  The initial stream enables unidirectional communication from the initiating entity to the receiving entity; in order to enable information exchange from the receiving entity to the initiating entity, the receiving entity MUST negotiate a stream in the opposite direction (the "response stream").</t>
        <t hangText="Definition of XML Stanza:">An XML STANZA is a discrete semantic unit of structured information that is sent from one entity to another over an XML stream, and is the basic unit of meaning in XMPP.  An XML stanza exists at the direct child level of the root &lt;stream/&gt; element and is said to be well-balanced if it matches the production [43] content of <xref target="XML"/>.  The start of any XML stanza is denoted unambiguously by the element start tag at depth=1 of the XML stream (e.g., &lt;presence&gt;), and the end of any XML stanza is denoted unambiguously by the corresponding close tag at depth=1 (e.g., &lt;/presence&gt;); a server MUST NOT process, deliver, or route a partial stanza and MUST NOT attach meaning to the transmission timing of any part of a stanza (before receipt of the close tag).  The only XML stanzas defined herein are the &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt; elements qualified by the default namespace for the stream, as described under <xref target="stanzas">XML Stanzas</xref>; an XML element sent for the purpose of <xref target='tls'>TLS negotiation</xref>, <xref target='sasl'>SASL negotiation</xref>, or <xref target="dialback">server dialback</xref> is not considered to be an XML stanza.  An XML stanza MAY contain child elements (with accompanying attributes, elements, and XML character data) as necessary in order to convey the desired information, which MAY be qualified by any XML namespace (see <xref target='XML-NAMES'/>).</t>
      </list></t>
      <t>Consider the example of a client's connection to a server.  In order to connect to a server, a client MUST initiate an XML stream by sending an opening &lt;stream&gt; tag to the server, optionally preceded by a text declaration specifying the XML version and the character encoding supported (see <xref target="xml-declaration">Inclusion of Text Declaration</xref> and <xref target="xml-encoding">Character Encoding</xref>).  Subject to local policies and service provisioning, the server SHOULD then reply with a second XML stream back to the client, again optionally preceded by a text declaration.  Once the client has completed <xref target='sasl'>SASL negotiation</xref>, the client MAY send an unbounded number of XML stanzas over the stream to any recipient on the network.  When the client desires to close the stream, it simply sends a closing &lt;/stream&gt; tag to the server; for details, see <xref target='streams-close'/>.</t>
      <t>Those who are accustomed to thinking of XML in a document-centric manner may wish to view a client's connection to a server as consisting of two open-ended XML documents: one from the client to the server and one from the server to the client.  From this perspective, the root &lt;stream/&gt; element can be considered the document entity for each "document", and the two "documents" are built up through the accumulation of XML stanzas sent over the two XML streams.  However, this perspective is a convenience only; XMPP does not deal in documents but in XML streams and XML stanzas.</t>
      <t>In essence, then, an XML stream acts as an envelope for all the XML stanzas sent during a connection.  We can represent this in a simplistic fashion as follows:</t>
      <figure>
        <artwork><![CDATA[
|--------------------|
| <stream>           |
|--------------------|
| <presence>         |
|   <show/>          |
| </presence>        |
|--------------------|
| <message to='foo'> |
|   <body/>          |
| </message>         |
|--------------------|
| <iq to='bar'>      |
|   <query/>         |
| </iq>              |
|--------------------|
| ...                |
|--------------------|
| </stream>          |
|--------------------|
        ]]></artwork>
      </figure>
    </section>

    <section title="Stream Security" anchor="streams-security">
      <t>When negotiating XML streams in XMPP 1.0, TLS SHOULD be used as defined under <xref target='tls'>TLS negotiation</xref> and SASL MUST be used as defined under <xref target='sasl'>SASL negotiation</xref>.  The initial stream and the response stream MUST be secured separately, although security in both directions MAY be established via mechanisms that provide mutual authentication.  An entity SHOULD NOT attempt to send <xref target="stanzas">XML Stanzas</xref> over the stream before the stream has been authenticated, but if it does, then the other entity MUST NOT accept such stanzas and SHOULD return a &lt;not-authorized/&gt; stream error and then terminate both the XML stream and the underlying TCP connection; note well that this applies to XML stanzas only (i.e., &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt; elements qualified by the default namespace) and not to XML elements used for stream negotiation (e.g., elements used to complete <xref target='tls'>TLS negotiation</xref> or <xref target='sasl'>SASL negotiation</xref>).</t>
    </section>

    <section title="Stream Attributes" anchor="streams-attr">
      <t>The attributes of the stream element are as follows:</t>
      <t><list style="symbols">
        <t>from -- In client-to-server communications, the 'from' attribute SHOULD be included in the XML stream header sent from the initiating entity to the receiving entity and (if included) MUST be set to the account name (i.e., "bare JID" = &lt;node@domain&gt;) of the entity controlling the client.  In server-to-server communications, the 'from' attribute SHOULD be included in the XML stream header sent from the initiating entity to the receiving entity and (if included) MUST be set to a hostname serviced by the initiating entity.  In both client-to-server and server-to-server communications, the 'from' attribute MUST be included in the XML stream header by which the receiving entity responds to the initiating entity and MUST be set to a hostname serviced by the receiving entity that is granting access to the initiating entity.  Note: Each entity MUST verify the identity of the other entity before exchanging XML stanzas with it (see the <xref target='security-client'>Client-to-Server Communications</xref> and <xref target='security-server'>Server-to-Server Communications</xref> sections of this document for details).</t>
        <t>to -- In both client-to-server and server-to-server communications, the 'to' attribute SHOULD be included in the XML stream header sent from the initiating entity to the receiving entity and (if included) MUST be set to a hostname serviced by the receiving entity.  In client-to-server communications, if the client included a 'from' address in the initial stream header then the server SHOULD include a 'to' attribute in the XML stream header by which it replies to the client and (if included) MUST set the 'to' attribute to the bare JID specified in the 'from' attribute of the XML stream header sent from the initiating entity to the receiving entity.  In server-to-server communications, if the initiating entity included a 'from' address in the initial stream header then the receiving entity SHOULD include a 'to' attribute in the XML stream header by which it replies to the initiating entity and (if included) MUST set the 'to' attribute to the hostname specified in the 'from' attribute of the XML stream header sent from the initiating entity to the receiving entity.  Note: Each entity MUST verify the identity of the other entity before exchanging XML stanzas with it (see the <xref target='security-client'>Client-to-Server Communications</xref> and <xref target='security-server'>Server-to-Server Communications</xref> sections of this document for details).</t>
        <t>id -- The 'id' attribute SHOULD be used only in the XML stream header from the receiving entity to the initiating entity.  This attribute is a unique identifier created by the receiving entity to function as a identifier for the initiating entity's streams with the receiving entity, and MUST be unique within the receiving application (normally a server).  Note well that the stream ID may be security-critical and therefore MUST be both unpredictable and nonrepeating (see <xref target="RANDOM"/> for recommendations regarding randomness for security purposes).  There SHOULD NOT be an 'id' attribute on the XML stream header sent from the initiating entity to the receiving entity; however, if an 'id' attribute is included, it SHOULD be silently ignored by the receiving entity.</t>
        <t>xml:lang -- An 'xml:lang' attribute (as defined in Section 2.12 of <xref target="XML"/>) SHOULD be included by the initiating entity on the header for the initial stream to specify the default language of any human-readable XML character data it sends over that stream.  If the attribute is included, the receiving entity SHOULD remember that value as the default for both the initial stream and the response stream; if the attribute is not included, the receiving entity SHOULD use a configurable default value for both streams, which it MUST communicate in the header for the response stream.  For all stanzas sent over the initial stream, if the initiating entity does not include an 'xml:lang' attribute, the receiving entity SHOULD apply the default value; if the initiating entity does include an 'xml:lang' attribute, the receiving entity MUST NOT modify or delete it (see also <xref target="stanzas-attributes-lang">xml:lang</xref>).  The value of the 'xml:lang' attribute MUST be an NMTOKEN (as defined in Section 2.3 of <xref target="XML"/>) and MUST conform to the format defined in <xref target="LANGTAGS"/>.</t>
        <t>version -- The presence of the version attribute set to a value of at least "1.0" signals support for the stream-related protocols (including stream features) defined in this specification.  Detailed rules regarding the generation and handling of this attribute are defined in the text that follows.</t>
      </list></t>
      <t>We can summarize as follows:</t>
      <figure>
        <artwork><![CDATA[
+----------+--------------------------+-------------------------+
|          | initiating to receiving  | receiving to initiating |
+----------+--------------------------+-------------------------+
| to       | JID of receiver          | JID of initiator        |
| from     | JID of initiator         | JID of receiver         |
| id       | silently ignored         | stream identifier       |
| xml:lang | default language         | default language        |
| version  | XMPP 1.0 supported       | XMPP 1.0 supported      |
+----------+--------------------------+-------------------------+
        ]]></artwork>
      </figure>
      <t>Note: The attributes of the root &lt;stream/&gt; element are not prepended by a 'stream:' prefix because, in accordance with Section 5.3 of <xref target="XML-NAMES">XML namespaces specification</xref>, the default namespace does not apply to attribute names.</t>
      <section title="Version Support" anchor="streams-attr-version">
        <t>The version of XMPP specified herein is "1.0"; in particular, this encapsulates the stream-related protocols (<xref target='tls'>TLS negotiation</xref>, <xref target='sasl'>SASL negotiation</xref>, and <xref target="streams-error">Stream Errors</xref>), as well as the semantics of the three defined XML stanza types (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;).  The numbering scheme for XMPP versions is "&lt;major&gt;.&lt;minor&gt;".  The major and minor numbers MUST be treated as separate integers and each number MAY be incremented higher than a single digit.  Thus, "XMPP 2.4" would be a lower version than "XMPP 2.13", which in turn would be lower than "XMPP 12.3".  Leading zeros (e.g., "XMPP 6.01") MUST be ignored by recipients and MUST NOT be sent.</t>
        <t>The major version number should be incremented only if the stream and stanza formats or required actions have changed so dramatically that an older version entity would not be able to interoperate with a newer version entity if it simply ignored the elements and attributes it did not understand and took the actions specified in the older specification.  The minor version number indicates new capabilities, and MUST be ignored by an entity with a smaller minor version number, but used for informational purposes by the entity with the larger minor version number.  For example, a minor version number might indicate the ability to process a newly defined value of the 'type' attribute for message, presence, or IQ stanzas; the entity with the larger minor version number would simply note that its correspondent would not be able to understand that value of the 'type' attribute and therefore would not send it.</t>
        <t>The following rules apply to the generation and handling of the 'version' attribute within stream headers by implementations:</t>
        <t><list style="numbers">
          <t>The initiating entity MUST set the value of the 'version' attribute on the initial stream header to the highest version number it supports (e.g., if the highest version number it supports is that defined in this specification, it MUST set the value to "1.0").</t>
          <t>The receiving entity MUST set the value of the 'version' attribute on the response stream header to either the value supplied by the initiating entity or the highest version number supported by the receiving entity, whichever is lower.  The receiving entity MUST perform a numeric comparison on the major and minor version numbers, not a string match on "&lt;major&gt;.&lt;minor&gt;".</t>
          <t>If the version number included in the response stream header is at least one major version lower than the version number included in the initial stream header and newer version entities cannot interoperate with older version entities as described above, the initiating entity SHOULD generate an &lt;unsupported-version/&gt; stream error and terminate the XML stream and underlying TCP connection.</t>
          <t>If either entity receives a stream header with no 'version' attribute, the entity MUST consider the version supported by the other entity to be "0.9" and SHOULD NOT include a 'version' attribute in the stream header it sends in reply.</t>
        </list></t>
      </section>
    </section>

    <section title="Namespace Declarations" anchor="streams-ns">
      <t>The stream element MUST possess both a streams namespace declaration and a default namespace declaration (as "namespace declaration" is defined in the <xref target="XML-NAMES"/>).  For detailed information regarding the streams namespace and default namespace, see <xref target="xml-ns">Namespace Names and Prefixes</xref>.</t>
    </section>

    <section title="Stream Features" anchor="streams-features">
      <t>If the initiating entity includes the 'version' attribute set to a value of at least "1.0" in the initial stream header, the receiving entity MUST send a &lt;features/&gt; child element (prefixed by the streams namespace prefix) to the initiating entity in order to announce any stream-level features that can be negotiated (or capabilities that otherwise need to be advertised).  Currently, this is used only to advertise <xref target='tls'>TLS negotiation</xref>, <xref target='sasl'>SASL negotiation</xref>, <xref target="bind">resource binding</xref>, and <xref target="dialback">server dialback</xref> as defined herein; however, the stream features functionality can be used to advertise other negotiable features as well.  If an entity does not understand or support some features, it SHOULD silently ignore them.  If one or more security features (e.g., TLS and SASL) need to be successfully negotiated before a non-security-related feature (e.g., Resource Binding) can be offered, the non-security-related feature SHOULD NOT be included in the stream features that are advertised before the relevant security features have been negotiated.  If a feature must be negotiated before the initiating entity may proceed, that feature SHOULD include a &lt;required/&gt; child element.</t>
    </section>

    <section title="Closing Streams" anchor="streams-close">
      <t>At any time after XML streams have been negotiated between two entities, either entity MAY close its stream to the other entity (even in the absence of a stream error) by sending a closing stream tag:</t>
      <figure>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>The entity that sends the closing stream tag SHOULD wait for the other entity to also close its stream:</t>
      <figure>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>However, the entity that sends the first closing stream tag MAY consider both streams to be void if the other entity does not send its closing stream tag within a reasonable amount of time (where the definition of "reasonable" is up to the implementation or deployment).</t>
      <t>After an entity sends a closing stream tag, it MUST NOT send further data over that stream.</t>
      <t>After the entity that sent the first closing stream tag receives a reciprocal closing stream tag from the other entity, it MUST terminate the underlying TCP connection.</t>
    </section>

    <section title="Reconnection" anchor="streams-reconnect">
      <t>It can happen that an XMPP server goes offline while servicing connections from clients and from other servers.  Because the number of such connections can be quite large, the reconnection algorithm employed by entities that seek to reconnect can have a significant impact on software and network performance.  The following guidelines are RECOMMENDED:</t>
      <t>
        <list style='symbols'>
          <t>The time to live (TTL) specified in Domain Name System records SHOULD be honored, even if DNS results are cached; if the TTL has not expired, an entity that seeks to reconnect SHOULD NOT re-resolve DNS before reconnecting.</t>
          <t>The time that expires before an entity first seeks to reconnect SHOULD be randomized (e.g., so that all clients do not attempt to reconnect 30 seconds after being disconnected).</t>
          <t>If the first reconnection attempt does not succeed, an entity SHOULD back off exponentially on the time between subsequent reconnection attempts.</t>
        </list>
      </t>
    </section>

    <section title="Stream Errors" anchor="streams-error">
      <t>The root stream element MAY contain an &lt;error/&gt; child element that is prefixed by the streams namespace prefix.  The error child MUST be sent by a compliant entity (usually a server rather than a client) if it perceives that a stream-level error has occurred.</t>
      <section title="Rules" anchor="streams-error-rules">
        <t>The following rules apply to stream-level errors:</t>
        <t><list style="symbols">
          <t>It is assumed that all stream-level errors are unrecoverable; therefore, if an error occurs at the level of the stream, the entity that detects the error MUST send a stream error to the other entity, send a closing &lt;/stream&gt; tag, and terminate the underlying TCP connection.</t>
          <t>If the error occurs while the stream is being set up, the receiving entity MUST still send the opening &lt;stream&gt; tag, include the &lt;error/&gt; element as a child of the stream element, send the closing &lt;/stream&gt; tag, and terminate the underlying TCP connection.  In this case, if the initiating entity provides an unknown host in the 'to' attribute (or provides no 'to' attribute at all), the server SHOULD provide the server's authoritative hostname in the 'from' attribute of the stream header sent before termination.</t>
        </list></t>
      </section>
      <section title="Syntax" anchor="streams-error-syntax">
        <t>The syntax for stream errors is as follows:</t>
        <figure>
          <artwork><![CDATA[
<stream:error>
  <defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
  [<text xmlns='urn:ietf:params:xml:ns:xmpp-streams'
        xml:lang='langcode'>
    OPTIONAL descriptive text
  </text>]
  [OPTIONAL application-specific condition element]
</stream:error>
          ]]></artwork>
        </figure>
        <t>The &lt;error/&gt; element:</t>
        <t><list style="symbols">
          <t>MUST contain a child element corresponding to one of the defined stanza error conditions defined in the text that follows; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-streams' namespace</t>
          <t>MAY contain a &lt;text/&gt; child containing XML character data that describes the error in more detail; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-streams' namespace and SHOULD possess an 'xml:lang' attribute specifying the natural language of the XML character data</t>
          <t>MAY contain a child element for an application-specific error condition; this element MUST be qualified by an application-defined namespace, and its structure is defined by that namespace</t>
        </list></t>
        <t>The &lt;text/&gt; element is OPTIONAL.  If included, it SHOULD be used only to provide descriptive or diagnostic information that supplements the meaning of a defined condition or application-specific condition.  It SHOULD NOT be interpreted programmatically by an application.  It SHOULD NOT be used as the error message presented to a user, but MAY be shown in addition to the error message associated with the included condition element (or elements).</t>
      </section>
      <section title="Defined Conditions" anchor="streams-error-conditions">
        <t>The following stream-level error conditions are defined:</t>
        <t><list style="symbols">
          <t>&lt;bad-format/&gt; -- the entity has sent XML that cannot be processed; this error MAY be used instead of the more specific XML-related errors, such as &lt;bad-namespace-prefix/&gt;, &lt;invalid-xml/&gt;, &lt;restricted-xml/&gt;, &lt;unsupported-encoding/&gt;, and &lt;xml-not-well-formed/&gt;, although the more specific errors are preferred.</t>
          <t>&lt;bad-namespace-prefix/&gt; -- the entity has sent a namespace prefix that is unsupported, or has sent no namespace prefix on an element that requires such a prefix (see <xref target="xml-ns">XML Namespace Names and Prefixes</xref>).</t>
          <t>&lt;conflict/&gt; -- the server is closing the active stream for this entity because a new stream has been initiated that conflicts with the existing stream.</t>
          <t>&lt;connection-timeout/&gt; -- the entity has not generated any traffic over the stream for some period of time (configurable according to a local service policy).</t>
          <t>&lt;host-gone/&gt; -- the value of the 'to' attribute provided by the initiating entity in the stream header corresponds to a hostname that is no longer hosted by the server.</t>
          <t>&lt;host-unknown/&gt; -- the value of the 'to' attribute provided by the initiating entity in the stream header does not correspond to a hostname that is hosted by the server.</t>
          <t>&lt;improper-addressing/&gt; -- a stanza sent between two servers lacks a 'to' or 'from' attribute (or the attribute has no value).</t>
          <t>&lt;internal-server-error/&gt; -- the server has experienced a misconfiguration or an otherwise-undefined internal error that prevents it from servicing the stream.</t>
          <t>&lt;invalid-from/&gt; -- the JID or hostname provided in a 'from' address does not match an authorized JID or validated domain negotiated between servers via SASL or dialback, or between a client and a server via authentication and resource binding.</t>
          <t>&lt;invalid-id/&gt; -- the stream ID or dialback ID is invalid or does not match an ID previously provided.</t>
          <t>&lt;invalid-namespace/&gt; -- the streams namespace name is something other than "http://etherx.jabber.org/streams" or the dialback namespace name is something other than "jabber:server:dialback" (see <xref target="xml-ns">XML Namespace Names and Prefixes</xref>).</t>
          <t>&lt;invalid-xml/&gt; -- the entity has sent invalid XML over the stream to a server that performs validation (see <xref target="xml-validation">Validation</xref>).</t>
          <t>&lt;not-authorized/&gt; -- the entity has attempted to send XML stanzas before the stream has been authenticated, or otherwise is not authorized to perform an action related to stream negotiation; the receiving entity MUST NOT process the offending stanza before sending the stream error.</t>
          <t>&lt;policy-violation/&gt; -- the entity has violated some local service policy (e.g., the entity is on a provisioned blacklist); the server MAY choose to specify the policy in the &lt;text/&gt; element or an application-specific condition element.</t>
          <t>&lt;remote-connection-failed/&gt; -- the server is unable to properly connect to a remote entity that is required for authentication or authorization.</t>
          <t>&lt;resource-constraint/&gt; -- the server lacks the system resources necessary to service the stream.</t>
          <t>&lt;restricted-xml/&gt; -- the entity has attempted to send restricted XML features such as a comment, processing instruction, DTD, entity reference, or unescaped character (see <xref target="xml-restrictions">Restrictions</xref>).</t>
          <t>&lt;see-other-host/&gt; -- the server will not provide service to the initiating entity but is redirecting traffic to another host; the XML character data of the &lt;see-other-host/&gt; element returned by the server SHOULD specify the alternate hostname or IP address at which to connect, which SHOULD be a valid domain identifier but may also include a port number; if no port is specified, the initiating entity SHOULD perform a <xref target="DNS-SRV"/> lookup on the provided domain identifier but MAY assume that it can connect to that domain identifier at the standard XMPP ports (5222 for client-to-server connections and 5269 for server-to-server connections).</t>
          <t>&lt;system-shutdown/&gt; -- the server is being shut down and all active streams are being closed.</t>
          <t>&lt;undefined-condition/&gt; -- the error condition is not one of those defined by the other conditions in this list; this error condition SHOULD be used only in conjunction with an application-specific condition.</t>
          <t>&lt;unsupported-encoding/&gt; -- the initiating entity has encoded the stream in an encoding that is not supported by the server (see <xref target="xml-encoding">Character Encoding</xref>).</t>
          <t>&lt;unsupported-stanza-type/&gt; -- the initiating entity has sent a first-level child of the stream that is not supported by the server.</t>
          <t>&lt;unsupported-version/&gt; -- the value of the 'version' attribute provided by the initiating entity in the stream header specifies a version of XMPP that is not supported by the server; the server MAY specify the version(s) it supports in the &lt;text/&gt; element.</t>
          <t>&lt;xml-not-well-formed/&gt; -- the initiating entity has sent XML that is not well-formed as defined by <xref target="XML"/>.</t>
        </list></t>
      </section>
      <section title="Application-Specific Conditions" anchor="streams-error-app">
        <t>As noted, an application MAY provide application-specific stream error information by including a properly-namespaced child in the error element.  The application-specific element SHOULD supplement or further qualify a defined element.  Thus the &lt;error/&gt; element will contain two or three child elements:</t>
        <figure>
          <artwork><![CDATA[
<stream:error>
  <xml-not-well-formed
      xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
  <text xml:lang='en' xmlns='urn:ietf:params:xml:ns:xmpp-streams'>
    Some special application diagnostic information!
  </text>
  <escape-your-data xmlns='application-ns'/>
</stream:error>
</stream:stream>
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Simplified Stream Examples" anchor="streams-example">
      <t>This section contains two simplified examples of a stream-based connection of a client on a server (where the "C" lines are sent from the client to the server, and the "S" lines are sent from the server to the client); these examples are included for the purpose of illustrating the concepts introduced thus far.</t>
      <figure>
        <preamble>A basic connection:</preamble>
        <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       xml:lang='en'
       from='juliet@example.com'
       to='example.com'
       version='1.0'>
S: <?xml version='1.0'?>
   <stream:stream
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       xml:lang='en'
       from='example.com'
       id='someid'
       to='juliet@example.com'
       version='1.0'>
...  encryption, authentication, and resource binding ...
C:   <message from='juliet@example.com/balcony'
              to='romeo@example.net'
              xml:lang='en'>
C:     <body>Art thou not Romeo, and a Montague?</body>
C:   </message>
S:   <message from='romeo@example.net/orchard'
              to='juliet@example.com/balcony'
              xml:lang='en'>
S:     <body>Neither, fair saint, if either thee dislike.</body>
S:   </message>
C: </stream:stream>
S: </stream:stream>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>A connection gone bad:</preamble>
        <artwork><![CDATA[
C: <?xml version='1.0'?>
   <stream:stream
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       xml:lang='en'
       from='juliet@example.com'
       to='example.com'
       version='1.0'>
S: <?xml version='1.0'?>
   <stream:stream
       xmlns='jabber:client'
       xmlns:stream='http://etherx.jabber.org/streams'
       xml:lang='en'
       from='example.com'
       id='someid'
       to='juliet@example.com'
       version='1.0'>
...  encryption, authentication, and resource binding ...
C: <message xml:lang='en'>
     <body>Bad XML, no closing body tag!
   </message>
S: <stream:error>
    <xml-not-well-formed
        xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
   </stream:error>
S: </stream:stream>
        ]]></artwork>
      </figure>
      <t>More detailed examples are provided under <xref target="examples"/>.</t>
    </section>
  </section>

  <section title="TLS Negotiation" anchor="tls">
    <section title="Overview" anchor="tls-overview">
      <t>XMPP includes a method for securing the stream from tampering and eavesdropping.  This channel encryption method makes use of the <xref target="TLS">Transport Layer Security (TLS) protocol</xref>, along with a "STARTTLS" extension that is modelled after similar extensions for the <xref target="IMAP"/>, <xref target="POP3"/>, and <xref target="ACAP"/> protocols as described in <xref target="USINGTLS"/>.  The namespace name for the STARTTLS extension is 'urn:ietf:params:xml:ns:xmpp-tls'.</t>
      <t>An administrator of a given domain MAY require the use of TLS for client-to-server communications, server-to-server communications, or both.  Clients SHOULD use TLS to secure the streams prior to attempting the completion of <xref target='sasl'>SASL negotiation</xref>, and servers SHOULD use TLS between two domains for the purpose of securing server-to-server communications.</t>
      <t>The following rules apply:</t>
      <t><list style='numbers'>
        <t>An initiating entity that complies with this specification MUST include the 'version' attribute set to a value of "1.0" in the initial stream header.</t>
        <t>If the TLS negotiation occurs between two servers, communications MUST NOT proceed until the Domain Name System (DNS) hostnames asserted by the servers have been resolved (see <xref target="security-server">Server-to-Server Communications</xref>).</t>
        <t>When a receiving entity that complies with this specification receives an initial stream header that includes the 'version' attribute set to a value of at least "1.0", after sending a stream header in reply (including the version flag), it MUST include a &lt;starttls/&gt; element (qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace) along with the list of other stream features it supports.</t>
        <t>If the initiating entity chooses to use TLS, TLS negotiation MUST be completed before proceeding to SASL negotiation; this order of negotiation is required to help safeguard authentication information sent during SASL negotiation, as well as to make it possible to base the use of the SASL EXTERNAL mechanism on a certificate provided during prior TLS negotiation.</t>
        <t>During TLS negotiation, an entity MUST NOT send any white space characters (matching production [3] content of <xref target="XML"/>) within the root stream element as separators between elements (any white space characters shown in the TLS examples that follow are included for the sake of readability only); this prohibition helps to ensure proper security layer byte precision.</t>
        <t>The receiving entity MUST consider the TLS negotiation to have begun immediately after sending the closing "&gt;" character of the &lt;proceed/&gt; element to the initiating entity.  The initiating entity MUST consider the TLS negotiation to have begun immediately after receiving the closing "&gt;" character of the &lt;proceed/&gt; element from the receiving entity.</t>
        <t>The initiating entity MUST validate the certificate presented by the receiving entity; see <xref target="security-validation">Certificate Validation</xref> regarding certificate validation procedures.</t>
        <t>Certificates MUST be checked against the hostname as provided by the initiating entity (e.g., a user), not the hostname as resolved via the Domain Name System; e.g., if the user specifies a hostname of "example.net" but a <xref target="DNS-SRV"/> lookup returned "im.example.net", the certificate MUST be checked as "example.net".  If a JID for an XMPP client (e.g., an end user account) is represented in a certificate, it MUST be represented as a UTF8String within an otherName entity inside the subjectAltName, using the <xref target="ASN.1"/> Object Identifier "id-on-xmppAddr" specified in <xref target="tls-overview-oid"/> of this document.  If a JID for an XMPP server is represented in a certificate, it SHOULD be represented as a UTF8String within an otherName entity inside the subjectAltName, using the <xref target="ASN.1"/> Object Identifier "id-on-xmppAddr" specified in <xref target="tls-overview-oid"/> of this document; however, the JID for an XMPP server MAY also or instead be represented as a subjectAltName extension of type dNSName, where the dNSName may contain the wildcard character '*', which applies only to the left-most domain name component or component fragment and is considered to match any single component or component fragment (e.g., *.example.com matches foo.example.com but not bar.foo.example.com, and im*.example.net matches im1.example.net and im2.example.net but not chat.example.net).</t>
        <t>If the TLS negotiation is successful, the initiating entity MUST send a new stream header to the receiving entity.</t>
        <t>If the TLS negotiation is successful, the receiving entity MUST discard any knowledge obtained in an insecure manner from the initiating entity before TLS takes effect.</t>
        <t>If the TLS negotiation is successful, the initiating entity MUST discard any knowledge obtained in an insecure manner from the receiving entity before TLS takes effect.</t>
        <t>If the TLS negotiation is successful, the receiving entity MUST NOT offer the STARTTLS extension to the initiating entity along with the other stream features that are offered after the new stream header is received and responded to.</t>
        <t>If the TLS negotiation is successful, the initiating entity MUST continue with SASL negotiation.</t>
        <t>If the TLS negotiation results in failure, the receiving entity MUST terminate both the XML stream and the underlying TCP connection.</t>
        <t>See <xref target="security-mandatory">Mandatory-to-Implement Technologies</xref> regarding mechanisms that MUST be supported.</t>
      </list></t>
      <section title="ASN.1 Object Identifier for XMPP Address" anchor="tls-overview-oid">
        <t>The <xref target="ASN.1"/> Object Identifier "id-on-xmppAddr" described above is defined as follows:</t>
        <figure>
          <artwork><![CDATA[
id-pkix OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
        dod(6) internet(1) security(5) mechanisms(5) pkix(7) }

id-on  OBJECT IDENTIFIER ::= { id-pkix 8 }  -- other name forms

id-on-xmppAddr  OBJECT IDENTIFIER ::= { id-on 5 }

XmppAddr ::= UTF8String
          ]]></artwork>
        </figure>
        <t>This Object Identifier MAY also be represented in dotted display format (i.e., "1.3.6.1.5.5.7.8.5") or in the Uniform Resource Name notation specified in <xref target='URN-OID'/> (i.e., "urn:oid:1.3.6.1.5.5.7.8.5").</t>
        <t>Thus for example the JID "example.com" as included in a certificate might be formatted as "subjectAltName=otherName:1.3.6.1.5.5.7.8.5;UTF8:example.com".</t>
      </section>
    </section>
    <section title="Narrative" anchor="tls-narr">
      <t>When an initiating entity secures a stream with a receiving entity using TLS, the steps involved are as follows:</t>
      <t><list style='numbers'>
        <t>The initiating entity opens a TCP connection and initiates the stream by sending the opening XML stream header to the receiving entity, including the 'version' attribute set to a value of at least "1.0".</t>
        <t>The receiving entity responds by opening a TCP connection and sending an XML stream header to the initiating entity, including the 'version' attribute set to a value of at least "1.0".</t>
        <t>The receiving entity offers the STARTTLS extension to the initiating entity by including it with the list of other supported stream features (if successful TLS negotiation is required for interaction with the receiving entity, it SHOULD signal that fact by including a &lt;required/&gt; element as a child of the &lt;starttls/&gt; element); the receiving entity SHOULD also include a list of supported SASL mechanisms in the stream features.</t>
        <t>The initiating entity issues the STARTTLS command (i.e., a &lt;starttls/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace) to instruct the receiving entity that it wishes to begin a TLS negotiation to secure the stream.</t>
        <t>The receiving entity MUST reply with either a &lt;proceed/&gt; element or a &lt;failure/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace.  If the failure case occurs, the receiving entity MUST terminate both the XML stream and the underlying TCP connection (failure cases include when the initiating entity sends a malformed STARTTLS command, when the receiving entity does not offer TLS negotiation either temporarily or permanently, and when the receiving entity cannot complete TLS negotiation because of an internal error).  If the proceed case occurs, the entities MUST attempt to complete the TLS negotiation over the TCP connection and MUST NOT send any further XML data until the TLS negotiation is complete.</t>
        <t>The initiating entity and receiving entity attempt to complete a TLS negotiation in accordance with <xref target="TLS"/>.</t>
        <t>If the TLS negotiation is unsuccessful, the receiving entity MUST terminate the TCP connection.  If the TLS negotiation is successful, the initiating entity MUST initiate a new stream by sending an opening XML stream header to the receiving entity (it is not necessary to send a closing &lt;/stream&gt; tag first, since the receiving entity and initiating entity MUST consider the original stream to be closed upon successful TLS negotiation).</t>
        <t>Upon receiving the new stream header from the initiating entity, the receiving entity MUST respond by sending a new XML stream header to the initiating entity along with the available features (but not including the STARTTLS feature) and SHOULD include an updated list of SASL mechanisms so that the initiating entity can detect any changes to the list of SASL mechanisms supported by the receiving entity.</t>
      </list></t>
    </section>
    <t>Examples of TLS negotiation are provided under <xref target="examples"/>.</t>
  </section>

  <section title="SASL Negotiation" anchor="sasl">
    <section title="Overview" anchor="sasl-overview">
      <t>XMPP includes a method for authenticating a stream by means of an XMPP-specific profile of the Simple Authentication and Security Layer protocol (see <xref target="SASL"/>).  SASL provides a generalized method for adding authentication support to connection-based protocols, and XMPP uses a generic XML namespace profile for SASL that conforms to the profiling requirements of <xref target="SASL"/>.</t>
      <t>The following rules apply:</t>
      <t><list style='numbers'>
        <t>If the SASL negotiation occurs between two servers, communications MUST NOT proceed until the Domain Name System (DNS) hostnames asserted by the servers have been resolved (see <xref target="security-server">Server-to-Server Communications</xref>).</t>
        <t>If the initiating entity is capable of SASL negotiation, it MUST include the 'version' attribute set to a value of at least "1.0" in the initial stream header.</t>
        <t>If the receiving entity is capable of SASL negotiation, it MUST advertise one or more authentication mechanisms within a &lt;mechanisms/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace in reply to the opening stream tag received from the initiating entity (if the opening stream tag included the 'version' attribute set to a value of at least "1.0").</t>
        <t>During SASL negotiation, an entity MUST NOT send any white space characters (matching production [3] content of <xref target="XML"/>) within the root stream element as separators between elements (any white space characters shown in the SASL examples that follow are included for the sake of readability only); this prohibition helps to ensure proper security layer byte precision.</t>
        <t>Any XML character data contained within the XML elements used during SASL negotiation MUST be encoded using base64, where the encoding adheres to the definition in Section 3 of <xref target="BASE64">RFC 3548</xref>.</t>
        <t>If the receiving entity does not include a 'realm' value, the initiating entity must default it to the domain identifier portion of the receiving entity's JID.</t>
        <t>If provision of a "simple username" is supported by the selected SASL mechanism (e.g., this is supported by the DIGEST-MD5 and CRAM-MD5 mechanisms but not by the EXTERNAL and GSSAPI mechanisms), during authentication the initiating entity SHOULD provide as the simple username its sending domain (IP address or fully qualified domain name as contained in a domain identifier) in the case of server-to-server communications or its registered account name (user or node name as contained in an XMPP node identifier) in the case of client-to-server communications.  In either case, the initiating entity MUST ensure that the username adheres to the <xref target="NAMEPREP"/> or <xref target='nodeprep'>Nodeprep</xref> profile of <xref target="STRINGPREP"/> (as appropriate) before sending it to the receiving entity.  (Note: Account provisioning is out of scope for this specification; possible methods for account provisioning include account creation by a server administrator and in-band account registration using the 'jabber:iq:register' namespace as documented in <xref target="XEP-0077"/>.)</t>
        <t>If the initiating entity wishes to act on behalf of another entity and the selected SASL mechanism supports transmission of an authorization identity, the initiating entity MUST provide an authorization identity during SASL negotiation.  If the initiating entity does not wish to act on behalf of another entity, it MUST NOT provide an authorization identity.  As specified in <xref target="SASL"/>, the initiating entity MUST NOT provide an authorization identity unless the authorization identity is different from the default authorization identity derived from the authentication identity.  If provided, the value of the authorization identity MUST be of the form &lt;domain&gt; (i.e., a domain identifier only) for servers and of the form &lt;node@domain&gt; (i.e., node identifier and domain identifier) for clients.</t>
        <t>If the SASL negotiation is successful, the initiating entity MUST send a new stream header to the receiving entity.</t>
        <t>Upon successful SASL negotiation that involves negotiation of a security layer, the receiving entity MUST discard any knowledge obtained from the initiating entity which was not obtained from the SASL negotiation itself; the receiving entity SHOULD also send new stream features (including an updated list of SASL mechanisms) so that the initiating entity can detect any changes to the list of mechanisms supported by the receiving entity.</t>
        <t>Upon successful SASL negotiation that involves negotiation of a security layer, the initiating entity MUST discard any knowledge obtained from the receiving entity which was not obtained from the SASL negotiation itself.</t>
        <t>See <xref target="security-mandatory">Mandatory-to-Implement Technologies</xref> regarding mechanisms that MUST be supported; naturally, other SASL mechanisms MAY be supported as well (best practices for the use of several SASL mechanisms in the context of XMPP are described in <xref target='XEP-0175'/> and <xref target='XEP-0178'/>).</t>
      </list></t>
    </section>
    <section title="Narrative" anchor="sasl-narr">
      <t>When an initiating entity authenticates with a receiving entity using SASL, the steps involved are as follows:</t>
      <t><list style="numbers">
        <t>The initiating entity requests SASL authentication by including the 'version' attribute in the opening XML stream header sent to the receiving entity, with the value set to "1.0".</t>
        <t>After sending an XML stream header in reply, the receiving entity advertises a list of available SASL authentication mechanisms as stream features; each of these is a &lt;mechanism/&gt; element included as a child within a &lt;mechanisms/&gt; container element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace, which in turn is a child of a &lt;features/&gt; element in the streams namespace.  If <xref target='tls'>TLS negotiation</xref> needs to be completed before a particular authentication mechanism may be used, the receiving entity MUST NOT provide that mechanism in the list of available SASL authentication mechanisms prior to TLS negotiation.  If the initiating entity presents a valid certificate during prior TLS negotiation, the receiving entity SHOULD offer the SASL EXTERNAL mechanism to the initiating entity during SASL negotiation (refer to <xref target="SASL"/>), although the EXTERNAL mechanism MAY be offered under other circumstances as well.  If successful SASL negotiation is required for interaction with the receiving entity, it SHOULD signal that fact by including a &lt;required/&gt; element as a child of the &lt;mechanisms/&gt; element.</t>
        <t>The initiating entity selects a mechanism by sending an &lt;auth/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace to the receiving entity and including an appropriate value for the 'mechanism' attribute.  This element MAY contain XML character data (in SASL terminology, the "initial response") if the mechanism supports or requires it; if the initiating entity needs to send a zero-length initial response, it MUST transmit the response as a single equals sign ("="), which indicates that the response is present but contains no data.</t>
        <t>If necessary, the receiving entity challenges the initiating entity by sending to the initiating entity a &lt;challenge/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element MAY contain XML character data (which MUST be computed in accordance with the definition of the SASL mechanism chosen by the initiating entity).</t>
        <t>The initiating entity responds to the challenge by sending to the receiving entity a &lt;response/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element MAY contain XML character data (which MUST be computed in accordance with the definition of the SASL mechanism chosen by the initiating entity).</t>
        <t>If necessary, the receiving entity sends more challenges and the initiating entity sends more responses.</t>
      </list></t>
      <t>This series of challenge/response pairs continues until one of three things happens:</t>
      <t><list style="numbers">
        <t>The initiating entity aborts the handshake by sending an &lt;abort/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace to the receiving entity.  Upon receiving an &lt;abort/&gt; element, the receiving entity SHOULD allow a configurable but reasonable number of retries (at least 2), after which it MUST terminate the TCP connection; this enables the initiating entity (e.g., an end-user client) to tolerate incorrectly-provided credentials (e.g., a mistyped password) without being forced to reconnect.</t>
        <t>The receiving entity reports failure of the handshake by sending a &lt;failure/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace to the initiating entity (the particular cause of failure SHOULD be communicated in an appropriate child element of the &lt;failure/&gt; element as defined under <xref target="sasl-errors">SASL Errors</xref>).  If the failure case occurs, the receiving entity SHOULD allow a configurable but reasonable number of retries (at least 2), after which it MUST terminate the TCP connection; this enables the initiating entity (e.g., an end-user client) to tolerate incorrectly-provided credentials (e.g., a mistyped password) without being forced to reconnect.</t>
        <t>The receiving entity reports success of the handshake by sending a &lt;success/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace to the initiating entity; this element MAY contain XML character data (in SASL terminology, "additional data with success") if required by the chosen SASL mechanism; if the receiving entity needs to send additional data of zero length, it MUST transmit the data as a single equals sign ("=").  Upon receiving the &lt;success/&gt; element, the initiating entity MUST initiate a new stream by sending an opening XML stream header to the receiving entity (it is not necessary to send a closing &lt;/stream&gt; tag first, since the receiving entity and initiating entity MUST consider the original stream to be closed upon sending or receiving the &lt;success/&gt; element).  Upon receiving the new stream header from the initiating entity, the receiving entity MUST respond by sending a new XML stream header to the initiating entity, along with any available features or an empty &lt;features/&gt; element (to signify that no additional features are available); any such additional features not defined herein MUST be defined by the relevant extension to XMPP.  As noted, if SASL negotiation involved establishment of a security layer, the receiving entity SHOULD send an updated list of SASL mechanisms so that the initiating entity can detect any changes to the list of mechanisms supported by the receiving entity.</t>
      </list></t>
    </section>
    <section title="SASL Definition" anchor="sasl-def">
      <t>The profiling requirements of <xref target="SASL"/> require that the following information be supplied by a protocol definition:</t>
      <t><list style="hanging">
        <t hangText="service name:">"xmpp"</t>
        <t hangText="initiation sequence:">After the initiating entity provides an opening XML stream header and the receiving entity replies in kind, the receiving entity provides a list of acceptable authentication methods.  The initiating entity chooses one method from the list and sends it to the receiving entity as the value of the 'mechanism' attribute possessed by an &lt;auth/&gt; element, optionally including an initial response to avoid a round trip.</t>
        <t hangText="exchange sequence:">Challenges and responses are carried through the exchange of &lt;challenge/&gt; elements from receiving entity to initiating entity and &lt;response/&gt; elements from initiating entity to receiving entity.  The receiving entity reports failure by sending a &lt;failure/&gt; element and success by sending a &lt;success/&gt; element; the initiating entity aborts the exchange by sending an &lt;abort/&gt; element.  Upon successful negotiation, both sides consider the original XML stream to be closed and new stream headers are sent by both entities.</t>
        <t hangText="security layer negotiation:">The security layer takes effect immediately after sending the closing "&gt;" character of the &lt;success/&gt; element for the receiving entity, and immediately after receiving the closing "&gt;" character of the &lt;success/&gt; element for the initiating entity.  The order of layers is first <xref target="TCP"/>, then <xref target="TLS"/>, then <xref target="SASL"/>, then XMPP.</t>
        <t hangText="use of the authorization identity:">The authorization identity may be used by xmpp to denote the non-default &lt;node@domain&gt; of a client or the sending &lt;domain&gt; of a server; an empty string is equivalent to an absent authorization identity.</t>
      </list></t>
    </section>
    <section title="SASL Errors" anchor="sasl-errors">
      <t>The following SASL-related error conditions are defined:</t>
      <t><list style='symbols'>
        <t>&lt;aborted/&gt; -- The receiving entity acknowledges an &lt;abort/&gt; element sent by the initiating entity; sent in reply to the &lt;abort/&gt; element.</t>
        <t>&lt;incorrect-encoding/&gt; -- The data provided by the initiating entity could not be processed because the <xref target="BASE64"/> encoding is incorrect (e.g., because the encoding does not adhere to the definition in Section 3 of <xref target="BASE64"/>); sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <t>&lt;invalid-authzid/&gt; -- The authzid provided by the initiating entity is invalid, either because it is incorrectly formatted or because the initiating entity does not have permissions to authorize that ID; sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <t>&lt;invalid-mechanism/&gt; -- The initiating entity did not provide a mechanism or requested a mechanism that is not supported by the receiving entity; sent in reply to an &lt;auth/&gt; element.</t>
        <t>&lt;malformed-request/&gt; -- The challenge or response is malformed (e.g., the &lt;auth/&gt; element includes an initial response but the mechanism does not allow that); sent in reply to an &lt;abort/&gt;, &lt;auth/&gt;, &lt;challenge/&gt;, or &lt;response/&gt; element.</t>
        <t>&lt;mechanism-too-weak/&gt; -- The mechanism requested by the initiating entity is weaker than server policy permits for that initiating entity; sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <t>&lt;not-authorized/&gt; -- The authentication failed because the initiating entity did not provide proper credentials (this includes but is not limited to the case of an unknown username, and no differentiation is made between an unknown username and incorrect credentials); sent in reply to a &lt;response/&gt; element or an &lt;auth/&gt; element with initial response data.</t>
        <t>&lt;temporary-auth-failure/&gt; -- The authentication failed because of a temporary error condition within the receiving entity, and the initiating entity should try again later; sent in reply to an &lt;auth/&gt; element or &lt;response/&gt; element.</t>
      </list></t>
    </section>
    <t>Examples of SASL negotiation are provided under <xref target="examples"/>.</t>
  </section>

  <section title="Resource Binding" anchor="bind">
    <t>After a client authenticates with a server, it MUST bind a specific resource to the stream so that the server can properly address the client (see <xref target="addressing">addresses</xref>) and route XML stanzas to and from the client (see <xref target="rules">stanza delivery rules</xref>).  That is, there MUST be a resource identifier associated with the "bare JID" (&lt;node@domain&gt;) of the client; this ensures that the address for use over that stream is a "full JID" of the form &lt;node@domain/resource&gt;.  After binding a resource to the stream, the client is referred to as a CONNECTED RESOURCE.</t>
    <t>Upon receiving a success indication within the SASL negotiation, the client MUST send a new stream header to the server, to which the server MUST respond with a stream header as well as a list of available stream features.  Specifically, if the server requires the client to bind a resource to the stream after successful SASL negotiation, it MUST include a &lt;bind/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-bind' namespace in the stream features list it presents to the client upon sending the header for the response stream sent after successful SASL negotiation (but not before); this &lt;bind/&gt; element SHOULD include an empty &lt;required/&gt; element as well.</t>
    <figure>
      <preamble>Server advertises resource binding feature to client:</preamble>
      <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='example.com'
    id='c2s_345'
    to='juliet@example.com'
    version='1.0'>
<stream:features>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <required/>
  </bind>
</stream:features>
      ]]></artwork>
    </figure>
    <t>Upon being so informed that resource binding is required, the client MUST bind a resource to the stream by sending to the server an IQ stanza of type "set" (see <xref target="stanzas-semantics-iq">IQ Semantics</xref>) containing data qualified by the 'urn:ietf:params:xml:ns:xmpp-bind' namespace.</t>
    <t>If the client wishes to allow the server to generate the resource identifier on its behalf, it sends an IQ stanza of type "set" that contains an empty &lt;bind/&gt; element.</t>
    <figure>
      <preamble>Client asks server to bind a resource:</preamble>
      <artwork><![CDATA[
<iq type='set' id='bind_1'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
</iq>
      ]]></artwork>
    </figure>
    <t>A server that supports resource binding MUST be able to generate a resource identifier on behalf of a client.  A resource identifier generated by the server MUST be currently unique for that &lt;node@domain&gt;.</t>
    <t>If the client wishes to specify the resource identifier, it MUST send an IQ stanza of type "set" that contains the desired resource identifier as the non-zero-length XML character data of a &lt;resource/&gt; element that is a child of the &lt;bind/&gt; element.</t>
    <figure>
      <preamble>Client binds a resource:</preamble>
      <artwork><![CDATA[
<iq type='set' id='bind_2'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <resource>balcony</resource>
  </bind>
</iq>
      ]]></artwork>
    </figure>
    <t>Once the server has generated a resource identifier for the client or accepted the resource identifier provided by the client, it MUST return an IQ stanza of type "result" to the client, which MUST include a &lt;jid/&gt; child element that specifies the full JID for the connected resource as determined by the server.</t>
    <figure>
      <preamble>Server informs client of successful resource binding:</preamble>
      <artwork><![CDATA[
<iq type='result' id='bind_2'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <jid>juliet@example.com/balcony</jid>
  </bind>
</iq>
      ]]></artwork>
    </figure>
    <t>A server SHOULD accept the resource identifier provided by the client, but MAY override it with a resource identifier that the server generates; in this case, the server SHOULD NOT return a stanza error (e.g., &lt;forbidden/&gt;) to the client but instead SHOULD communicate the generated resource identifier to the client in the IQ result as shown above.</t>
    <t>When a client supplies a resource identifier, the following stanza error conditions are possible (see <xref target="stanzas-error">Stanza Errors</xref>):</t>
    <t><list style="symbols">
      <t>The provided resource identifier cannot be processed by the server, e.g. because it is not in accordance with <xref target="resourceprep">Resourceprep</xref>.</t>
      <t>The client is not allowed to bind a resource to the stream (e.g., because the node or user has reached a limit on the number of connected resources allowed).</t>
      <t>The provided resource identifier is already in use but the server does not allow binding of multiple connected resources with the same identifier.</t>
    </list></t>
    <t>The protocol for these error conditions is as follows.</t>
    <figure>
      <preamble>Resource identifier cannot be processed:</preamble>
      <artwork><![CDATA[
<iq type='error' id='bind_2'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <resource>someresource</resource>
  </bind>
  <error type='modify'>
    <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  </error>
</iq>
      ]]></artwork>
    </figure>
    <figure>
      <preamble>Client is not allowed to bind a resource:</preamble>
      <artwork><![CDATA[
<iq type='error' id='bind_2'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <resource>someresource</resource>
  </bind>
  <error type='cancel'>
    <not-allowed xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  </error>
</iq>
      ]]></artwork>
    </figure>
    <t>If there is already a connected resource of the same name, the server MUST do one of the following:</t>
    <t>
      <list style='numbers'>
        <t>Not accept the resource identifier provided by the client but instead override it with a resource identifier that the server generates.</t>
        <t>Terminate the current resource and allow the newly-requested resource.</t>
        <t>Disallow the newly-requested resource and maintain the current resource.</t>
      </list>
    </t>
    <t>Which of these the server does is up to the implementation, although it is RECOMMENDED to implement case #1.  In case #2, the server MUST send a &lt;conflict/&gt; stream error to the current resource, terminate the XML stream and underlying TCP connection for the current resource, and return a IQ stanza of type "result" (indicating success) to the newly-requested resource.  In case #3, the server MUST either (a) return a server-generated resource name or (b) send a &lt;conflict/&gt; stanza error to the newly-requested resource but maintain the XML stream for that connection so that the newly-requested resource has an opportunity to negotiate a non-conflicting resource identifier before sending another request for resource binding.</t>
    <figure>
      <preamble>Resource identifier is in use:</preamble>
      <artwork><![CDATA[
<iq type='error' id='bind_2'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <resource>someresource</resource>
  </bind>
  <error type='cancel'>
    <conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  </error>
</iq>
      ]]></artwork>
    </figure>
    <t>If, before completing the resource binding step, the client attempts to send an outbound XML stanza (i.e., a stanza not directed to the server itself or to the client's own account), the server MUST NOT process the stanza and SHOULD return a &lt;not-authorized/&gt; stanza error to the client.</t>
    <section title="Binding Multiple Resources" anchor="bind-multi">
      <t>A server MAY support binding of multiple resources to the same stream.  This functionality is desirable in certain environments (e.g., for devices that are unable to open more than one TCP connection or when a machine runs an XMPP client daemon that is used by multiple applications).  If a server supports binding of multiple resources to a stream, it MUST enable a client to unbind resources.  This shall be completed by sending an IQ-set with a child element of &lt;unbind/&gt; qualified by the 'urn:ietf:params:xml:ns:xmpp-bind' namespace, which in turn has a child element of &lt;resource/&gt; whose XML character data specifies the resource to be unbound:</t>
      <figure>
        <artwork><![CDATA[
<iq type='set' id='unbind_1'>
  <unbind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <resource>someresource</resource>
  </unbind>
</iq>
        ]]></artwork>
      </figure>
      <t>If the server does not understand the &lt;unbind/&gt; element, it MUST return an error of &lt;bad-request/&gt;.  Otherwise, if there is no such resource for that stream, the server MUST return an error of &lt;item-not-found/&gt;.  When the client unbinds the only resource associated with the stream, the server SHOULD close the stream and terminate the TCP connection.</t>
      <t>A server SHOULD advertise its support for the 'urn:ietf:params:xml:ns:xmpp-bind' namespace by returning an appropriate stream feature as follows:</t>
      <figure>
        <artwork><![CDATA[
<stream:features>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
  <unbind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>
</stream:features>
        ]]></artwork>
      </figure>
      <t>When a client binds multiple resources to the same stream, proper management of 'from' addresses is imperative. In particular, a client MUST specify a 'from' address on every stanza it sends over a stream to which it has bound multiple resources, where the 'from' address is the full JID (&lt;node@domain.tld/resource&gt;) associated with the relevant resource. If a client does not specify a 'from' address on a stanza it sends over a stream to which it has bound multiple resources (or if it specifies as the 'from' address a full JID other than one of the bound resources), the server MUST return the stanza to the client with an &lt;unknown-sender/&gt; stanza error.</t>
      <t>Naturally, the rules regarding validation of asserted 'from' addresses still apply (see <xref target='rules'/>).</t>
    </section>
  </section>

  <section title="XML Stanzas" anchor="stanzas">
    <t>After a client has connected to a server or two servers have connected to each other, either party can send XML stanzas over the negotiated stream.  Three kinds of XML stanza are defined for the 'jabber:client' and 'jabber:server' namespaces: &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;.  In addition, there are five common attributes for these kinds of stanza.  These common attributes, as well as the basic semantics of the three stanza kinds, are defined herein; more detailed information regarding the syntax of XML stanzas for instant messaging and presence applications is provided in <xref target="XMPP-IM"/>, and for other applications in the relevant XMPP extension specifications.</t>
    <t>An XML stanza is the basic unit of meaning in XMPP.  A server MUST NOT process, deliver, or route a partial stanza and a server MUST NOT attach meaning to the transmission timing of any child element within a stanza.</t>

    <section title="Common Attributes" anchor="stanzas-attributes">
      <t>The following five attributes are common to message, presence, and IQ stanzas:</t>
      <section title="to" anchor="stanzas-attributes-to">
        <t>The 'to' attribute specifies the JID of the intended recipient for the stanza.</t>
        <t>In the 'jabber:client' namespace, a stanza with a specific intended recipient MUST possess a 'to' attribute, whereas a stanza sent from a client to a server for direct processing by that server (e.g., presence sent to the server for broadcasting to other entities) SHOULD NOT possess a 'to' attribute.</t>
        <t>In the 'jabber:server' namespace, a stanza MUST possess a 'to' attribute; if a server receives a stanza that does not meet this restriction, it MUST generate an &lt;improper-addressing/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection with the offending server.</t>
        <t>If the value of the 'to' attribute is invalid or cannot be contacted, the entity discovering that fact (usually the sender's or recipient's server) MUST return an appropriate error to the sender, setting the 'from' attribute of the error stanza to the value provided in the 'to' attribute of the offending stanza.</t>
      </section>
      <section title="from" anchor="stanzas-attributes-from">
        <t>The 'from' attribute specifies the JID of the sender.</t>
        <t>When a server receives an XML stanza within the context of an authenticated stream qualified by the 'jabber:client' namespace, it MUST do one of the following:
          <list style="numbers">
            <t>validate that the value of the 'from' attribute provided by the client is that of a connected resource for the associated entity</t>
            <t>add a 'from' address to the stanza whose value is the full JID (&lt;node@domain/resource&gt;) determined by the server for the connected resource that generated the stanza (see <xref target="addressing-determination">Determination of Addresses</xref>), or the bare JID (&lt;node@domain&gt;) in the case of subscription-related presence stanzas (see <xref target='XMPP-IM'/> for details)</t>
          </list>
        </t>
        <t>If a client attempts to send an XML stanza for which the value of the 'from' attribute does not exactly match one of the connected resources for that entity, the server SHOULD return an &lt;invalid-from/&gt; stream error to the client.  If a client attempts to send an XML stanza over a stream that is not yet authenticated, the server SHOULD return a &lt;not-authorized/&gt; stream error to the client.  If generated, both of these conditions MUST result in closure of the stream and termination of the underlying TCP connection; this helps to prevent a denial of service attack launched from a rogue client.</t>
        <t>When a server generates a stanza from the server itself for delivery to a connected client (e.g., in the context of data storage services provided by the server on behalf of the client), the stanza MUST either (1) not include a 'from' attribute or (2) include a 'from' attribute whose value is the account's bare JID (&lt;node@domain&gt;) or connected resource's full JID (&lt;node@domain/resource&gt;).  A server MUST NOT send to the client a stanza without a 'from' attribute if the stanza was not generated by the server itself.  When a client receives a stanza that does not include a 'from' attribute, it MUST assume that the stanza is from the server to which the client is connected.</t>
        <t>In the 'jabber:server' namespace, a stanza MUST possess a 'from' attribute; if a server receives a stanza that does not meet this restriction, it MUST generate an &lt;improper-addressing/&gt; stream error condition.  Furthermore, the domain identifier portion of the JID contained in the 'from' attribute MUST match the hostname of the sending server (or any validated domain thereof, such as a validated subdomain of the sending server's hostname or another validated domain hosted by the sending server) as communicated in the SASL negotiation or dialback negotiation; if a server receives a stanza that does not meet this restriction, it MUST generate an &lt;invalid-from/&gt; stream error condition.  Both of these conditions MUST result in closure of the stream and termination of the underlying TCP connection; this helps to prevent a denial of service attack launched from a rogue server.</t>
      </section>
      <section title="id" anchor="stanzas-attributes-id">
        <t>The optional 'id' attribute MAY be used by a sending entity for internal tracking of stanzas that it sends and receives (especially for tracking the request-response interaction inherent in the semantics of IQ stanzas).  It is OPTIONAL for the value of the 'id' attribute to be unique globally, within a domain, or within a stream.  The semantics of IQ stanzas impose additional restrictions; see <xref target="stanzas-semantics-iq">IQ Semantics</xref>.</t>
      </section>
      <section title="type" anchor="stanzas-attributes-type">
        <t>The 'type' attribute specifies detailed information about the purpose or context of the message, presence, or IQ stanza.  The particular allowable values for the 'type' attribute vary depending on whether the stanza is a message, presence, or IQ; the values for message and presence stanzas are specific to instant messaging and presence applications and therefore are defined in <xref target="XMPP-IM"/>, whereas the values for IQ stanzas specify the role of an IQ stanza in a structured request-response "conversation" and thus are defined under <xref target="stanzas-semantics-iq">IQ Semantics</xref> below.  The only 'type' value common to all three stanzas is "error"; see <xref target="stanzas-error">Stanza Errors</xref>.</t>
      </section>
      <section title="xml:lang" anchor="stanzas-attributes-lang">
        <t>A stanza SHOULD possess an 'xml:lang' attribute (as defined in Section 2.12 of <xref target="XML"/>) if the stanza contains XML character data that is intended to be presented to a human user (as explained in <xref target="CHARSET"/>, "internationalization is for humans").  The value of the 'xml:lang' attribute specifies the default language of any such human-readable XML character data, which MAY be overridden by the 'xml:lang' attribute of a specific child element.  If a stanza does not possess an 'xml:lang' attribute, an implementation MUST assume that the default language is that specified for the stream as defined under <xref target="streams-attr">Stream Attributes</xref> above.  The value of the 'xml:lang' attribute MUST be an NMTOKEN and MUST conform to the format defined in <xref target="LANGTAGS"/>.</t>
      </section>
    </section>

    <section title="Basic Semantics" anchor="stanzas-semantics">
      <section title="Message Semantics" anchor="stanzas-semantics-message">
        <t>The &lt;message/&gt; stanza kind can be seen as a "push" mechanism whereby one entity pushes information to another entity, similar to the communications that occur in a system such as email.  All message stanzas SHOULD possess a 'to' attribute that specifies the intended recipient of the message; upon receiving such a stanza, a server SHOULD route or deliver it to the intended recipient (see <xref target="rules">Server Rules for Handling XML Stanzas</xref> for general routing and delivery rules related to XML stanzas).</t>
      </section>
      <section title="Presence Semantics" anchor="stanzas-semantics-presence">
        <t>The &lt;presence/&gt; element can be seen as a specialized broadcast or "publish-subscribe" mechanism, whereby multiple entities receive information about an entity to which they have subscribed (in this case, network availability information).  In general, a publishing entity SHOULD send a presence stanza with no 'to' attribute, in which case the server to which the entity is connected SHOULD broadcast or multiplex that stanza to all subscribing entities.  However, a publishing entity MAY also send a presence stanza with a 'to' attribute, in which case the server SHOULD route or deliver that stanza to the intended recipient.  See <xref target="rules">Server Rules for Handling XML Stanzas</xref> for general routing and delivery rules related to XML stanzas, and <xref target="XMPP-IM"/> for rules specific to presence applications.</t>
      </section>
      <section title="IQ Semantics" anchor="stanzas-semantics-iq">
        <t>Info/Query, or IQ, is a request-response mechanism, similar in some ways to <xref target="HTTP"/>.  The semantics of IQ enable an entity to make a request of, and receive a response from, another entity.  The data content of the request and response is defined by the schema or other structural definition associated with the XML namespace that qualifies the direct child element of the IQ element (see <xref target='stanzas-extended'>extended namespaces</xref>), and the interaction is tracked by the requesting entity through use of the 'id' attribute.  Thus, IQ interactions follow a common pattern of structured data exchange such as get/result or set/result (although an error may be returned in reply to a request if appropriate):</t>
        <figure>
          <artwork><![CDATA[
Requesting                 Responding
  Entity                     Entity
----------                 ----------
    |                           |
    | <iq type='get' id='1'>    |
    | ------------------------> |
    |                           |
    | <iq type='result' id='1'> |
    | <------------------------ |
    |                           |
    | <iq type='set' id='2'>    |
    | ------------------------> |
    |                           |
    | <iq type='error' id='2'>  |
    | <------------------------ |
    |                           |
          ]]></artwork>
        </figure>
        <t>In order to enforce these semantics, the following rules apply:</t>
        <t><list style='numbers'>
          <t>The 'id' attribute is REQUIRED for IQ stanzas.</t>
          <t>The 'type' attribute is REQUIRED for IQ stanzas.  The value MUST be one of the following:
            <list style="symbols">
              <t>get -- The stanza is a request for information or requirements.</t>
              <t>set -- The stanza provides required data, sets new values, or replaces existing values.</t>
              <t>result -- The stanza is a response to a successful get or set request.</t>
              <t>error -- An error has occurred regarding processing or delivery of a previously-sent get or set (see <xref target="stanzas-error">Stanza Errors</xref>).</t>
            </list>
          </t>
          <t>An entity that receives an IQ request of type "get" or "set" MUST reply with an IQ response of type "result" or "error" (the response MUST preserve the 'id' attribute of the request).</t>
          <t>An entity that receives a stanza of type "result" or "error" MUST NOT respond to the stanza by sending a further IQ response of type "result" or "error"; however, as shown above, the requesting entity MAY send another request (e.g., an IQ of type "set" in order to provide required information discovered through a get/result pair).</t>
          <t>An IQ stanza of type "get" or "set" MUST contain one and only one child element that specifies the semantics of the particular request or response.</t>
          <t>An IQ stanza of type "result" MUST include zero or one child elements.</t>
          <t>An IQ stanza of type "error" SHOULD include the child element contained in the associated "get" or "set" and MUST include an &lt;error/&gt; child; for details, see <xref target="stanzas-error">Stanza Errors</xref>.</t>
        </list></t>
      </section>
    </section>

    <section title="Stanza Errors" anchor="stanzas-error">
      <t>Stanza-related errors are handled in a manner similar to <xref target="streams-error">stream errors</xref>.  However, unlike stream errors, stanza errors are recoverable; therefore error stanzas include hints regarding actions that the original sender can take in order to remedy the error.</t>
      <section title="Rules" anchor="stanzas-error-rules">
        <t>The following rules apply to stanza-related errors:</t>
        <t><list style="symbols">
          <t>The receiving or processing entity that detects an error condition in relation to a stanza SHOULD return an "error stanza" (and MUST do so for IQ stanzas), where such an "error stanza" is a stanza of the same kind (message, presence, or IQ) whose 'type' attribute is set to a value of "error".</t>
          <t>The entity that generates an error stanza SHOULD include the original XML sent so that the sender can inspect and, if necessary, correct the XML before attempting to resend.</t>
          <t>An error stanza MUST contain an &lt;error/&gt; child element.</t>
          <t>An &lt;error/&gt; child MUST NOT be included if the 'type' attribute has a value other than "error" (or if there is no 'type' attribute).</t>
          <t>An entity that receives an error stanza MUST NOT respond to the stanza with a further error stanza; this helps to prevent looping.</t>
        </list></t>
      </section>
      <section title="Syntax" anchor="stanzas-error-syntax">
        <t>The syntax for stanza-related errors is as follows:</t>
        <figure>
          <artwork><![CDATA[
<stanza-kind to='sender' type='error'>
  [RECOMMENDED to include sender XML here]
  <error type='error-type'>
    <defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    [<text xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'
          xml:lang='langcode'>
      OPTIONAL descriptive text
    </text>]
    [OPTIONAL application-specific condition element]
  </error>
</stanza-kind>
          ]]></artwork>
        </figure>
        <t>The "stanza-kind" is one of message, presence, or iq.</t>
        <t>The value of the &lt;error/&gt; element's 'type' attribute MUST be one of the following:</t>
        <t><list style="symbols">
          <t>cancel -- do not retry (the error is unrecoverable)</t>
          <t>continue -- proceed (the condition was only a warning)</t>
          <t>modify -- retry after changing the data sent</t>
          <t>auth -- retry after providing credentials</t>
          <t>wait -- retry after waiting (the error is temporary)</t>
        </list></t>
        <t>The &lt;error/&gt; element:</t>
        <t><list style="symbols">
          <t>MUST contain a child element corresponding to one of the defined stanza error conditions specified below; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-stanzas' namespace.</t>
          <t>MAY contain a &lt;text/&gt; child containing XML character data that describes the error in more detail; this element MUST be qualified by the 'urn:ietf:params:xml:ns:xmpp-stanzas' namespace and SHOULD possess an 'xml:lang' attribute.</t>
          <t>MAY contain a child element for an application-specific error condition; this element MUST be qualified by an application-defined namespace, and its structure is defined by that namespace.</t>
        </list></t>
        <t>The &lt;text/&gt; element is OPTIONAL.  If included, it SHOULD be used only to provide descriptive or diagnostic information that supplements the meaning of a defined condition or application-specific condition.  It SHOULD NOT be interpreted programmatically by an application.  It SHOULD NOT be used as the error message presented to a user, but MAY be shown in addition to the error message associated with the included condition element (or elements).</t>
        <t>Finally, to maintain backward compatibility, the schema (specified in <xref target="XMPP-IM"/>) allows the optional inclusion of a 'code' attribute on the &lt;error/&gt; element; for details, see <xref target="XEP-0086"/>.</t>
      </section>
      <section title="Defined Conditions" anchor="stanzas-error-conditions">
        <t>The following conditions are defined for use in stanza errors.</t>
        <t><list style="symbols">
          <t>&lt;bad-request/&gt; -- the sender has sent XML that is malformed or that cannot be processed (e.g., an IQ stanza that includes an unrecognized value of the 'type' attribute); the associated error type SHOULD be "modify".</t>
          <t>&lt;conflict/&gt; -- access cannot be granted because an existing resource exists with the same name or address; the associated error type SHOULD be "cancel".</t>
          <t>&lt;feature-not-implemented/&gt; -- the feature requested is not implemented by the recipient or server and therefore cannot be processed; the associated error type SHOULD be "cancel" or "modify".</t>
          <t>&lt;forbidden/&gt; -- the requesting entity does not possess the required permissions to perform the action; the associated error type SHOULD be "auth".</t>
          <t>&lt;gone/&gt; -- the recipient or server can no longer be contacted at this address (the error stanza MAY contain a new address in the XML character data of the &lt;gone/&gt; element); the associated error type SHOULD be "cancel" or "modify".</t>
          <t>&lt;internal-server-error/&gt; -- the server could not process the stanza because of a misconfiguration or an otherwise-undefined internal server error; the associated error type SHOULD be "wait".</t>
          <t>&lt;item-not-found/&gt; -- the addressed JID or item requested cannot be found; the associated error type SHOULD be "cancel".</t>
          <t>&lt;jid-malformed/&gt; -- the sending entity has provided or communicated an XMPP address (e.g., a value of the 'to' attribute) or aspect thereof (e.g., a resource identifier) that does not adhere to the syntax defined under <xref target="addressing">Addresses</xref>; the associated error type SHOULD be "modify".</t>
          <t>&lt;not-acceptable/&gt; -- the recipient or server understands the request but is refusing to process it because it does not meet criteria defined by the recipient or server (e.g., a local policy regarding stanza size limits or acceptable words in messages); the associated error type SHOULD be "modify".</t>
          <t>&lt;not-allowed/&gt; -- the recipient or server does not allow any entity to perform the action (e.g., sending to entities at a blacklisted domain); the associated error type SHOULD be "cancel".</t>
          <t>&lt;not-authorized/&gt; -- the sender must provide proper credentials before being allowed to perform the action, or has provided improper credentials; the associated error type SHOULD be "auth".</t>
          <t>&lt;not-modified/&gt; -- the item requested has not changed since it was last requested; the associated error type SHOULD be "continue".</t>
          <t>&lt;payment-required/&gt; -- the requesting entity is not authorized to access the requested service because payment is required; the associated error type SHOULD be "auth".</t>
          <t>&lt;recipient-unavailable/&gt; -- the intended recipient is temporarily unavailable; the associated error type SHOULD be "wait" (note: an application MUST NOT return this error if doing so would provide information about the intended recipient's network availability to an entity that is not authorized to know such information).</t>
          <t>&lt;redirect/&gt; -- the recipient or server is redirecting requests for this information to another entity, usually temporarily (the error stanza SHOULD contain the alternate address, which MUST be a valid JID, in the XML character data of the &lt;redirect/&gt; element); the associated error type SHOULD be "modify".</t>
          <t>&lt;registration-required/&gt; -- the requesting entity is not authorized to access the requested service because prior registration is required; the associated error type SHOULD be "auth".</t>
          <t>&lt;remote-server-not-found/&gt; -- a remote server or service specified as part or all of the JID of the intended recipient does not exist; the associated error type SHOULD be "cancel".</t>
          <t>&lt;remote-server-timeout/&gt; -- a remote server or service specified as part or all of the JID of the intended recipient (or required to fulfill a request) could not be contacted within a reasonable amount of time; the associated error type SHOULD be "wait".</t>
          <t>&lt;resource-constraint/&gt; -- the server or recipient lacks the system resources necessary to service the request; the associated error type SHOULD be "wait".</t>
          <t>&lt;service-unavailable/&gt; -- the server or recipient does not currently provide the requested service; the associated error type SHOULD be "cancel".</t>
          <t>&lt;subscription-required/&gt; -- the requesting entity is not authorized to access the requested service because a subscription is required; the associated error type SHOULD be "auth".</t>
          <t>&lt;undefined-condition/&gt; -- the error condition is not one of those defined by the other conditions in this list; any error type may be associated with this condition, and it SHOULD be used only in conjunction with an application-specific condition.</t>
          <t>&lt;unexpected-request/&gt; -- the recipient or server understood the request but was not expecting it at this time (e.g., the request was out of order); the associated error type SHOULD be "wait" or "modify".</t>
          <t>&lt;unknown-sender/&gt; -- the stanza 'from' address specified by a remote server or connected client is not known to the receiving server or is not valid for the stream; the associated error type SHOULD be "modify".</t>
        </list></t>
      </section>
      <section title="Application-Specific Conditions" anchor="stanzas-error-app">
        <t>As noted, an application MAY provide application-specific stanza error information by including a properly-namespaced child in the error element.  The application-specific element SHOULD supplement or further qualify a defined element.  Thus, the &lt;error/&gt; element will contain two or three child elements:</t>
        <figure>
          <artwork><![CDATA[
<iq type='error' id='some-id'>
  <error type='modify'>
    <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    <too-many-parameters xmlns='application-ns'/>
  </error>
</iq>
          ]]></artwork>
        </figure>
        <figure>
          <artwork><![CDATA[
<message type='error' id='another-id'>
  <error type='modify'>
    <undefined-condition
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    <text xml:lang='en'
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>
      Some special application diagnostic information...
    </text>
    <special-application-condition xmlns='application-ns'/>
  </error>
</message>
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Extended Namespaces" anchor="stanzas-extended">
      <t>While the message, presence, and IQ stanza kinds provide basic semantics for messaging, availability, and request-response interactions, XMPP uses XML namespaces to extend the stanzas for the purpose of providing additional functionality.  Thus a message or presence stanza MAY contain one or more optional child elements specifying content that extends the meaning of the message (e.g., an XHTML-formatted version of the message body as described in <xref target="XEP-0071"/>), and an IQ stanza MAY contain one such child element.  This child element MAY have any name and MUST possess an 'xmlns' namespace declaration (other than "jabber:client", "jabber:server", or "http://etherx.jabber.org/streams") that defines all data contained within the child element.  Such a child element is said to be defined by an EXTENDED NAMESPACE.</t>
      <t>Support for any given extended namespace is OPTIONAL on the part of any implementation.  If an entity does not understand such a namespace, the entity's expected behavior depends on whether the entity is (1) the recipient or (2) an entity that is routing the stanza to the recipient:</t>
      <t><list style="hanging">
        <t hangText="Recipient:">If a recipient receives a stanza that contains a child element it does not understand, it SHOULD ignore that specific XML data, i.e., it SHOULD not process it or present it to a user or associated application (if any).  In particular:
          <list style='symbols'>
            <t>If an entity receives a message or presence stanza that contains XML data qualified by a namespace it does not understand, the portion of the stanza that is in the unknown namespace SHOULD be ignored.</t>
            <t>If an entity receives a message stanza whose only child element is qualified by a namespace it does not understand, it MUST ignore the entire stanza.</t>
            <t>If an entity receives an IQ stanza of type "get" or "set" containing a child element qualified by a namespace it does not understand, the entity SHOULD return an IQ stanza of type "error" with an error condition of &lt;service-unavailable/&gt;.</t>
          </list></t>
        <t hangText="Router:">If a routing entity (usually a server) handles a stanza that contains a child element it does not understand, it SHOULD ignore the associated XML data by passing it on untouched to the recipient.</t>
      </list></t>
    </section>

  </section>

  <section title="Examples" anchor="examples">
    <section title="Client-to-Server" anchor="examples-client">
      <t>The following examples show the data flow for a client negotiating an XML stream with a server, exchanging XML stanzas, and closing the negotiated stream.  The server is "example.com", the server requires use of TLS, the client authenticates via the SASL DIGEST-MD5 mechanism as "juliet@example.com", and the client binds the resource "balcony" to the stream.  (Note: The alternate steps shown below are provided to illustrate the protocol for failure cases; they are not exhaustive and would not necessarily be triggered by the data sent in the examples.)</t>
      <figure>
        <preamble>Step 1: Client initiates stream to server:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='juliet@example.com'
    to='example.com'
    version='1.0'>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 2: Server responds by sending a stream header to client:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='example.com'
    id='c2s_123'
    to='juliet@example.com'
    version='1.0'>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 3: Server sends stream features to client (STARTTLS extension and authentication mechanisms):</preamble>
        <artwork><![CDATA[
<stream:features>
  <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
    <required/>
  </starttls>
</stream:features>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 4: Client sends STARTTLS command to server:</preamble>
        <artwork><![CDATA[
<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 5: Server informs client that it is allowed to proceed:</preamble>
        <artwork><![CDATA[
<proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 5 (alt): Server informs client that TLS negotiation has failed and closes both XML stream and TCP connection:</preamble>
        <artwork><![CDATA[
<failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
</stream:stream>
        ]]></artwork>
      </figure>
      <t>Step 6: Client and server attempt to complete TLS negotiation over the existing TCP connection (see <xref target='TLS'/> for details).</t>
      <figure>
        <preamble>Step 7: If TLS negotiation is successful, client initiates a new stream to server:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='juliet@example.com'
    to='example.com'
    version='1.0'>
        ]]></artwork>
      </figure>
      <t>Step 7 (alt): If TLS negotiation is unsuccessful, server closes TCP connection.</t>
      <figure>
        <preamble>Step 8: Server responds by sending a stream header to client along with any available stream features (notice that the server now shows a different set of SASL mechanisms; here the server accepts the SASL PLAIN mechanism once the stream has been secured via TLS):</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='example.com'
    id='c2s_234'
    to='juliet@example.com'
    version='1.0'>
<stream:features>
  <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
    <mechanism>DIGEST-MD5</mechanism>
    <mechanism>PLAIN</mechanism>
    <required/>
  </mechanisms>
</stream:features>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 9: Client selects an authentication mechanism, in this case <xref target='DIGEST-MD5'/> with an empty authorization identity ("="):</preamble>
        <artwork><![CDATA[
<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
      mechanism='DIGEST-MD5'>=</auth>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 10: Server sends a <xref target="BASE64"/> encoded challenge to client:</preamble>
        <artwork><![CDATA[
<challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
cmVhbG09ImV4YW1wbGUuY29tIixub25jZT0iT0E2TUc5dEVRR20yaGgiLHFvcD0i
YXV0aCIsY2hhcnNldD11dGYtOCxhbGdvcml0aG09bWQ1LXNlc3MK
</challenge>]]></artwork>
      </figure>
      <t>The decoded challenge is:</t>
      <figure>
        <artwork><![CDATA[
realm="example.com",nonce="OA6MG9tEQGm2hh",
qop="auth",charset=utf-8,algorithm=md5-sess
        ]]></artwork>
      </figure>
      <t>Note: When the server sends a DIGEST-MD5 challenge to the client, the qop list must be quoted since it is a list rather than a single item (even if there is only one item in the list); however, when the client sends its response to the server (see below), the qop must not be quoted since it is a single item rather than a list.</t>
      <figure>
        <preamble>Step 10 (alt): Server returns error to client:</preamble>
        <artwork><![CDATA[
<failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
  <temporary-auth-failure/>
</failure>
</stream:stream>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 11: Client sends a <xref target="BASE64"/> encoded response to the challenge:</preamble>
        <artwork><![CDATA[
<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
dXNlcm5hbWU9Imp1bGlldCIscmVhbG09ImV4YW1wbGUuY29tIixub25jZT0iT0E2
TUc5dEVRR20yaGgiLGNub25jZT0iT0E2TUhYaDZWcVRyUmsiLG5jPTAwMDAwMDAx
LHFvcD1hdXRoLGRpZ2VzdC11cmk9InhtcHAvZXhhbXBsZS5jb20iLHJlc3BvbnNl
PWQzODhkYWQ5MGQ0YmJkNzYwYTE1MjMyMWYyMTQzYWY3LGNoYXJzZXQ9dXRmLTgK
</response>
        ]]></artwork>
      </figure>
      <t>The decoded response is:</t>
      <figure>
        <artwork><![CDATA[
username="juliet",realm="example.com",
nonce="OA6MG9tEQGm2hh",cnonce="OA6MHXh6VqTrRk",
nc=00000001,qop=auth,digest-uri="xmpp/example.com",
response=d388dad90d4bbd760a152321f2143af7,charset=utf-8
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 12: Server informs client of success and includes <xref target="BASE64"/> encoded value for subsequent authentication:</preamble>
        <artwork><![CDATA[
<success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
cnNwYXV0aD1lYTQwZjYwMzM1YzQyN2I1NTI3Yjg0ZGJhYmNkZmZmZAo=
</success>
        ]]></artwork>
      </figure>
      <t>The decoded value for subsequent authentication is:</t>
      <figure>
        <artwork><![CDATA[
rspauth=ea40f60335c427b5527b84dbabcdfffd
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 12 (alt): Server returns error to client:</preamble>
        <artwork><![CDATA[
<failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
  <temporary-auth-failure/>
</failure>
</stream:stream>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 13: Client initiates a new stream to server:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='juliet@example.com'
    to='example.com'
    version='1.0'>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 14: Server responds by sending a stream header to client along with supported features (in this case resource binding):</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    xml:lang='en'
    from='example.com'
    id='c2s_345'
    to='juliet@example.com'
    version='1.0'>
<stream:features>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <required/>
  </bind>
</stream:features>
        ]]></artwork>
      </figure>
      <t>Upon being so informed that resource binding is required, the client MUST bind a resource to the stream; here we assume that the client binds a resource called "balcony".</t>
      <figure>
        <preamble>Step 15: Client binds a resource:</preamble>
        <artwork><![CDATA[
<iq type='set' id='bind_1'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <resource>balcony</resource>
  </bind>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 16: Server informs client of successful resource binding:</preamble>
        <artwork><![CDATA[
<iq type='result'
    to='juliet@example.com/balcony'
    id='bind_1'>
  <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
    <jid>juliet@example.com/balcony</jid>
  </bind>
</iq>
        ]]></artwork>
      </figure>
      <t>Now the client is allowed to send XML stanzas over the negotiated stream.</t>
      <figure>
        <preamble>Client sends XML stanza to other entity:</preamble>
        <artwork><![CDATA[
<message from='juliet@example.com/balcony'
         to='romeo@example.net'
         xml:lang='en'>
    <body>Art thou not Romeo, and a Montague?</body>
</message>
        ]]></artwork>
      </figure>
      <t>If necessary, sender's server negotiates XML streams with intended recipient's server (see <xref target='examples-server'>Server-to-Server Examples</xref>).</t>
      <t>The intended recipient replies and the message is delivered to the client.</t>
      <figure>
        <preamble>Client receives XML stanza from other entity:</preamble>
        <artwork><![CDATA[
<message from='romeo@example.net/orchard'
         to='juliet@example.com/balcony'
         xml:lang='en'>
  <body>Neither, fair saint, if either thee dislike.</body>
</message>
        ]]></artwork>
      </figure>
      <t>Desiring to send no further messages, the client closes the stream.</t>
      <figure>
        <preamble>Client closes the stream:</preamble>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>Consistent with the recommended stream closing handshake, server closes stream as well:</t>
      <figure>
        <preamble>Server closes the stream:</preamble>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>Client now terminates the underlying TCP connection.</t>
    </section>
    <section title="Server-to-Server Examples" anchor="examples-server">
      <t>The following examples show the data flow for a server negotiating an XML stream with another server, exchanging XML stanzas, and closing the negotiated stream.  The initiating server ("Server1") is "example.com"; the receiving server ("Server2") is example.net and it requires use of TLS; example.com presents a certificate and authenticates via the SASL EXTERNAL mechanism.  (Note: The alternate steps shown below are provided to illustrate the protocol for failure cases; they are not exhaustive and would not necessarily be triggered by the data sent in the examples.)</t>
      <figure>
        <preamble>Step 1: Server1 initiates stream to Server2:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    to='example.net'
    version='1.0'>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 2: Server2 responds by sending a stream tag to Server1:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.net'
    id='s2s_123'
    to='example.com'
    version='1.0'>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 3: Server2 sends stream features to Server1 (STARTTLS extension and authentication mechanisms):</preamble>
        <artwork><![CDATA[
<stream:features>
  <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>
    <required/>
  </starttls>
</stream:features>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 4: Server1 sends the STARTTLS command to Server2:</preamble>
        <artwork><![CDATA[
<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 5: Server2 informs Server1 that it is allowed to proceed:</preamble>
        <artwork><![CDATA[
<proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 5 (alt): Server2 informs Server1 that TLS negotiation has failed and closes stream:</preamble>
        <artwork><![CDATA[
<failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
</stream:stream>
        ]]></artwork>
      </figure>
      <t>Step 6: Server1 and Server2 attempt to complete TLS negotiation via TCP.</t>
      <figure>
        <preamble>Step 7: If TLS negotiation is successful, Server1 initiates a new stream to Server2:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    to='example.net'
    version='1.0'>
        ]]></artwork>
      </figure>
      <t>Step 7 (alt): If TLS negotiation is unsuccessful, Server2 closes TCP connection.</t>
      <figure>
        <preamble>Step 8: Server2 responds by sending a stream header to Server1 along with available stream features (notice that Server2 now prefers the SASL EXTERNAL mechanism):</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.net'
    id='s2s_234'
    to='example.com'
    version='1.0'>
<stream:features>
  <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
    <mechanism>EXTERNAL</mechanism>
    <mechanism>DIGEST-MD5</mechanism>
    <required/>
  </mechanisms>
</stream:features>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 9: Server1 selects the EXTERNAL mechanism, in this case with an authorization identity encoded according to <xref target="BASE64"/>:</preamble>
        <artwork><![CDATA[
<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
      mechanism='EXTERNAL'/>ZXhhbXBsZS5jb20K</auth>
        ]]></artwork>
        <postamble>The decoded authorization identity is "example.com".</postamble>
      </figure>
      <figure>
        <preamble>Step 10: Server2 determines that the authorization identity provided by Server1 matches the valid id-xmppAddr-on or Common Name in the presented certificate and therefore returns success:</preamble>
        <artwork><![CDATA[
<success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 11 (alt): Server2 informs Server1 of failed authentication:</preamble>
        <artwork><![CDATA[
<failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
  <not-authorized/>
</failure>
</stream:stream>
        ]]></artwork>
       </figure>
      <figure>
        <preamble>Step 12: Server1 initiates a new stream to Server2:</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    to='example.net'
    version='1.0'>
        ]]></artwork>
      </figure>
      <figure>
        <preamble>Step 13: Server2 responds by sending a stream header to Server1 along with any additional features (or, in this case, an empty features element):</preamble>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.net'
    id='s2s_345'
    to='example.com'
    version='1.0'>
<stream:features/>
        ]]></artwork>
      </figure>
      <t>Now Server1 is allowed to send XML stanzas to Server2 over the negotiated stream; here we assume that the transferred stanzas are those shown earlier for client-to-server communications.</t>
      <figure>
        <preamble>Server1 sends XML stanza to Server2:</preamble>
        <artwork><![CDATA[
<message from='juliet@example.com/balcony'
         to='romeo@example.net'
         xml:lang='en'>
    <body>Art thou not Romeo, and a Montague?</body>
</message>
        ]]></artwork>
      </figure>
      <t>The intended recipient replies and the message is delivered from Server2 to Server1.</t>
      <figure>
        <preamble>Server2 sends XML stanza to Server1:</preamble>
        <artwork><![CDATA[
<message from='romeo@example.net/orchard'
         to='juliet@example.com/balcony'
         xml:lang='en'>
  <body>Neither, fair saint, if either thee dislike.</body>
</message>
        ]]></artwork>
      </figure>
      <t>Desiring to send no further messages, Server1 closes the stream.  (In practice, the stream would most likely remain open for some time, since Server1 and Server2 do not immediately know if the stream will be needed for further communications.)</t>
      <figure>
        <preamble>Server1 closes the stream:</preamble>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>Consistent with the recommended stream closing handshake, Server2 closes stream as well:</t>
      <figure>
        <preamble>Server2 closes the stream:</preamble>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>Server1 now terminates the underlying TCP connection.</t>
    </section>
  </section>

  <section title="Server Rules for Handling XML Stanzas" anchor="rules">
    <t>Compliant server implementations MUST ensure in-order processing of XML stanzas between any two entities.  This includes stanzas sent by a client to its server for direct processing by the server.</t>
    <t>Beyond the requirement for in-order processing, each server implementation will contain its own "delivery tree" for handling stanzas it receives.  Such a tree determines whether a stanza needs to be routed to another domain, processed direct, or delivered to a resource associated with a connected node.  The following rules apply.</t>
    <section title="No 'to' Address" anchor="rules-noto">
      <t>If the stanza possesses no 'to' attribute, the server SHOULD process it directly on behalf of the entity that sent it.  Because all stanzas received from other servers MUST possess a 'to' attribute, this rule applies only to stanzas received from a registered entity (such as a client) that is connected to the server.  If the server receives a presence stanza with no 'to' attribute, the server SHOULD broadcast it to the entities that are subscribed to the sending entity's presence, if applicable (the semantics of presence broadcast for presence applications are defined in <xref target="XMPP-IM"/>).  If the server receives an IQ stanza of type "get" or "set" with no 'to' attribute and it understands the namespace that qualifies the content of the stanza, it MUST either process the stanza directly on behalf of sending entity (where the meaning of "process" is determined by the semantics of the qualifying namespace) or return an error to the sending entity.</t>
    </section>
    <section title="Foreign Domain" anchor="rules-foreign">
      <t>If the hostname of the domain identifier portion of the JID contained in the 'to' attribute does not match one of the configured hostnames of the server itself or a configured subdomain thereof, the server SHOULD route the stanza to the foreign domain (subject to local service provisioning and security policies regarding inter-domain communication, since such communication is OPTIONAL).  There are two possible cases:</t>
      <t><list style='hanging'>
        <t hangText='A server-to-server stream already exists between the two domains:'>The sender's server routes the stanza to the authoritative server for the foreign domain over the existing stream</t>
        <t hangText='There exists no server-to-server stream between the two domains:'>The sender's server (1) resolves the hostname of the foreign domain (as defined under <xref target="security-server">Server-to-Server Communications</xref>), (2) negotiates a server-to-server stream between the two domains (as defined under <xref target='tls'>TLS negotiation</xref> and <xref target='sasl'>SASL negotiation</xref>), and (3) routes the stanza to the authoritative server for the foreign domain over the newly-established stream</t>
      </list></t>
      <t>If routing to the recipient's server is unsuccessful, the sender's server MUST return an error to the sender; if the recipient's server can be contacted but delivery by the recipient's server to the recipient is unsuccessful, the recipient's server MUST return an error to the sender by way of the sender's server.</t>
    </section>
    <section title="Subdomain" anchor="rules-subdomain">
      <t>If the hostname of the domain identifier portion of the JID contained in the 'to' attribute matches a subdomain of one of the configured hostnames of the server itself, the server MUST either process the stanza itself or route the stanza to a specialized service that is responsible for that subdomain (if the subdomain is configured), or return an error to the sender (if the subdomain is not configured).</t>
    </section>
    <section title="Mere Domain or Specific Resource" anchor="rules-domain">
      <t>If the hostname of the domain identifier portion of the JID contained in the 'to' attribute matches a configured hostname of the server itself and the JID contained in the 'to' attribute is of the form &lt;domain&gt; or &lt;domain/resource&gt;, the server (or a defined resource thereof) MUST either process the stanza as appropriate for the stanza kind or return an error stanza to the sender.</t>
    </section>
    <section title="Node in Same Domain" anchor="rules-node">
      <t>If the hostname of the domain identifier portion of the JID contained in the 'to' attribute matches a configured hostname of the server itself and the JID contained in the 'to' attribute is of the form &lt;node@domain&gt; or &lt;node@domain/resource&gt;, the server SHOULD deliver the stanza to the intended recipient of the stanza as represented by the JID contained in the 'to' attribute.  The following rules apply:</t>
      <t><list style="numbers">
        <t>If the JID contains a resource identifier (i.e., is of the form &lt;node@domain/resource&gt;) and there exists a connected resource that exactly matches the full JID, the recipient's server SHOULD deliver the stanza to the stream or connection that exactly matches the resource identifier.</t>
        <t>If the JID contains a resource identifier and there exists no connected resource that exactly matches the full JID, the recipient's server SHOULD return a &lt;service-unavailable/&gt; stanza error to the sender.</t>
        <t>If the JID is of the form &lt;node@domain&gt; and there exists at least one connected resource for the node, the recipient's server SHOULD deliver the stanza to at least one of the connected resources, according to application-specific rules.</t>
      </list></t>
      <t>Particular XMPP applications MAY specify delivery rules that modify or supplement the foregoing rules; for example, a set of delivery rules for instant messaging and presence applications is defined in <xref target="XMPP-IM"/>.</t>
    </section>
  </section>

  <section title="XML Usage" anchor="xml">

    <section title="Restrictions" anchor="xml-restrictions">
      <t>XMPP is a simplified and specialized protocol for streaming XML elements in order to exchange structured information in close to real time.  Because XMPP does not require the parsing of arbitrary and complete XML documents, there is no requirement that XMPP needs to support the full feature set of <xref target="XML"/>.  In particular, the following restrictions apply.</t>
      <t>With regard to XML generation, an XMPP implementation MUST NOT inject into an XML stream any of the following:</t>
      <t><list style='symbols'>
        <t>comments (as defined in Section 2.5 of <xref target="XML"/>)</t>
        <t>processing instructions (Section 2.6 therein)</t>
        <t>internal or external DTD subsets (Section 2.8 therein)</t>
        <t>internal or external entity references (Section 4.2 therein) with the exception of predefined entities (Section 4.6 therein)</t>
        <t>character data or attribute values containing unescaped characters that map to the predefined entities (Section 4.6 therein); such characters MUST be escaped</t>
      </list></t>
      <t>With regard to XML processing, if an XMPP implementation receives such restricted XML data, it MUST return a &lt;restricted-xml/&gt; stream error.</t>
    </section>

    <section title="XML Namespace Names and Prefixes" anchor="xml-ns">
      <t>XML namespaces (see <xref target="XML-NAMES"/>) are used within all XMPP-compliant XML to create strict boundaries of data ownership.  The basic function of namespaces is to separate different vocabularies of XML elements that are structurally mixed together.  Ensuring that XMPP-compliant XML is namespace-aware enables any allowable XML to be structurally mixed with any data element within XMPP.  Rules for XML namespace names and prefixes are defined in the following subsections.</t>
      <section title="Streams Namespace" anchor="xml-ns-stream">
        <t>A streams namespace declaration is REQUIRED in all XML stream headers.  The name of the streams namespace MUST be 'http://etherx.jabber.org/streams'.  The element names of the &lt;stream/&gt; element and its &lt;features/&gt; and &lt;error/&gt; children MUST be qualified by the streams namespace prefix in all instances.  An implementation SHOULD generate only the 'stream:' prefix for these elements, and for historical reasons MAY accept only the 'stream:' prefix.</t>
      </section>
      <section title="Default Namespace" anchor="xml-ns-default">
        <t>A default namespace declaration is REQUIRED and is used in all XML streams in order to define the allowable first-level children of the root stream element.  This namespace declaration MUST be the same for the initial stream and the response stream so that both streams are qualified consistently.  The default namespace declaration applies to the stream and all stanzas sent within a stream (unless explicitly qualified by another namespace, or by the prefix of the streams namespace or the dialback namespace).</t>
        <t>A server implementation MUST support the following two default namespaces (for historical reasons, some implementations MAY support only these two default namespaces):</t>
        <t><list style="symbols">
          <t>jabber:client -- this default namespace is declared when the stream is used for communications between a client and a server</t>
          <t>jabber:server -- this default namespace is declared when the stream is used for communications between two servers</t>
        </list></t>
        <t>A client implementation MUST support the 'jabber:client' default namespace, and for historical reasons MAY support only that default namespace.</t>
        <t>An implementation MUST NOT generate namespace prefixes for elements qualified by the default namespace if the default namespace is 'jabber:client' or 'jabber:server'.  An implementation SHOULD NOT generate namespace prefixes for elements qualified by content (as opposed to stream) namespaces other than 'jabber:client' and 'jabber:server'.</t>
        <t>Note: The 'jabber:client' and 'jabber:server' namespaces are nearly identical but are used in different contexts (client-to-server communications for 'jabber:client' and server-to-server communications for 'jabber:server').  The only difference between the two is that the 'to' and 'from' attributes are OPTIONAL on stanzas sent within 'jabber:client', whereas they are REQUIRED on stanzas sent within 'jabber:server'.  If a compliant implementation accepts a stream that is qualified by the 'jabber:client' or 'jabber:server' namespace, it MUST support the <xref target="stanzas-attributes">common attributes</xref> and <xref target="stanzas-semantics">basic semantics</xref> of all three core stanza kinds (message, presence, and IQ).</t>
      </section>
      <section title="Dialback Namespace" anchor="xml-ns-db">
        <t>A dialback namespace declaration is REQUIRED for all elements used in <xref target="dialback">server dialback</xref>.  The name of the dialback namespace MUST be 'jabber:server:dialback'.  All elements qualified by this namespace MUST be prefixed.  An implementation SHOULD generate only the 'db:' prefix for such elements and MAY accept only the 'db:' prefix.</t>
      </section>
    </section>

    <section title="Validation" anchor="xml-validation">
      <t>A server is not responsible for validating the XML elements forwarded to a client or another server; an implementation MAY choose to provide only validated data elements but this is OPTIONAL (although an implementation MUST NOT accept XML that is not well-formed).  Clients SHOULD NOT rely on the ability to send data which does not conform to the schemas, and SHOULD ignore any non-conformant elements or attributes on the incoming XML stream.  Validation of XML streams and stanzas is OPTIONAL, and schemas are included herein for descriptive purposes only.</t>
    </section>

    <section title="Inclusion of Text Declaration" anchor="xml-declaration">
      <t>Implementations SHOULD send a text declaration before sending a stream header.  Applications MUST follow the rules in <xref target="XML"/> regarding the circumstances under which a text declaration is included.</t>
    </section>

    <section title="Character Encoding" anchor="xml-encoding">
      <t>Implementations MUST support the <xref target="UTF-8"/> transformation of Universal Character Set (<xref target="UCS2"/>) characters, as required by <xref target="CHARSET"/>.  Implementations MUST NOT attempt to use any other encoding.</t>
    </section>

    <section title="White Space" anchor="xml-whitespace">
      <t>Except where explicitly disallowed (i.e., during <xref target='tls'>TLS negotiation</xref> and <xref target='SASL'>SASL negotiation</xref>), either entity MAY send white space characters (matching production [3] content of <xref target="XML"/>) within the root stream element as separators between XML stanzas or between any other first-level elements sent over the stream; one common use for sending such white space characters is to check the viability of the underlying TCP connection after a period of inactivity.</t>
    </section>

  </section>

  <section title="Compliance Requirements" anchor="compliance">
    <t>This section summarizes the specific aspects of the Extensible Messaging and Presence Protocol that MUST be supported by servers and clients in order to be considered compliant implementations, as well as additional protocol aspects that SHOULD be supported.  For compliance purposes, we draw a distinction between core protocols (which MUST be supported by any server or client, regardless of the specific application) and instant messaging and presence protocols (which MUST be supported only by instant messaging and presence applications built on top of the core protocols).  Compliance requirements that apply to all servers and clients are specified in this section; compliance requirements for instant messaging and presence applications are specified in the corresponding section of <xref target="XMPP-IM"/>.</t>
    <section title="Servers" anchor="compliance-server">
      <t>In addition to all defined requirements with regard to security, XML usage, and internationalization, a server MUST support the following core protocols in order to be considered compliant:</t>
      <t><list style='symbols'>
        <t>Application of the <xref target="NAMEPREP"/>, <xref target='nodeprep'>Nodeprep</xref>, and <xref target='resourceprep'>Resourceprep</xref> profiles of <xref target="STRINGPREP"/> to addresses (including ensuring that domain identifiers are internationalized domain names as defined in <xref target="IDNA"/>)</t>
        <t><xref target='streams'>XML streams</xref>, including <xref target='tls'>TLS negotiation</xref>, <xref target='sasl'>SASL negotiation</xref>, and <xref target="bind">Resource Binding</xref></t>
        <t>The basic semantics of the three defined stanza kinds (i.e., &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;) as specified in <xref target="stanzas-semantics">stanza semantics</xref></t>
        <t>Generation (and, where appropriate, handling) of error syntax and semantics related to streams, TLS, SASL, and XML stanzas</t>
      </list></t>
      <t>In addition, for historical reasons a server SHOULD support the following core protocol:</t>
      <t><list style='symbols'>
        <t><xref target='dialback'>Server dialback</xref></t>
      </list></t>
    </section>
    <section title="Clients" anchor="compliance-client">
      <t>A client MUST support the following core protocols in order to be considered compliant:</t>
      <t><list style='symbols'>
        <t><xref target='streams'>XML streams</xref>, including <xref target='tls'>TLS negotiation</xref>, <xref target='sasl'>SASL negotiation</xref>, and <xref target="bind">Resource Binding</xref></t>
        <t>The basic semantics of the three defined stanza kinds (i.e., &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;) as specified in <xref target="stanzas-semantics">stanza semantics</xref></t>
        <t>Handling (and, where appropriate, generation) of error syntax and semantics related to streams, TLS, SASL, and XML stanzas</t>
      </list></t>
      <t>In addition, a client SHOULD support the following core protocols:</t>
      <t><list style='symbols'>
        <t>Generation of addresses to which the <xref target="NAMEPREP"/>, <xref target='nodeprep'>Nodeprep</xref>, and <xref target='resourceprep'>Resourceprep</xref> profiles of <xref target="STRINGPREP"/> can be applied without failing</t>
      </list></t>
    </section>
  </section>

  <section title="Internationalization Considerations" anchor="i18n">
    <t>XML streams MUST be encoded in UTF-8 as specified under <xref target="xml-encoding">Character Encoding</xref>.  As specified under <xref target="streams-attr">Stream Attributes</xref>, an XML stream SHOULD include an 'xml:lang' attribute specifying the default language for any XML character data sent over the stream that is intended to be presented to a human user.  As specified under <xref target="stanzas-attributes-lang">xml:lang</xref>, an XML stanza SHOULD include an 'xml:lang' attribute if the stanza contains XML character data that is intended to be presented to a human user.  A server SHOULD apply the default 'xml:lang' attribute to stanzas it routes or delivers on behalf of connected entities, and MUST NOT modify or delete 'xml:lang' attributes stanzas it receives from other entities.</t>
  </section>

  <section title="Security Considerations" anchor="security">
    <section title="High Security" anchor="security-high">
      <t>For the purposes of XMPP communications (client-to-server and server-to-server), the term "high security" refers to the use of security technologies that provide both mutual authentication and integrity-checking; in particular, when using certificate-based authentication to provide high security, a chain-of-trust SHOULD be established out-of-band, although a shared certificate authority signing certificates could allow a previously unknown certificate to establish trust in-band.  See <xref target="security-validation"/> below regarding certificate validation procedures.</t>
      <t>Implementations MUST support high security.  Service provisioning SHOULD use high security, subject to local security policies.</t>
    </section>
    <section title="Certificate Validation" anchor="security-validation">
      <t>When an XMPP peer communicates with another peer securely, it MUST validate the peer's certificate.  There are three possible cases:</t>
      <t><list style='hanging'>
        <t hangText='Case #1:'>The peer contains an End Entity certificate which appears to be certified by a chain of certificates terminating in a trust anchor (as described in Section 6.1 of <xref target="X509"/>).</t>
        <t hangText='Case #2:'>The peer certificate is certified by a Certificate Authority not known to the validating peer.</t>
        <t hangText='Case #3:'>The peer certificate is self-signed.</t>
      </list></t>
      <t>In Case #1, the validating peer MUST do one of two things:
        <list style="numbers">
          <t>Verify the peer certificate according to the rules of <xref target="X509"/>.  The certificate SHOULD then be checked against the expected identity of the peer following the rules described in <xref target="HTTP-TLS"/>, except that if present an <xref target="ASN.1"/> Object Identifier of "id-on-xmppAddr" (represented as a UTF8String in an otherName entity inside the subjectAltName) MUST be used as the identity.  If one of these checks fails, user-oriented clients MUST either notify the user (clients MAY give the user the opportunity to continue with the connection in any case) or terminate the connection with a bad certificate error.  Automated clients SHOULD terminate the connection (with a bad certificate error) and log the error to an appropriate audit log.  Automated clients MAY provide a configuration setting that disables this check, but MUST provide a setting that enables it.</t>
          <t>The peer SHOULD show the certificate to a user for approval, including the entire certificate chain.  The peer MUST cache the certificate (or some non-forgeable representation such as a hash).  In future connections, the peer MUST verify that the same certificate was presented and MUST notify the user if it has changed.</t>
        </list>
      </t>
      <t>In Case #2 and Case #3, implementations SHOULD act as in (2) above.</t>
    </section>
    <section title="Client-to-Server Communications" anchor="security-client">
      <t>A compliant client implementation MUST support both TLS and SASL for connections to a server.</t>
      <t>The TLS protocol for encrypting XML streams (defined under <xref target='tls'>TLS negotiation</xref>) provides a reliable mechanism for helping to ensure the confidentiality and data integrity of data exchanged between two entities.</t>
      <t>The SASL protocol for authenticating XML streams (defined under <xref target='sasl'>SASL negotiation</xref>) provides a reliable mechanism for validating that a client connecting to a server is who it claims to be.</t>
      <t>Client-to-server communications MUST NOT proceed until the DNS hostname asserted by the server has been resolved as specified under <xref target='tcp'>TCP Binding</xref>.  If there is a mismatch between the hostname to which a client attempted to connect (e.g., "example.net") and the hostname to which the client actually connects (e.g., "im.example.net"), the client MUST warn a human user about the mismatch and the human user MUST approve the connection before the client proceeds; however, the client MAY allow the user to add the presented hostname to a configured set of accepted hostnames in order to expedite future connections.</t>
      <t>The IP address and method of access of clients MUST NOT be made public by a server, nor are any connections other than the original server connection required.  This helps to protect the client's server from direct attack or identification by third parties.</t>
    </section>
    <section title="Server-to-Server Communications" anchor="security-server">
      <t>A compliant server implementation MUST support both TLS and SASL for inter-domain communications.  For historical reasons, a compliant implementation SHOULD also support <xref target="dialback">Server Dialback</xref>.</t>
      <t>Because service provisioning is a matter of policy, it is OPTIONAL for any given domain to communicate with other domains, and server-to-server communications MAY be disabled by the administrator of any given deployment.  If a particular domain enables inter-domain communications, it SHOULD enable high security.</t>
      <t>Administrators may want to require use of SASL for server-to-server communications in order to ensure both authentication and confidentiality (e.g., on an organization's private network).  Compliant implementations SHOULD support SASL for this purpose.</t>
      <t>Server-to-server communications MUST NOT proceed until the DNS hostnames asserted by both servers have been resolved as specified under <xref target='tcp'>TCP Binding</xref>.</t>
      <t>Server dialback helps protect against domain spoofing, thus making it more difficult to spoof XML stanzas.  It is not a mechanism for authenticating, securing, or encrypting streams between servers as is done via SASL and TLS, and results in weak verification of server identities only.  Furthermore, it is susceptible to DNS poisoning attacks unless <xref target="DNSSEC"/> is used, and even if the DNS information is accurate, dialback cannot protect from attacks where the attacker is capable of hijacking the IP address of the remote domain.  Domains requiring robust security SHOULD use TLS and SASL.  If SASL is used for server-to-server authentication, dialback SHOULD NOT be used since it is unnecessary.</t>
    </section>
    <section title="Order of Layers" anchor="security-layers">
      <t>The order of layers in which protocols MUST be stacked is as follows:</t>
      <t><list style="numbers">
        <t>TCP</t>
        <t>TLS</t>
        <t>SASL</t>
        <t>XMPP</t>
      </list></t>
      <t>The rationale for this order is that <xref target="TCP"/> is the base connection layer used by all of the protocols stacked on top of TCP, <xref target="TLS"/> is often provided at the operating system layer, <xref target="SASL"/> is often provided at the application layer, and XMPP is the application itself.</t>
    </section>
    <section title="Lack of SASL Channel Binding to TLS" anchor="security-channel">
      <t>The SASL framework does not provide a mechanism to bind SASL authentication to a security layer providing confidentiality and integrity protection that was negotiated at a lower layer.  This lack of a "channel binding" prevents SASL from being able to verify that the source and destination end points to which the lower layer's security is bound are equivalent to the end points that SASL is authenticating.  If the end points are not identical, the lower layer's security cannot be trusted to protect data transmitted between the SASL authenticated entities.  In such a situation, a SASL security layer should be negotiated that effectively ignores the presence of the lower layer security.</t>
    </section>
    <section title="Mandatory-to-Implement Technologies" anchor="security-mandatory">
      <t>At a minimum, all implementations MUST support the following mechanisms:</t>
      <t><list style='hanging'>
        <t hangText='for authentication:'>the SASL <xref target="DIGEST-MD5"/> mechanism</t>
        <t hangText='for confidentiality:'>TLS (using the TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher)</t>
        <t hangText='for both:'>TLS plus SASL PLAIN for client-to-server connections and TLS plus SASL EXTERNAL for server-to-server connections (using the TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher supporting peer certificates)</t>
      </list></t>
      <t>Naturally, implementations MAY support other ciphers with TLS and MAY support other SASL mechanisms.</t>
    </section>
    <section title="Firewalls" anchor="security-firewalls">
      <t>Communications using XMPP normally occur over <xref target="TCP"/> connections on port 5222 (client-to-server) or port 5269 (server-to-server), as registered with the IANA (see <xref target="iana">IANA Considerations</xref>).  Use of these well-known ports allows administrators to easily enable or disable XMPP activity through existing and commonly-deployed firewalls.</t>
    </section>
    <section title="Use of base64 in SASL" anchor="security-base64">
      <t>Both the client and the server MUST verify any <xref target="BASE64"/> data received during SASL negotiation.  An implementation MUST reject (not ignore) any characters that are not explicitly allowed by the base64 alphabet; this helps to guard against creation of a covert channel that could be used to "leak" information.  An implementation MUST NOT break on invalid input and MUST reject any sequence of base64 characters containing the pad ('=') character if that character is included as something other than the last character of the data (e.g., "=AAA" or "BBBB=CCC"); this helps to guard against buffer overflow attacks and other attacks on the implementation.  Base 64 encoding visually hides otherwise easily recognized information, such as passwords, but does not provide any computational confidentiality.  Base 64 encoding MUST follow the definition in Section 3 of <xref target="BASE64"/>.</t>
    </section>
    <section title="Stringprep Profiles" anchor="security-stringprep">
      <t>XMPP makes use of the <xref target="NAMEPREP"/> profile of <xref target="STRINGPREP"/> for processing of domain identifiers; for security considerations related to Nameprep, refer to the appropriate section of <xref target="NAMEPREP"/>.</t>
      <t>In addition, XMPP defines two profiles of <xref target="STRINGPREP"/>: <xref target="nodeprep">Nodeprep</xref> for node identifiers and <xref target="resourceprep">Resourceprep</xref> for resource identifiers.</t>
      <t>The Unicode and ISO/IEC 10646 repertoires have many characters that look similar.  In many cases, users of security protocols might do visual matching, such as when comparing the names of trusted third parties.  Because it is impossible to map similar-looking characters without a great deal of context, such as knowing the fonts used, stringprep does nothing to map similar-looking characters together, nor to prohibit some characters because they look like others.</t>
      <t>A node identifier can be employed as one part of an entity's address in XMPP.  One common usage is as the username of an instant messaging user; another is as the name of a multi-user chat room; many other kinds of entities could use node identifiers as part of their addresses.  The security of such services could be compromised based on different interpretations of the internationalized node identifier; for example, a user entering a single internationalized node identifier could access another user's account information, or a user could gain access to an otherwise restricted chat room or service.</t>
      <t>A resource identifier can be employed as one part of an entity's address in XMPP.  One common usage is as the name for an instant messaging user's connected resource; another is as the nickname of a user in a multi-user chat room; many other kinds of entities could use resource identifiers as part of their addresses.  The security of such services could be compromised based on different interpretations of the internationalized resource identifier; for example, a user could attempt to initiate multiple connections with the same name, or a user could send a message to someone other than the intended recipient in a multi-user chat room.</t>
    </section>
  </section>

  <section title="IANA Considerations" anchor="iana">
    <section title="XML Namespace Name for TLS Data" anchor="iana-ns-tls">
      <t>A URN sub-namespace for TLS-related data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG">The IETF XML Registry</xref>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-tls</t>
        <t hangText='Specification:'>RFC 3920</t>
        <t hangText='Description:'>This is the XML namespace name for TLS-related data in the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3920.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for SASL Data" anchor="iana-ns-sasl">
      <t>A URN sub-namespace for SASL-related data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-sasl</t>
        <t hangText='Specification:'>RFC 3920</t>
        <t hangText='Description:'>This is the XML namespace name for SASL-related data in the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3920.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for Stream Errors" anchor="iana-ns-streams">
      <t>A URN sub-namespace for stream-related error data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-streams</t>
        <t hangText='Specification:'>RFC 3920</t>
        <t hangText='Description:'>This is the XML namespace name for stream-related error data in the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3920.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for Resource Binding" anchor="iana-ns-bind">
      <t>A URN sub-namespace for resource binding in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-bind</t>
        <t hangText='Specification:'>RFC 3920</t>
        <t hangText='Description:'>This is the XML namespace name for resource binding in the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3920.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title="XML Namespace Name for Stanza Errors" anchor="iana-ns-stanzas">
      <t>A URN sub-namespace for stanza-related error data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows.  (This namespace name adheres to the format defined in <xref target="XML-REG"/>.)</t>
      <t><list style='hanging'>
        <t hangText='URI:'>urn:ietf:params:xml:ns:xmpp-stanzas</t>
        <t hangText='Specification:'>RFC 3920</t>
        <t hangText='Description:'>This is the XML namespace name for stanza-related error data in the Extensible Messaging and Presence Protocol (XMPP) as defined by RFC 3920.</t>
        <t hangText='Registrant Contact:'>IETF, XMPP Working Group, &lt;xmppwg@xmpp.org&gt;</t>
      </list></t>
    </section>
    <section title='Nodeprep Profile of Stringprep' anchor="iana-nodeprep">
      <t>The Nodeprep profile of stringprep is defined under <xref target="nodeprep">Nodeprep</xref>.  The IANA has registered Nodeprep in the stringprep profile registry.</t>
      <t>Name of this profile:</t>
      <t><list style='hanging'>
        <t>Nodeprep</t>
      </list></t>
      <t>RFC in which the profile is defined:</t>
      <t><list style='hanging'>
        <t>RFC 3920</t>
      </list></t>
      <t>Indicator whether or not this is the newest version of the profile:</t>
      <t><list style='hanging'>
        <t>This is the first version of Nodeprep</t>
      </list></t>
    </section>
    <section title='Resourceprep Profile of Stringprep' anchor="iana-resourceprep">
      <t>The Resourceprep profile of stringprep is defined under <xref target="resourceprep">Resourceprep</xref>.  The IANA has registered Resourceprep in the stringprep profile registry.</t>
      <t>Name of this profile:</t>
      <t><list style='hanging'>
        <t>Resourceprep</t>
      </list></t>
      <t>RFC in which the profile is defined:</t>
      <t><list style='hanging'>
        <t>RFC 3920</t>
      </list></t>
      <t>Indicator whether or not this is the newest version of the profile:</t>
      <t><list style='hanging'>
        <t>This is the first version of Resourceprep</t>
      </list></t>
    </section>
    <section title="GSSAPI Service Name" anchor="iana-gssapi">
      <t>The IANA has registered "xmpp" as a <xref target="GSS-API">GSSAPI</xref> service name, as defined under <xref target="sasl-def">SASL Definition</xref>.</t>
    </section>
    <section title="Port Numbers" anchor="iana-ports">
      <t>The IANA has registered "xmpp-client" and "xmpp-server" as keywords for <xref target="TCP"/> ports 5222 and 5269 respectively.</t>
      <t>These ports SHOULD be used for client-to-server and server-to-server communications respectively, but their use is OPTIONAL.</t>
    </section>
  </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor='ABNF'>
<front>
<title abbrev='ABNF for Syntax Specifications'>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.H.' surname='Crocker' fullname='David H.  Crocker'>
<organization>Internet Mail Consortium</organization>
<address>
<postal>
<street>675 Spruce Dr.</street>
<city>Sunnyvale</city>
<region>CA</region>
<code>94086</code>
<country>US</country></postal>
<phone>+1 408 246 8253</phone>
<facsimile>+1 408 249 6205</facsimile>
<email>dcrocker@bbiw.net</email></address></author>
<author initials='P.' surname='Overell' fullname='Paul Overell'>
<organization>THUS plc.</organization>
<address>
<postal>
<street>1/3 Berkeley Square</street>
<street>99 Berkeley Street</street>
<city>Glasgow</city>
<code>G3 7HR</code>
<country>UK</country></postal>
<email>paulo@turnpike.com</email></address></author>
<date month='October' year='2005' /></front>
<seriesInfo name='RFC' value='4234' />
<format type='TXT' octets='26351' target='ftp://ftp.isi.edu/in-notes/rfc4234.txt' />
</reference>

<reference anchor="BASE64">
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S.  Josefsson'>
<organization /></author>
<date month='July' year='2003' /></front>
<seriesInfo name='RFC' value='3548' />
<format type='TXT' octets='26363' target='ftp://ftp.isi.edu/in-notes/rfc3548.txt' />
</reference>

<reference anchor="CHARSET">
<front>
<title abbrev='Charset Policy'>IETF Policy on Character Sets and Languages</title>
<author initials='H.T.' surname='Alvestrand' fullname='Harald Tveit Alvestrand'>
<organization>UNINETT</organization>
<address>
<postal>
<street>P.O.Box 6883 Elgeseter</street>
<street>N-7002 TRONDHEIM</street>
<country>NORWAY</country></postal>
<phone>+47 73 59 70 94</phone>
<email>Harald.T.Alvestrand@uninett.no</email></address></author>
<date month='January' year='1998' />
<area>Applications</area>
<keyword>Internet Engineering Task Force</keyword>
<keyword>character encoding</keyword></front>
<seriesInfo name='BCP' value='18' />
<seriesInfo name='RFC' value='2277' />
<format type='TXT' octets='16622' target='ftp://ftp.isi.edu/in-notes/rfc2277.txt' />
<format type='HTML' octets='26556' target='http://xml.resource.org/public/rfc/html/rfc2277.html' />
<format type='XML' octets='15544' target='http://xml.resource.org/public/rfc/xml/rfc2277.xml' />
</reference>

<reference anchor='DIGEST-MD5'>
<front>
<title>Using Digest Authentication as a SASL Mechanism</title>
<author initials='P.' surname='Leach' fullname='P. Leach'>
<organization /></author>
<author initials='C.' surname='Newman' fullname='C. Newman'>
<organization /></author>
<date month='May' year='2000' /></front>
<seriesInfo name='RFC' value='2831' />
<format type='TXT' octets='58124' target='ftp://ftp.isi.edu/in-notes/rfc2831.txt' />
</reference>

<reference anchor='DNS-SRV'>
<front>
<title abbrev='DNS SRV RR'>A DNS RR for specifying the location of services (DNS SRV)</title>
<author initials='A.' surname='Gulbrandsen' fullname='Arnt Gulbrandsen'>
<organization>Troll Tech</organization>
<address>
<postal>
<street>Waldemar Thranes gate 98B</street>
<city>Oslo</city>
<region />
<code>N-0175</code>
<country>NO</country></postal>
<phone>+47 22 806390</phone>
<facsimile>+47 22 806380</facsimile>
<email>arnt@troll.no</email></address></author>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>950 Charter Street</street>
<city>Redwood City</city>
<region>CA</region>
<code>94063</code>
<country>US</country></postal>
<phone>+1 650 779 7001</phone></address></author>
<author initials='L.' surname='Esibov' fullname='Levon Esibov'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>levone@microsoft.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>This document describes a DNS RR which specifies the location of the
   server(s) for a specific protocol and domain.</t></abstract></front>
<seriesInfo name='RFC' value='2782' />
<format type='TXT' octets='24013' target='ftp://ftp.isi.edu/in-notes/rfc2782.txt' />
</reference>

<reference anchor='DNS'>
<front>
<title abbrev='Domain Implementation and Specification'>Domain names - implementation and specification</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>USC/ISI</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal>
<phone>+1 213 822 1511</phone></address></author>
<date month='November' day='1' year='1987' /></front>
<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1035' />
<format type='TXT' octets='125626' target='ftp://ftp.isi.edu/in-notes/rfc1035.txt' />
</reference>

<reference anchor='GSS-API'>
<front>
<title abbrev='GSS-API'>Generic Security Service Application Program Interface Version 2, Update 1</title>
<author initials='J.' surname='Linn' fullname='John Linn'>
<organization>RSA Laboratories</organization>
<address>
<postal>
<street>20 Crosby Drive</street>
<city>Bedford</city>
<region>MA</region>
<code>01730</code>
<country>US</country></postal>
<phone>+1 781 687 7817</phone>
<email>jlinn@rsasecurity.com</email></address></author>
<date year='2000' month='January' />
<abstract>
<t>The Generic Security Service Application Program Interface (GSS-API), Version 2, as defined in, provides security services to callers in a generic fashion, supportable with a range of underlying mechanisms and technologies and hence allowing source-level portability of applications to different environments. This specification defines GSS-API services and primitives at a level independent of underlying mechanism and programming language environment, and is to be complemented by other, related specifications:</t>
<t>documents defining specific parameter bindings for particular language environments</t>
<t>documents defining token formats, protocols, and procedures to be implemented in order to realize GSS-API services atop particular security mechanisms</t>
<t>This memo obsoletesmaking specific, incremental changes in response to implementation experience and liaison requests. It is intended, therefore, that this memo or a successor version thereto will become the basis for subsequent progression of the GSS-API specification on the standards track.</t></abstract></front>
<seriesInfo name='RFC' value='2743' />
<format type='TXT' octets='229418' target='ftp://ftp.isi.edu/in-notes/rfc2743.txt' />
</reference>

<reference anchor="HMAC" target="http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf">
<front>
<title>The Keyed-Hash Message Authentication Code (HMAC)</title>
<author>
<organization>National Institute of Standards and Technology</organization>
</author>
<date month="March" year="2002" />
</front>
<seriesInfo name="FIPS" value="PUB 198" />
</reference>

<reference anchor='HTTP-TLS'>
<front>
<title>HTTP Over TLS</title>
<author initials='E.' surname='Rescorla' fullname='E.  Rescorla'>
<organization /></author>
<date month='May' year='2000' /></front>
<seriesInfo name='RFC' value='2818' />
<format type='TXT' octets='15170' target='ftp://ftp.isi.edu/in-notes/rfc2818.txt' />
</reference>

<reference anchor='IDNA'>
<front>
<title>Internationalizing Domain Names in Applications (IDNA)</title>
<author initials='P.' surname='Faltstrom' fullname='P. Faltstrom'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='A.' surname='Costello' fullname='A. Costello'>
<organization /></author>
<date month='March' year='2003' /></front>
<seriesInfo name='RFC' value='3490' />
<format type='TXT' octets='51943' target='ftp://ftp.isi.edu/in-notes/rfc3490.txt' />
</reference>

<reference anchor='IPv6'>
<front>
<title>Internet Protocol Version 6 (IPv6) Addressing Architecture</title>
<author initials='R.' surname='Hinden' fullname='R. Hinden'>
<organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'>
<organization /></author>
<date year='2003' month='April' /></front>
<seriesInfo name='RFC' value='3513' />
<format type='TXT' octets='53920' target='ftp://ftp.isi.edu/in-notes/rfc3513.txt' />
</reference>

<reference anchor="LANGTAGS">
<front>
<title>Tags for the Identification of Languages</title>
<author initials='H.' surname='Alvestrand' fullname='H.  Alvestrand'>
<organization /></author>
<date month='January' year='2001' /></front>
<seriesInfo name='BCP' value='47' />
<seriesInfo name='RFC' value='3066' />
<format type='TXT' octets='26522' target='ftp://ftp.isi.edu/in-notes/rfc3066.txt' />
</reference>

<reference anchor="NAMEPREP">
<front>
<title>Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)</title>
<author initials='P.' surname='Hoffman' fullname='P.  Hoffman'>
<organization /></author>
<author initials='M.' surname='Blanchet' fullname='M.  Blanchet'>
<organization /></author>
<date month='March' year='2003' /></front>
<seriesInfo name='RFC' value='3491' />
<format type='TXT' octets='10316' target='ftp://ftp.isi.edu/in-notes/rfc3491.txt' />
</reference>

<reference anchor='RANDOM'>
<front>
<title>Randomness Recommendations for Security</title>
<author initials='D.E.' surname='Eastlake' fullname='Donald E. Eastlake 3rd'>
<organization>Digital Equipment Corporation</organization>
<address>
<postal>
<street>550 King Street</street>
<street>LKG2-1/BB3</street>
<city>Littleton</city>
<region>MA</region>
<code>01460</code>
<country>US</country></postal>
<phone>+1 508 486 6577</phone>
<email>dee@lkg.dec.com</email></address></author>
<author initials='S.' surname='Crocker' fullname='Stephen D. Crocker'>
<organization>CyberCash Inc.</organization>
<address>
<postal>
<street>2086 Hunters Crest Way</street>
<city>Vienna</city>
<region>VA</region>
<code>22181</code>
<country>US</country></postal>
<phone>+1 703 620 1222</phone>
<facsimile>+1 703 391 2651</facsimile>
<email>crocker@cybercash.com</email></address></author>
<author initials='J.I.' surname='Schiller' fullname='Jeffrey I. Schiller'>
<organization>Massachusetts Institute of Technology</organization>
<address>
<postal>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<phone>+1 617 253 0161</phone>
<email>jis@mit.edu</email></address></author>
<date month='December' year='1994' />
<abstract>
<t>Security systems today are built on increasingly strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security.  The sophisticated attacker of these security systems may find it easier to reproduce the environment that produced the secret quantities, searching the resulting small set of possibilities, than to locate the quantities in the whole of the number space.</t>
<t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This paper points out many pitfalls in using traditional pseudo-random number generation techniques for choosing such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose.  It provides suggestions to ameliorate the problem when a hardware solution is not available.  And it gives examples of how large such quantities need to be for some particular applications.</t></abstract></front>
<seriesInfo name='RFC' value='1750' />
<format type='TXT' octets='73842' target='ftp://ftp.isi.edu/in-notes/rfc1750.txt' />
</reference>

<reference anchor="SASL">
<front>
<title>Simple Authentication and Security Layer (SASL)</title>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'>
<organization /></author>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>&lt;p>The Simple Authentication and Security Layer (SASL) is a framework for providing authentication and data security services in connection-oriented protocols via replaceable mechanisms. It provides a structured interface between protocols and mechanisms. The resulting framework allows new protocols to reuse existing mechanisms and allows old protocols to make use of new mechanisms. The framework also provides a protocol for securing subsequent protocol exchanges within a data security layer.&lt;/p>&lt;p> This document describes how a SASL mechanism is structured, describes how protocols include support for SASL, and defines the protocol for carrying a data security layer over a connection. In addition, this document defines one SASL mechanism, the EXTERNAL mechanism.&lt;/p>&lt;p> This document obsoletes RFC 2222. [STANDARDS TRACK]&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='4422' />
<format type='TXT' octets='73206' target='ftp://ftp.isi.edu/in-notes/rfc4422.txt' />
</reference>

<reference anchor="SHA" target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">
<front>
<title>Secure Hash Standard</title>
<author>
<organization>National Institute of Standards and Technology</organization>
</author>
<date month="August" year="2002" />
</front>
<seriesInfo name="FIPS" value="PUB 180-2" />
</reference>

<reference anchor="STRINGPREP">
<front>
<title>Preparation of Internationalized Strings ("stringprep")</title>
<author initials='P.' surname='Hoffman' fullname='P.  Hoffman'>
<organization /></author>
<author initials='M.' surname='Blanchet' fullname='M.  Blanchet'>
<organization /></author>
<date month='December' year='2002' /></front>
<seriesInfo name='RFC' value='3454' />
<format type='TXT' octets='138684' target='ftp://ftp.isi.edu/in-notes/rfc3454.txt' />
</reference>

<reference anchor="TCP">
<front>
<title abbrev='Transmission Control Protocol'>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='Jon Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal></address></author>
<date month='September' day='1' year='1981' /></front>
<seriesInfo name='STD' value='7' />
<seriesInfo name='RFC' value='793' />
<format type='TXT' octets='172710' target='ftp://ftp.isi.edu/in-notes/rfc793.txt' />
</reference>

<reference anchor="TERMS">
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass.  Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date month='March' year='1997' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
      NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
      &quot;OPTIONAL&quot; in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='14486' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5661' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<reference anchor='TLS'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.1</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2006' month='April' />
<abstract>
<t>&lt;p>This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='4346' />
<format type='TXT' octets='187041' target='ftp://ftp.isi.edu/in-notes/rfc4346.txt' />
</reference>

<reference anchor="UCS2">
  <front>
    <title>Information Technology - Universal Multiple-octet coded Character Set (UCS) - Amendment 2: UCS Transformation Format 8 (UTF-8)</title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date month="October" year="1996" />
  </front>
  <seriesInfo name="ISO" value="Standard 10646-1 Addendum 2" />
</reference>

<reference anchor='UTF-8'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'>
<organization /></author>
<date month='November' year='2003' /></front>
<seriesInfo name='STD' value='63' />
<seriesInfo name='RFC' value='3629' />
<format type='TXT' octets='33856' target='ftp://ftp.isi.edu/in-notes/rfc3629.txt' />
</reference>

<reference anchor='X509'>
<front>
<title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<author initials='W.' surname='Polk' fullname='W. Polk'>
<organization /></author>
<author initials='W.' surname='Ford' fullname='W. Ford'>
<organization /></author>
<author initials='D.' surname='Solo' fullname='D. Solo'>
<organization /></author>
<date month='April' year='2002' /></front>
<seriesInfo name='RFC' value='3280' />
<format type='TXT' octets='295556' target='ftp://ftp.isi.edu/in-notes/rfc3280.txt' />
</reference>

<reference anchor="XML" target="http://www.w3.org/TR/REC-xml">
  <front>
    <title abbrev="XML">Extensible Markup Language (XML) 1.0 (2nd ed)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray">
      <organization>Textuality and Netscape</organization>
      <address>
        <email>tbray@textuality.com</email>
      </address>
    </author>
    <author initials="J." surname="Paoli" fullname="Jean Paoli">
      <organization>Microsoft</organization>
      <address>
        <email>jeanpa@microsoft.com</email>
      </address>
    </author>
    <author initials="C.M." surname="Sperberg-McQueen" fullname="C.  M.  Sperberg-McQueen">
      <organization>University of Illinois at Chicago and Text Encoding Initiative</organization>
      <address>
        <email>cmsmcq@uic.edu</email>
      </address>
    </author>
    <author initials="E." surname="Maler" fullname="Eve Maler">
      <organization>Sun Microsystems</organization>
      <address>
        <email>eve.maler@east.sun.com</email>
      </address>
    </author>
    <date day="6" month="October" year="2000"/>
  </front>
  <seriesInfo name="W3C" value="REC-xml"/>
</reference>

<reference anchor="XML-NAMES" target="http://www.w3.org/TR/REC-xml-names">
  <front>
    <title>Namespaces in XML</title>
    <author initials="T." surname="Bray" fullname="Tim Bray">
      <organization>Textuality</organization>
      <address>
        <email>tbray@textuality.com</email>
      </address>
    </author>
    <author initials="D." surname="Hollander" fullname="Dave Hollander">
      <organization>Hewlett-Packard Company</organization>
      <address>
        <email>dmh@corp.hp.com</email>
      </address>
    </author>
    <author initials="A." surname="Layman" fullname="Andrew Layman">
      <organization>Microsoft</organization>
      <address>
        <email>andrewl@microsoft.com</email>
      </address>
    </author>
    <date day="14" month="January" year="1999"/>
  </front>
  <seriesInfo name="W3C" value="REC-xml-names"/>
</reference>

    </references>

    <references title="Informative References">

<reference anchor='ACAP'>
<front>
<title abbrev='ACAP'>ACAP -- Application Configuration Access Protocol</title>
<author initials='C.' surname='Newman' fullname='Chris Newman'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 Lakes Drive</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<email>chris.newman@innosoft.com</email></address></author>
<author initials='J.G.' surname='Myers' fullname='John Gardiner Myers'>
<organization>Netscape Communications</organization>
<address>
<postal>
<street>501 East Middlefield Road</street>
<street>Mail Stop MV-029</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country></postal>
<email>jgmyers@netscape.com</email></address></author>
<date month='November' year='1997' />
<abstract>
<t>The Application Configuration Access Protocol (ACAP) is designed to support remote storage and access of program option, configuration and preference information.  The data store model is designed to allow a client relatively simple access to interesting data, to allow new information to be easily added without server re-configuration, and to promote the use of both standardized data and custom or proprietary data.  Key features include "inheritance" which can be used to manage default values for configuration settings and access control lists which allow interesting personal information to be shared and group information to be restricted.</t></abstract></front>
<seriesInfo name='RFC' value='2244' />
<format type='TXT' octets='154610' target='ftp://ftp.isi.edu/in-notes/rfc2244.txt' />
</reference>

<reference anchor="ASN.1">
<front>
<title>Recommendation X.208: Specification of Abstract Syntax Notation One (ASN.1)
</title>
<author>
<organization>CCITT</organization>
</author>
<date year="1988" />
</front>
</reference>

<reference anchor='DNSSEC'>
<front>
<title abbrev='DNS Security Extensions'>Domain Name System Security Extensions</title>
<author initials='D.' surname='Eastlake' fullname='Donald E.  Eastlake 3rd'>
<organization>IBM</organization>
<address>
<postal>
<street>65 Shindegan Hill Road</street>
<street>RR #1</street>
<city>Carmel</city>
<region>NY</region>
<code>10512</code>
<country>US</country></postal>
<phone>+1 914 784 7913</phone>
<facsimile>+1 914 784 3833</facsimile>
<email>dee3@us.ibm.com</email></address></author>
<date month='March' year='1999' />
<abstract>
<t>Extensions to the Domain Name System (DNS) are described that provide data integrity and authentication to security aware resolvers and applications through the use of cryptographic digital signatures.  These digital signatures are included in secured zones as resource records.  Security can also be provided through non-security aware DNS servers in some cases.</t>
<t>The extensions provide for the storage of authenticated public keys in the DNS.  This storage of keys can support general public key distribution services as well as DNS security.  The stored keys enable security aware resolvers to learn the authenticating key of zones in addition to those for which they are initially configured.  Keys associated with DNS names can be retrieved to support other protocols.  Provision is made for a variety of key types and algorithms.</t>
<t>In addition, the security extensions provide for the optional authentication of DNS protocol transactions and requests.</t>
<t>This document incorporates feedback on RFC 2065 from early implementers and potential users.</t></abstract></front>
<seriesInfo name='RFC' value='2535' />
<format type='TXT' octets='110958' target='ftp://ftp.isi.edu/in-notes/rfc2535.txt' />
</reference>

<reference anchor='DNS-TXT'>
<front>
<title abbrev='Storing Arbitrary Attributes in DNS'>Using the Domain Name System To Store Arbitrary String Attributes</title>
<author initials='R.' surname='Rosenbaum' fullname='Rich Rosenbaum'>
<organization>Digital Equipment Corporation</organization>
<address>
<postal>
<street>550 King Street</street>
<street>LKG2-2/Z7</street>
<city>Littleton</city>
<region>MA</region>
<code>01460-1289</code>
<country>US</country></postal>
<phone>+1 508 486 5922</phone>
<email>rosenbaum@lkg.dec.com</email></address></author>
<date year='1993' month='May' />
<abstract>
<t>While the Domain Name System (DNS),is generally used to store predefined types of information (e.g., addresses of hosts), it is possible to use it to store information that has not been previously classified.</t>
<t>This paper describes a simple means to associate arbitrary string information (ASCII text) with attributes that have not been defined by the DNS.  It uses DNS TXT resource records to store the information.  It requires no change to current DNS implementations.</t></abstract></front>
<seriesInfo name='RFC' value='1464' />
<format type='TXT' octets='7953' target='ftp://ftp.isi.edu/in-notes/rfc1464.txt' />
</reference>

<reference anchor='HTTP'>
<front>
<title abbrev='HTTP/1.1'>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials='R.' surname='Fielding' fullname='Roy T.  Fielding'>
<organization abbrev='UC Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='J.' surname='Gettys' fullname='James Gettys'>
<organization abbrev='Compaq/W3C'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials='J.' surname='Mogul' fullname='Jeffrey C.  Mogul'>
<organization abbrev='Compaq'>Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials='H.' surname='Frystyk' fullname='Henrik Frystyk Nielsen'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox'>Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials='P.' surname='Leach' fullname='Paul J.  Leach'>
<organization abbrev='Microsoft'>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date month='June' year='1999' />
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems.  It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers .  A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990.  This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>
<seriesInfo name='RFC' value='2616' />
<format type='TXT' octets='422317' target='ftp://ftp.isi.edu/in-notes/rfc2616.txt' />
<format type='PS' octets='5529857' target='ftp://ftp.isi.edu/in-notes/rfc2616.ps' />
<format type='PDF' octets='550558' target='ftp://ftp.isi.edu/in-notes/rfc2616.pdf' />
<format type='HTML' octets='498891' target='http://xml.resource.org/public/rfc/html/rfc2616.html' />
<format type='XML' octets='471630' target='http://xml.resource.org/public/rfc/xml/rfc2616.xml' />
</reference>

<reference anchor='IMAP'>
<front>
<title>INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1</title>
<author initials='M.' surname='Crispin' fullname='M. Crispin'>
<organization /></author>
<date year='2003' month='March' /></front>
<seriesInfo name='RFC' value='3501' />
<format type='TXT' octets='227640' target='ftp://ftp.isi.edu/in-notes/rfc3501.txt' />
</reference>

<reference anchor="IMP-REQS">
<front>
<title abbrev='Instant Messaging/Presence Protocol'>Instant Messaging / Presence Protocol Requirements</title>
<author initials='M.' surname='Day' fullname='Mark Day'>
<organization>SightPath, Inc.</organization>
<address>
<postal>
<street>135 Beaver Street</street>
<city>Waltham</city>
<region>MA</region>
<code>02452</code>
<country>US</country></postal>
<email>mday@alum.mit.edu</email></address></author>
<author initials='S.' surname='Aggarwal' fullname='Sonu Aggarwal'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code>
<country>US</country></postal>
<email>sonuag@microsoft.com</email></address></author>
<author initials='J.' surname='Vincent' fullname='Jesse Vincent'>
<organization>Into Networks, Inc.</organization>
<address>
<postal>
<street>150 Cambridgepark Drive</street>
<city>Cambridge</city>
<region>MA</region>
<code>02140</code>
<country>US</country></postal>
<email>jesse@intonet.com</email></address></author>
<date month='February' year='2000' />
<abstract>
<t>Presence and Instant Messaging have recently emerged as a new medium of communications over the Internet.  Presence is a means for finding, retrieving, and subscribing to changes in the presence information (e.g.  "online" or "offline") of other users.  Instant messaging is a means for sending small, simple messages that are delivered immediately to online users.</t>
<t>Applications of presence and instant messaging currently use independent, non-standard and non-interoperable protocols developed by various vendors.  The goal of the Instant Messaging and Presence Protocol (IMPP) Working Group is to define a standard protocol so that independently developed applications of instant messaging and/or   presence can interoperate across the Internet.  This document defines a minimal set of requirements that IMPP must meet.</t></abstract></front>
<seriesInfo name='RFC' value='2779' />
<format type='TXT' octets='47420' target='ftp://ftp.isi.edu/in-notes/rfc2779.txt' />
</reference>

<reference anchor='IRI'>
<front>
<title>Internationalized Resource Identifiers (IRIs)</title>
<author initials='M.' surname='Duerst' fullname='M. Duerst'>
<organization /></author>
<author initials='M.' surname='Suignard' fullname='M. Suignard'>
<organization /></author>
<date year='2005' month='January' />
<abstract>
<t>&lt;p>This document defines a new protocol element, the Internationalized Resource Identifier (IRI), as a complement of the Uniform Resource Identifier (URI). An IRI is a sequence of characters from the Universal Character Set (Unicode/ISO 10646). A mapping from IRIs to URIs is defined, which means that IRIs can be used instead of URIs, where appropriate, to identify resources.&lt;/p>&lt;p> The approach of defining a new protocol element was chosen instead of extending or changing the definition of URIs. This was done in order to allow a clear distinction and to avoid incompatibilities with existing software. Guidelines are provided for the use and deployment of IRIs in various protocols, formats, and software components that currently deal with URIs.&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='3987' />
<format type='TXT' octets='111190' target='ftp://ftp.isi.edu/in-notes/rfc3987.txt' />
</reference>

<reference anchor="LINKLOCAL">
<front>
<title>Dynamic Configuration of IPv4 Link-Local Addresses</title>
<author initials='S.' surname='Cheshire' fullname='S. Cheshire'>
<organization /></author>
<author initials='B.' surname='Aboba' fullname='B. Aboba'>
<organization /></author>
<author initials='E.' surname='Guttman' fullname='E. Guttman'>
<organization /></author>
<date year='2005' day='23' month='May' /></front>
<seriesInfo name='RFC' value='3927' />
<format type='TXT' octets='83102' target='ftp://ftp.isi.edu/in-notes/rfc3927.txt' />
</reference>

<reference anchor='MAILBOXES'>
<front>
<title abbrev='Mailbox Names'>MAILBOX NAMES FOR COMMON SERVICES, ROLES AND FUNCTIONS</title>
<author initials='D.' surname='Crocker' fullname='Dave Crocker'>
<organization>Internet Mail Consortium</organization>
<address>
<postal>
<street>127 Segre Ave.</street>
<street>Santa Cruz</street>
<country>CA</country></postal>
<phone>+1 408 246 8253</phone>
<email>dcrocker@imc.org</email></address></author>
<date year='1997' month='May' />
<area>Applications</area>
<keyword>mail</keyword>
<abstract>
<t>
   This specification enumerates and describes Internet mail addresses
   (mailbox name @ host reference) to be used when contacting personnel
   at an organization.  Mailbox names are provided for both operations
   and business functions.  Additional mailbox names and aliases are not
   prohibited, but organizations which support email exchanges with the
   Internet are encouraged to support AT LEAST each mailbox name for
   which the associated function exists within the organization.
</t></abstract></front>
<seriesInfo name='RFC' value='2142' />
<format type='TXT' octets='12195' target='ftp://ftp.isi.edu/in-notes/rfc2142.txt' />
<format type='HTML' octets='29012' target='http://xml.resource.org/public/rfc/html/rfc2142.html' />
<format type='XML' octets='16576' target='http://xml.resource.org/public/rfc/xml/rfc2142.xml' />
</reference>

<reference anchor='POP3'>
<front>
<title abbrev='POP3'>Post Office Protocol - Version 3</title>
<author initials='J.G.' surname='Myers' fullname='John G.  Myers'>
<organization>Carnegie-Mellon University</organization>
<address>
<postal>
<street>5000 Forbes Ave</street>
<city>Pittsburgh</city>
<region>PA</region>
<code>15213</code>
<country>US</country></postal>
<email>jgm+@cmu.edu</email></address></author>
<author initials='M.T.' surname='Rose' fullname='Marshall T.  Rose'>
<organization>Dover Beach Consulting, Inc.</organization>
<address>
<postal>
<street>420 Whisman Court</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043-2186</code>
<country>US</country></postal>
<email>mrose@dbc.mtview.ca.us</email></address></author>
<date month='May' year='1996' /></front>
<seriesInfo name='STD' value='53' />
<seriesInfo name='RFC' value='1939' />
<format type='TXT' octets='47018' target='ftp://ftp.isi.edu/in-notes/rfc1939.txt' />
</reference>

<reference anchor='SMTP'>
<front>
<title>Simple Mail Transfer Protocol</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date month='April' year='2001' /></front>
<seriesInfo name='RFC' value='2821' />
<format type='TXT' octets='192504' target='ftp://ftp.isi.edu/in-notes/rfc2821.txt' />
</reference>

<reference anchor='URI'>
<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='Day Software'>Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Adobe Systems'>Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year='2005' month='January' />
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>
<seriesInfo name='STD' value='66' />
<seriesInfo name='RFC' value='3986' />
<format type='TXT' octets='141811' target='ftp://ftp.isi.edu/in-notes/rfc3986.txt' />
<format type='HTML' octets='200858' target='http://xml.resource.org/public/rfc/html/rfc3986.html' />
<format type='XML' octets='165759' target='http://xml.resource.org/public/rfc/xml/rfc3986.xml' />
</reference>

<reference anchor='URN-OID'>
<front>
<title>A URN Namespace of Object Identifiers</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'>
<organization /></author>
<date year='2001' month='February' />
<abstract>
<t>&lt;p>This document describes a Uniform Resource Name (URN) namespace that contains Object Identifiers (OIDs). This memo provides information for the Internet community. &lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='3061' />
<format type='TXT' octets='8387' target='ftp://ftp.isi.edu/in-notes/rfc3061.txt' />
</reference>

<reference anchor="USINGTLS">
<front>
<title>Using TLS with IMAP, POP3 and ACAP</title>
<author initials='C.' surname='Newman' fullname='Chris Newman'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 Lakes Drive</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<email>chris.newman@innosoft.com</email></address></author>
<date month='June' year='1999' /></front>
<seriesInfo name='RFC' value='2595' />
<format type='TXT' octets='32440' target='ftp://ftp.isi.edu/in-notes/rfc2595.txt' />
</reference>

<reference anchor="XEP-0045">
  <front>
    <title>Multi-User Chat</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="13" month="September" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0045"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0045.html"/>
</reference>

<reference anchor="XEP-0071">
  <front>
    <title>XHTML-IM</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="11" month="January" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0071"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0071.html"/>
</reference>

<reference anchor="XEP-0077">
  <front>
    <title>In-Band Registration</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="24" month="January" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0077"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0077.html"/>
</reference>

<reference anchor="XEP-0086">
  <front>
    <title>Error Condition Mappings</title>
    <author initials="R." surname="Norris" fullname="Robert Norris">
      <organization/>
      <address>
        <email>rob@cataclysm.cx</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="17" month="February" year="2004"/>
  </front>
  <seriesInfo name="XSF XEP" value="0086"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0086.html"/>
</reference>

<reference anchor="XEP-0124">
  <front>
    <title>HTTP Binding</title>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <author initials="D." surname="Smith" fullname="Dave Smith">
      <organization/>
      <address>
        <email>dizzyd@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="28" month="April" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0124"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0124.html"/>
</reference>

<reference anchor="XEP-0156">
  <front>
    <title>A DNS TXT Resource Record Format for XMPP Connection Methods</title>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="16" month="May" year="2005"/>
  </front>
  <seriesInfo name="XSF XEP" value="0156"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0156.html"/>
</reference>

<reference anchor="XEP-0157">
  <front>
    <title>Contact Addresses for XMPP Services</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <author initials="J." surname="Konieczny" fullname="Jacek Konieczny">
      <organization/>
      <address>
        <email>jajcus@jajcus.net</email>
      </address>
    </author>
    <date day="25" month="January" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0157"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0157.html"/>
</reference>

<reference anchor="XEP-0174">
  <front>
    <title>Link-Local Messaging</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="22" month="December" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0174"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0174.html"/>
</reference>

<reference anchor="XEP-0175">
  <front>
    <title>Best Practices for Use of SASL ANONYMOUS</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <date day="20" month="September" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0175"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0175.html"/>
</reference>

<reference anchor="XEP-0178">
  <front>
    <title>Best Practices for Use of SASL EXTERNAL</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email>stpeter@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address>
        <email></email>
      </address>
    </author>
    <date day="25" month="January" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0178"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0178.html"/>
</reference>

<reference anchor="XML-REG">
<front>
<title>The IETF XML Registry</title>
<author initials='M.' surname='Mealling' fullname='M. Mealling'>
<organization /></author>
<date month='January' year='2004' /></front>
<seriesInfo name='BCP' value='81' />
<seriesInfo name='RFC' value='3688' />
<format type='TXT' octets='17325' target='ftp://ftp.isi.edu/in-notes/rfc3688.txt' />
</reference>

<reference anchor="XMPP-IM">
  <front>
    <title>Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence</title>
    <author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'>
      <organization>Jabber Software Foundation</organization>
    </author>
    <date year='2004' month='October' />
  </front>
  <seriesInfo name='RFC' value='3921' />
  <format type='TXT' octets='217527' target='ftp://ftp.isi.edu/in-notes/rfc3921.txt' />
</reference>

<reference anchor='XMPP-URI'>
<front>
<title>Internationalized Resource Identifiers (IRIs) and Uniform Resource Identifiers (URIs) for the Extensible Messaging and Presence Protocol (XMPP)</title>
<author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'>
<organization /></author>
<date year='2006' month='August' />
<abstract>
<t>&lt;p>This document defines the use of Internationalized Resource Identifiers (IRIs) and Uniform Resource Identifiers (URIs) in identifying or interacting with entities that can communicate via the Extensible Messaging and Presence Protocol (XMPP). [STANDARDS TRACK]&lt;/p></t></abstract></front>
<seriesInfo name='RFC' value='4622' />
<format type='TXT' octets='49968' target='ftp://ftp.isi.edu/in-notes/rfc4622.txt' />
</reference>

    </references>

    <section title="Nodeprep" anchor="nodeprep">
      <section title="Introduction" anchor="nodeprep-intro">
        <t>This appendix defines the "Nodeprep" profile of <xref target="STRINGPREP"/>.  As such, it specifies processing rules that will enable users to enter internationalized node identifiers in the Extensible Messaging and Presence Protocol (XMPP) and have the highest chance of getting the content of the strings correct.  (An XMPP node identifier is the optional portion of an XMPP address that precedes a domain identifier and the '@' separator; it is often but not exclusively associated with an instant messaging username.)  These processing rules are intended only for XMPP node identifiers and are not intended for arbitrary text or any other aspect of an XMPP address.</t>
        <t>This profile defines the following, as required by <xref target="STRINGPREP"/>:</t>
        <t><list style="symbols">
          <t>The intended applicability of the profile: internationalized node identifiers within XMPP</t>
          <t>The character repertoire that is the input and output to stringprep: Unicode 3.2, specified in Section 2 of this Appendix</t>
          <t>The mappings used: specified in Section 3</t>
          <t>The Unicode normalization used: specified in Section 4</t>
          <t>The characters that are prohibited as output: specified in Section 5</t>
          <t>Bidirectional character handling: specified in Section 6</t>
        </list></t>
      </section>
      <section title="Character Repertoire" anchor="nodeprep-character">
        <t>This profile uses Unicode 3.2 with the list of unassigned code points being Table A.1, both defined in Appendix A of <xref target="STRINGPREP"/>.</t>
      </section>
      <section title="Mapping" anchor="nodeprep-mapping">
        <t>This profile specifies mapping using the following tables from <xref target="STRINGPREP"/>:</t>
        <t><list style='hanging'>
          <t>Table B.1</t>
          <t>Table B.2</t>
        </list></t>
      </section>
      <section title="Normalization" anchor="nodeprep-normalization">
        <t>This profile specifies the use of Unicode normalization form KC, as described in <xref target="STRINGPREP"/>.</t>
      </section>
      <section title="Prohibited Output" anchor="nodeprep-prohibited">
        <t>This profile specifies the prohibition of using the following tables from <xref target="STRINGPREP"/>.</t>
        <t><list style='hanging'>
          <t>Table C.1.1</t>
          <t>Table C.1.2</t>
          <t>Table C.2.1</t>
          <t>Table C.2.2</t>
          <t>Table C.3</t>
          <t>Table C.4</t>
          <t>Table C.5</t>
          <t>Table C.6</t>
          <t>Table C.7</t>
          <t>Table C.8</t>
          <t>Table C.9</t>
        </list></t>
        <t>In addition, the following Unicode characters are also prohibited:</t>
        <t><list style='hanging'>
          <t>#x22 (")</t>
          <t>#x26 (&amp;)</t>
          <t>#x27 (')</t>
          <t>#x2F (/)</t>
          <t>#x3A (:)</t>
          <t>#x3C (&lt;)</t>
          <t>#x3E (&gt;)</t>
          <t>#x40 (@)</t>
        </list></t>
      </section>
      <section title="Bidirectional Characters" anchor="nodeprep-bidirectional">
        <t>This profile specifies checking bidirectional strings, as described in Section 6 of <xref target="STRINGPREP"/>.</t>
      </section>
    </section>

    <section title="Resourceprep" anchor="resourceprep">
      <section title="Introduction" anchor="resourceprep-introduction">
      <t>This appendix defines the "Resourceprep" profile of <xref target="STRINGPREP"/>.  As such, it specifies processing rules that will enable users to enter internationalized resource identifiers in the Extensible Messaging and Presence Protocol (XMPP) and have the highest chance of getting the content of the strings correct.  (An XMPP resource identifier is the optional portion of an XMPP address that follows a domain identifier and the '/' separator.)  These processing rules are intended only for XMPP resource identifiers and are not intended for arbitrary text or any other aspect of an XMPP address.</t>
      <t>This profile defines the following, as required by <xref target="STRINGPREP"/>:</t>
      <t><list style="symbols">
        <t>The intended applicability of the profile: internationalized resource identifiers within XMPP</t>
        <t>The character repertoire that is the input and output to stringprep: Unicode 3.2, specified in Section 2 of this Appendix</t>
        <t>The mappings used: specified in Section 3</t>
        <t>The Unicode normalization used: specified in Section 4</t>
        <t>The characters that are prohibited as output: specified in Section 5</t>
        <t>Bidirectional character handling: specified in Section 6</t>
      </list></t>
    </section>
    <section title="Character Repertoire" anchor="resourceprep-character">
      <t>This profile uses Unicode 3.2 with the list of unassigned code points being Table A.1, both defined in Appendix A of <xref target="STRINGPREP"/>.</t>
    </section>
      <section title="Mapping" anchor="resourceprep-mapping">
        <t>This profile specifies mapping using the following tables from <xref target="STRINGPREP"/>:</t>
        <t><list style='hanging'>
          <t>Table B.1</t>
        </list></t>
      </section>
      <section title="Normalization" anchor="resourceprep-normalization">
        <t>This profile specifies the use of Unicode normalization form KC, as described in <xref target="STRINGPREP"/>.</t>
      </section>
      <section title="Prohibited Output" anchor="resourceprep-prohibited">
        <t>This profile specifies the prohibition of using the following tables from <xref target="STRINGPREP"/>.</t>
        <t><list style='hanging'>
          <t>Table C.1.2</t>
          <t>Table C.2.1</t>
          <t>Table C.2.2</t>
          <t>Table C.3</t>
          <t>Table C.4</t>
          <t>Table C.5</t>
          <t>Table C.6</t>
          <t>Table C.7</t>
          <t>Table C.8</t>
          <t>Table C.9</t>
        </list></t>
      </section>
      <section title="Bidirectional Characters" anchor="resourceprep-bidirectional">
        <t>This profile specifies checking bidirectional strings, as described in Section 6 of <xref target="STRINGPREP"/>.</t>
      </section>
    </section>

  <section title="Server Dialback" anchor="dialback">
    <section title="Overview" anchor="dialback-overview">
      <t>Server dialback is a reverse DNS lookup method whose results are communicated over XML streams, thus making it more difficult to spoof XMPP server domains and XML stanzas sent over XML streams between servers.  Server dialback is not a security mechanism, and results only in weak verification of server identities (see <xref target="security-server">Server-to-Server Communications</xref> regarding this method's security characteristics).  Domains requiring robust security SHOULD use TLS and SASL; see <xref target="security-server">Server-to-Server Communications</xref> for details.  If SASL is used for server-to-server authentication, dialback SHOULD NOT be used since it is unnecessary.  Documentation of dialback is included mainly for the sake of backward-compatibility with existing implementations and deployments.  However, depending on local policies, a service may wish to use dialback to provide weak identity verification in cases where SASL negotiation would not result in strong authentication (e.g., because the certificate presented by the peer service during TLS negotiation is self-signed and thus provides even weaker identity verification than DNS).</t>
      <t>The server dialback method is made possible by the existence of the Domain Name System (DNS), since one server can (normally) discover the authoritative server for a given domain.  Because dialback depends on DNS, inter-domain communications MUST NOT proceed until the Domain Name System (DNS) hostnames asserted by the servers have been resolved (see <xref target="security-server">Server-to-Server Communications</xref>).</t>
      <t>Server dialback is uni-directional, and results in weak identity verification for one stream in one direction.  Because server dialback is not an authentication mechanism, mutual authentication is not possible via dialback.  Therefore, server dialback MUST be completed in each direction in order to enable bi-directional communications between two domains.</t>
      <t>The method for generating and verifying the keys used in server dialback MUST take into account the hostnames being used, the stream ID generated by the receiving server, and a secret known by the authoritative server's network; see <xref target='dialback-key'/> for the recommended algorithm.</t>
      <t>Any error that occurs during dialback negotiation MUST be considered a stream error, resulting in termination of the stream and of the underlying TCP connection.  The possible error conditions are specified in the protocol description below.</t>
      <t>The following terminology applies:</t>
      <t><list style="symbols">
        <t>ORIGINATING SERVER -- the server that is attempting to establish a connection between two domains.</t>
        <t>RECEIVING SERVER -- the server that is trying to authenticate that the Originating Server represents the domain which it claims to be.</t>
        <t>AUTHORITATIVE SERVER -- the server that answers to the DNS hostname asserted by the Originating Server; for basic environments this will be the Originating Server, but it could be a separate machine in the Originating Server's network.</t>
      </list></t>
    </section>
    <section title="Order of Events" anchor="dialback-order">
      <t>The following is a brief summary of the order of events in dialback:</t>
      <t><list style="numbers">
          <t>The Originating Server establishes a connection to the Receiving Server.</t>
          <t>The Originating Server sends a 'key' value over the connection to the Receiving Server.</t>
          <t>The Receiving Server establishes a connection to the Authoritative Server.</t>
          <t>The Receiving Server sends the same 'key' value to the Authoritative Server.</t>
          <t>The Authoritative Server replies that key is valid or invalid.</t>
          <t>The Receiving Server informs the Originating Server whether it is authenticated or not.</t>
        </list></t>
      <t>We can represent this flow of events graphically as follows:</t>
      <figure>
        <artwork><![CDATA[
Originating               Receiving
  Server                    Server
-----------               ---------
    |                         |
    |   establish connection  |
    | ----------------------> |
    |                         |
    |   send stream header    |
    | ----------------------> |
    |                         |
    |   send stream header    |
    | <---------------------- |
    |                         |                   Authoritative
    |   send dialback key     |                       Server
    | ----------------------> |                   -------------
    |                         |                         |
                              |   establish connection  |
                              | ----------------------> |
                              |                         |
                              |   send stream header    |
                              | ----------------------> |
                              |                         |
                              |   send stream header    |
                              | <---------------------- |
                              |                         |
                              |   send verify request   |
                              | ----------------------> |
                              |                         |
                              |   send verify response  |
                              | <---------------------- |
                              |
    |  report dialback result |
    | <---------------------- |
    |                         |
        ]]></artwork>
      </figure>
    </section>
    <section title="Protocol" anchor="dialback-protocol">
      <t>This section describes the detailed protocol interaction between the Originating Server, the Receiving Server, and the Authoritative Server.</t>
      <t>This section uses the following domain names, IP addresses, stream IDs, and shared secret in the examples:</t>
      <t>
        <list style="symbols">
          <t>The Originating Server is "example.org" (there is no IP address associated with this domain since it is merely asserted by the Originating Server).</t>
          <t>The Receiving Server is "xmpp.example.com" and its IP address is "192.0.2.0".</t>
          <t>The Authoritative Server is "example.org" and its IP address is "192.0.2.1".</t>
          <t>The stream ID of the stream from the Originating Server to the Receiving Server is "D60000229F".</t>
          <t>The shared secret known by the Authoritative Server's network is "s3cr3tf0rd14lb4ck".</t>
          <t>The stream ID of the stream from the Receiving Server to the Authoritative Server is "F92200006D".</t>
        </list>
      </t>
      <t>To assist the reader, the following conventions are used to clarify the flow of packets:</t>
      <t>
        <list style="symbols">
          <t>"O2R:" -- packets sent from the Originating Server to the Receiving Server.</t>
          <t>"R2O:" -- packets sent from the Receiving Server to the Originating Server.</t>
          <t>"R2A:" -- packets sent from the Receiving Server to the Authoritative Server.</t>
          <t>"A2R:" -- packets sent from the Authoritative Server to the Receiving Server.</t>
        </list>
      </t>
      <t>The flow of events is as follows:</t>
      <t><list style="numbers">
          <t>The Originating Server (asserted to be "example.org") performs a DNS lookup for the Receiving Server (in accordance with the procedure described under <xref target='tcp'/>) and establishes a TCP connection to the Receiving Server at the IP address and port discovered during the DNS lookup (here assumed to be "192.0.2.0" and "5269").</t>
          <t>The Originating Server sends a stream header to the Receiving Server:
            <figure>
              <artwork><![CDATA[
O2R: <stream:stream
          xmlns='jabber:server'
          xmlns:db='jabber:server:dialback'
          xmlns:stream='http://etherx.jabber.org/streams'
          from='example.org'
          to='xmpp.example.com'>
                ]]></artwork>
                <postamble>Note: The inclusion of the xmlns:db namespace declaration with the name shown indicates to the Receiving Server that the Originating Server supports server dialback.  If any of the namespace names provided by the Originating Server is incorrect, then the Receiving Server MUST generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If the value of the 'to' address provided by the Originating Server does not match a hostname serviced by the Receiving Server, then the Receiving Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</postamble>
              </figure>
            </t>
            <t>The Receiving Server SHOULD send a stream header back to the Originating Server over the same TCP connection, including a unique ID for this interaction:
              <figure>
                <artwork><![CDATA[
R2O: <stream:stream
         xmlns='jabber:server'
         xmlns:db='jabber:server:dialback'
         xmlns:stream='http://etherx.jabber.org/streams'
         from='xmpp.example.com'
         id='D60000229F'
         to='example.org'>
              ]]></artwork>
              <postamble>Note: The Receiving Server SHOULD reply but MAY silently terminate the XML stream and underlying TCP connection depending on local security policies; however, if the Receiving Server desires to proceed, it MUST send a stream header back to the Originating Server.  If any of the namespace names provided by the Receiving Server is incorrect, then the Originating Server MUST generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If the value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Originating Server, then the Originating Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</postamble>
            </figure>
          </t>
          <t>The Receiving Server SHOULD also send stream features to the Originating Server, including the dialback feature as described under <xref target='dialback-advertise'/>:
            <figure>
              <artwork><![CDATA[
R2O: <stream:features>
       <dialback xmlns='urn:xmpp:features:dialback'>
         <required/>
       </dialback>
     </stream:features>
              ]]></artwork>
            </figure>
          </t>
          <t>The Originating Server MUST then send a dialback key to the Receiving Server:
            <figure>
              <artwork><![CDATA[
O2R: <db:result
         to='xmpp.example.com'
         from='example.org'>
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     </db:result>
              ]]></artwork>
              <postamble>If the value of the 'to' address provided by the Originating Server does not match a hostname serviced by the Receiving Server, then the Receiving Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  The key generated by the Originating Server MUST be based in part on the value of the ID provided by the Receiving Server in the previous step (here "D60000229F"), and in part on a secret shared by the Originating Server and the Authoritative Server (here "s3cr3tf0rd14lb4ck").  Any verifiable method MAY be used to generate the key; however, the method specified under <xref target='dialback-key'/> is RECOMMENDED.  The key is not examined by the Receiving Server, since the key is validated by the Authoritative Server.</postamble>
            </figure>
          </t>
          <t>The Receiving Server performs a DNS lookup for the Authoritative Server (in accordance with the procedure described under <xref target='tcp'/>) and establishes a TCP connection to the Authoritative Server at the IP address and port discovered during the DNS lookup (here assumed to be "192.0.2.1" and "5269").</t>
          <t>The Receiving Server sends a stream header to the Authoritative Server:
            <figure>
              <artwork><![CDATA[
R2A: <stream:stream
         xmlns='jabber:server'
         xmlns:db='jabber:server:dialback'
         xmlns:stream='http://etherx.jabber.org/streams'
         from='xmpp.example.com'
         to='example.org'>
              ]]></artwork>
              <postamble>Note: If the namespace name is incorrect, then the Authoritative Server MUST generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If the value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Authoritative Server, then the Authoritative Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</postamble>
            </figure>
          </t>
          <t>The Authoritative Server sends the Receiving Server a stream header:
            <figure>
              <artwork><![CDATA[
A2R: <stream:stream
         xmlns='jabber:server'
         xmlns:db='jabber:server:dialback'
         xmlns:stream='http://etherx.jabber.org/streams'
         from='example.org'
         id='F92200006D'
         to='xmpp.example.com'>
              ]]></artwork>
              <postamble>Note: If any of the namespace names provided by the Authoritative Server is incorrect, then the Receiving Server MUST generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection between it and the Authoritative Server.  If the value of the 'to' address provided by the Authoritative Server does not match a hostname serviced by the Receiving Server, then the Receiving Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If a stream error occurs between the Receiving Server and the Authoritative Server, then the Receiving Server MUST not only terminate the XML stream and the underlying TCP connection between it and the Authoritative Server but also terminate the XML stream and the underlying TCP connection between it and the Originating Server, generating a &lt;remote-connection-failed/&gt; stream error for the latter stream.</postamble>
            </figure>
          </t>
          <t>The Receiving Server sends the Authoritative Server a request for verification of a key:
            <figure>
              <artwork><![CDATA[
R2A: <db:verify
         from='xmpp.example.com'
         to='example.org'
         id='D60000229F'>
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     </db:verify>
              ]]></artwork>
              <postamble>Note: Passed here are the hostnames of the Receiving Server ('from') and the Originating Server ('to'), the original identifier from the Receiving Server's stream header to the Originating Server in Step 3, and the key that the Originating Server sent to the Receiving Server in Step 5.  Based on this information, as well as shared secret information within the Authoritative Server's network, the Authoritative Server determines whether the key is valid or invalid.  If the value of the 'to' address does not match a hostname serviced by the Authoritative Server, then the Authoritative Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If the value of the 'from' address does not match the hostname sent by the Receiving Server in the 'from' address of the stream header it sent to the Authoritative Server in Step 7, then the Authoritative Server MUST generate an &lt;invalid-from/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</postamble>
            </figure>
          </t>
          <t>The Authoritative Server determines whether the key was valid or invalid and informs the Receiving Server of its determination:
            <figure>
              <artwork><![CDATA[
A2R: <db:verify
         from='example.org'
         to='xmpp.example.com'
         id='D60000229F'
         type='valid'/>
              ]]></artwork>
            </figure>
            or
            <figure>
              <artwork><![CDATA[
A2R: <db:verify
         from='example.org'
         to='xmpp.example.com'
         id='D60000229F'
         type='invalid'/>
              ]]></artwork>
              <postamble>Note: If the ID does not match that provided by the Receiving Server in Step 3, then the Receiving Server MUST generate an &lt;invalid-id/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If the value of the 'to' address does not match a hostname serviced by the Receiving Server, then the Receiving Server MUST generate a &lt;host-unknown/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  If the value of the 'from' address does not match the hostname represented by the Originating Server in the 'from' address of the stream header it sent to the Receiving Server in Step 2, then the Receiving Server MUST generate an &lt;invalid-from/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  After returning the verification to the Receiving Server, the Authoritative Server SHOULD terminate the stream between them and the underlying TCP connection.</postamble>
            </figure>
          </t>
          <t>The Receiving Server informs the Originating Server of the result:
            <figure>
              <artwork><![CDATA[
R2O: <db:result
         from='xmpp.example.com'
         to='example.org'
         id='D60000229F'
         type='valid'/>
              ]]></artwork>
              <postamble>Note: At this point, the connection from the Originating Server to the Receiving Server has either been validated or reported as invalid.  If the connection is invalid, then the Receiving Server MUST terminate both the XML stream and the underlying TCP connection between itself and the Originating Server.  If the connection is valid, the Receiving Server has verified the identity of the Originating Server; as a result, the Originating Server may now send XML stanzas to the Receiving Server over the validated connection (i.e., over the "initial stream" from the Originating Server to the Receiving Server).</postamble>
            </figure>
          </t>
        </list></t>
      <t>Until the initial stream has been validated, the Receiving Server MUST silently drop all XML stanzas sent by the Originating Server to the Receiving Server.</t>
      <t>After successful dialback negotiation, the Receiving Server MUST verify that all XML stanzas received from the Originating Server include a 'from' attribute and a 'to' attribute; if a stanza does not meet this restriction, the Receiving Server MUST generate an &lt;improper-addressing/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  Furthermore, the Receiving Server MUST verify that the 'from' attribute of stanzas received from the Originating Server includes a domain name that has been validated for the stream; if a stanza does not meet this restriction, the Receiving Server MUST generate an &lt;invalid-from/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.  Both of these checks help to prevent spoofing related to particular stanzas.</t>
      <t>As mentioned, server dialback results in weak identity verification in one direction only (in the foregoing text, verification of the Originating Server by the Receiving Server).  In order to proceed with bi-directional communication so that the Receiving Server may sent XML stanzas to the Originating Server, the Receiving Server MUST now also initiate a dialback negotiation with the Originating Server.</t>
    </section>

    <section title="Reuse of Negotiated Connections" anchor="dialback-reuse">
      <t>After the Receiving Server has validated the connection from the Originating Server, the Originating Server may wish to reuse that connection for validation of additional domains.  One common motivation for such reuse is the existence of additional services associated with the Originating Server but hosted at subdomains of the Originating Server (the use of subdomains helps to ensure proper routing of XML stanzas to the hosted services). For example, the "example.org" XMPP server may host a groupchat service at "chat.example.org".  In order to accept XML stanzas from rooms at "chat.example.org" intended for addresses at "xmpp.example.com", the "xmpp.example.com" will need to validate the "chat.example.org" domain (just as it already did for the "example.org" domain).  Thus the "example.org" server would now initiate a dialback negotiation with "xmpp.example.com" but specify the Originating Server as "chat.example.org".  Several optimizations are possible:</t>
      <t>
        <list style='symbols'>
          <t>Because the "example.org" server already has a validated connection open to the Receiving Server ("xmpp.example.com"), it MAY send a &lt;db:result/&gt; element with the key to be validated for the new Originating Server ("chat.example.org") over the XML stream that has already been negotiated, rather than opening a new TCP connection and XML stream.  The Receiving Server SHOULD accept this element rather than returning an error to the Originating Server over the previously negotiated connection.</t>
          <t>If the Receiving Server ("xmpp.example.com") has also negotiated a valid connection in the other direction (from the Receiving Server to the Originating Server), then that connection is ipso facto a connection to the Authoritative Server for the first negotiation.  Therefore the receiving server can re-use that connection for exchange of the &lt;db:verify/&gt; elements associated with the second negotiation.  The Authoritative Server SHOULD accept this element rather than returning an error to the Receiving Server over the previously negotiated connection.</t>
        </list>
      </t>
      <t>These optimizations effectively enable "piggybacking" of the previously negotiated connections.</t>
    </section>

    <section title="Dialback Key Generation" anchor="dialback-key">
      <t>As mentioned, the dialback key is generated based on four different pieces of information:</t>
      <t>
        <list style='symbols'>
          <t>the hostname of the Originating Server</t>
          <t>the hostname of the Receiving Server</t>
          <t>the Stream ID</t>
          <t>a shared secret known by the Authoritative Server's network</t>
        </list>
      </t>
      <t>The stream ID is security-critical in server dialback and therefore MUST be both unpredictable and non-repeating (see <xref target="RANDOM"/> for recommendations regarding randomness for security purposes).</t>
      <t>It is RECOMMENDED for the dialback key to be the hexadecimal representation of a Keyed-Hash Message Authentication Code (see <xref target='HMAC'/>) that uses the SHA-256 algorithm (see <xref target='SHA'/>), as follows:</t>
      <figure>
        <artwork><![CDATA[
HMAC-SHA256
( 
  SHA256(secret), 
  {'Receiving Server' 'Originating Server' 'Stream ID'} 
)
        ]]></artwork>
      </figure>
      <t>The shared secret SHOULD either be set up in a configuration option for each host or process within the Authoritative Server's network or generated as a random string when starting each host or process.  The secret's length SHOULD be at least 128 bits or 16 characters long.</t>
      <t>Consider the following scenario:</t>
      <t>
        <list style='symbols'>
          <t>The Originating Server is "example.org"</t>
          <t>The Receiving Server is "xmpp.example.com"</t>
          <t>The Stream ID is "D60000229F"</t>
          <t>The secret is "s3cr3tf0rd14lb4ck"</t>
        </list>
      </t>
      <t>The resulting dialback key would be:</t>
      <figure>
        <artwork><![CDATA[
HMAC-SHA256
( 
  SHA256(secret), 
  {'Receiving Server' 'Originating Server' 'Stream ID'} 
)

that is,

HMAC-SHA256
(SHA256('s3cr3tf0rd14lb4ck'),
{'xmpp.example.net',' ','example.org',' ','D60000229F'})

that is,

HMAC-SHA256
('a7136eb1f46c9ef18c5e78c36ca257067c69b3d518285f0b18a96c33beae9acc',
{'xmpp.example.com example.org D60000229F'})

that is,

37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
        ]]></artwork>
      </figure>
    </section>
    <section title="Advertisement" anchor="dialback-advertise">
      <t>Support for the server dialback protocol can be indicated in two ways:</t>
      <t>
        <list style='numbers'>
          <t>By inclusion of the server dialback feature in a given set of stream features.</t>
          <t>By inclusion of the dialback namespace declaration in the stream header.</t>
        </list>
      </t>
      <t>The former method is preferred, but the latter method is also specified herein for the purpose of backwards-compatibility with older "XMPP 0.9" deployments.</t>
      <t>The server dialback stream feature is advertised by including in any given set of stream features a &lt;dialback/&gt; element qualified by the 'urn:xmpp:features:dialback' namespace; the &lt;dialback/&gt; element MAY also include an empty &lt;required/&gt; element, indicating that the entity sending the stream features requires dialback to be negotiated for the stream.</t>
      <figure>
        <preamble>Server2 informs Server1 that it supports (and requires) server dialback:</preamble>
        <artwork><![CDATA[
<stream:features>
  <dialback xmlns='urn:xmpp:features:dialback'>
    <required/>
  </dialback>
</stream:features>
        ]]></artwork>
      </figure>
      <t>As mentioned, support for the server dialback protocol can also be advertised by including the dialback namespace declaration in a stream header.</t>
      <figure>
        <artwork><![CDATA[
<stream:stream
    xmlns='jabber:server'
    xmlns:db='jabber:server:dialback'
    xmlns:stream='http://etherx.jabber.org/streams'
    from='example.com'
    to='example.net'>
        ]]></artwork>
      </figure>
      <t>No matter which method is used, a service SHOULD advertise support for server dialback only at a point in the stream negotiation when it will accept negotiation of server dialback for that stream.  For example, if a service wishes to be backwards-compatible with older "XMPP 0.9" deployments, it SHOULD include the server dialback namespace declaration in the initial stream header it sends to other servers (so that "XMPP 0.9" servers can proceed with dialback in the absence of TLS and SASL authentication).  However, in the midst of stream negotiation with an XMPP 1.0 or higher server, a service SHOULD advertise the dialback stream feature only at a point when negotiation of server dialback is allowed in accordance with local service policies (e.g., after TLS negotiation in the case when a self-signed certificate was presented by the Originating Server and local service policies stipulate that it is preferable to weakly identify the Originating Server via server dialback rather than depend on the self-signed certificate for identity verification).</t>
    </section>
  </section>

    <section title="XML Schemas" anchor="def">
      <t>The following XML schemas are descriptive, not normative.  For schemas defining the 'jabber:client' and 'jabber:server' namespaces, refer to <xref target="XMPP-IM"/>.</t>
      <section title="Streams namespace" anchor="def-streams">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='http://etherx.jabber.org/streams'
    xmlns='http://etherx.jabber.org/streams'
    elementFormDefault='unqualified'>

  <xs:import namespace='jabber:client'/>
  <xs:import namespace='jabber:server'/>
  <xs:import namespace='jabber:server:dialback'/>

  <xs:element name='stream'>
    <xs:complexType>
      <xs:sequence xmlns:client='jabber:client'
                   xmlns:server='jabber:server'
                   xmlns:db='jabber:server:dialback'>
        <xs:element ref='features' minOccurs='0' maxOccurs='1'/>
        <xs:any namespace='urn:ietf:params:xml:ns:xmpp-tls'
                minOccurs='0'
                maxOccurs='unbounded'/>
        <xs:any namespace='urn:ietf:params:xml:ns:xmpp-sasl'
                minOccurs='0'
                maxOccurs='unbounded'/>
        <xs:choice minOccurs='0' maxOccurs='1'>
          <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element ref='client:message'/>
            <xs:element ref='client:presence'/>
            <xs:element ref='client:iq'/>
          </xs:choice>
          <xs:choice minOccurs='0' maxOccurs='unbounded'>
            <xs:element ref='server:message'/>
            <xs:element ref='server:presence'/>
            <xs:element ref='server:iq'/>
            <xs:element ref='db:result'/>
            <xs:element ref='db:verify'/>
          </xs:choice>
        </xs:choice>
        <xs:element ref='error' minOccurs='0' maxOccurs='1'/>
      </xs:sequence>
      <xs:attribute name='from' type='xs:string' use='optional'/>
      <xs:attribute name='id' type='xs:NMTOKEN' use='optional'/>
      <xs:attribute name='to' type='xs:string' use='optional'/>
      <xs:attribute name='version' type='xs:decimal' use='optional'/>
      <xs:attribute ref='xml:lang' use='optional'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='features'>
    <xs:complexType>
      <xs:any namespace='##other'/>
    </xs:complexType>
  </xs:element>

  <xs:element name='error'>
    <xs:complexType>
      <xs:sequence  xmlns:err='urn:ietf:params:xml:ns:xmpp-streams'>
        <xs:group   ref='err:streamErrorGroup'/>
        <xs:element ref='err:text'
                    minOccurs='0'
                    maxOccurs='1'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Stream error namespace" anchor="def-streamerror">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-streams'
    xmlns='urn:ietf:params:xml:ns:xmpp-streams'
    elementFormDefault='qualified'>

  <xs:element name='bad-format' type='empty'/>
  <xs:element name='bad-namespace-prefix' type='empty'/>
  <xs:element name='conflict' type='empty'/>
  <xs:element name='connection-timeout' type='empty'/>
  <xs:element name='host-gone' type='empty'/>
  <xs:element name='host-unknown' type='empty'/>
  <xs:element name='improper-addressing' type='empty'/>
  <xs:element name='internal-server-error' type='empty'/>
  <xs:element name='invalid-from' type='empty'/>
  <xs:element name='invalid-id' type='empty'/>
  <xs:element name='invalid-namespace' type='empty'/>
  <xs:element name='invalid-xml' type='empty'/>
  <xs:element name='not-authorized' type='empty'/>
  <xs:element name='policy-violation' type='empty'/>
  <xs:element name='remote-connection-failed' type='empty'/>
  <xs:element name='resource-constraint' type='empty'/>
  <xs:element name='restricted-xml' type='empty'/>
  <xs:element name='see-other-host' type='xs:string'/>
  <xs:element name='system-shutdown' type='empty'/>
  <xs:element name='undefined-condition' type='empty'/>
  <xs:element name='unsupported-encoding' type='empty'/>
  <xs:element name='unsupported-stanza-type' type='empty'/>
  <xs:element name='unsupported-version' type='empty'/>
  <xs:element name='xml-not-well-formed' type='empty'/>

  <xs:group name='streamErrorGroup'>
    <xs:choice>
      <xs:element ref='bad-format'/>
      <xs:element ref='bad-namespace-prefix'/>
      <xs:element ref='conflict'/>
      <xs:element ref='connection-timeout'/>
      <xs:element ref='host-gone'/>
      <xs:element ref='host-unknown'/>
      <xs:element ref='improper-addressing'/>
      <xs:element ref='internal-server-error'/>
      <xs:element ref='invalid-from'/>
      <xs:element ref='invalid-id'/>
      <xs:element ref='invalid-namespace'/>
      <xs:element ref='invalid-xml'/>
      <xs:element ref='not-authorized'/>
      <xs:element ref='policy-violation'/>
      <xs:element ref='remote-connection-failed'/>
      <xs:element ref='resource-constraint'/>
      <xs:element ref='restricted-xml'/>
      <xs:element ref='see-other-host'/>
      <xs:element ref='system-shutdown'/>
      <xs:element ref='undefined-condition'/>
      <xs:element ref='unsupported-encoding'/>
      <xs:element ref='unsupported-stanza-type'/>
      <xs:element ref='unsupported-version'/>
      <xs:element ref='xml-not-well-formed'/>
    </xs:choice>
  </xs:group>

  <xs:element name='text'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="TLS namespace" anchor="def-tls">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-tls'
    xmlns='urn:ietf:params:xml:ns:xmpp-tls'
    elementFormDefault='qualified'>

  <xs:element name='starttls'>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='required'
                    minOccurs='0'
                    type='empty'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='proceed' type='empty'/>
  <xs:element name='failure' type='empty'/>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="SASL namespace" anchor="def-sasl">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-sasl'
    xmlns='urn:ietf:params:xml:ns:xmpp-sasl'
    elementFormDefault='qualified'>

  <xs:element name='mechanisms'>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='mechanism'
                    maxOccurs='unbounded'
                    type='xs:string'/>
        <xs:element name='required'
                    minOccurs='0'
                    type='empty'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='auth'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute name='mechanism'
                        type='xs:string'
                        use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='challenge' type='xs:string'/>
  <xs:element name='response' type='xs:string'/>
  <xs:element name='abort' type='empty'/>
  <xs:element name='success' type='xs:string'/>

  <xs:element name='failure'>
    <xs:complexType>
      <xs:choice minOccurs='0'>
        <xs:element name='aborted' type='empty'/>
        <xs:element name='incorrect-encoding' type='empty'/>
        <xs:element name='invalid-authzid' type='empty'/>
        <xs:element name='invalid-mechanism' type='empty'/>
        <xs:element name='malformed-request' type='empty'/>
        <xs:element name='mechanism-too-weak' type='empty'/>
        <xs:element name='not-authorized' type='empty'/>
        <xs:element name='temporary-auth-failure' type='empty'/>
      </xs:choice>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Resource binding namespace" anchor="def-bind">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-bind'
    xmlns='urn:ietf:params:xml:ns:xmpp-bind'
    elementFormDefault='qualified'>

  <xs:element name='bind'>
    <xs:complexType>
      <xs:sequence>
        <xs:choice minOccurs='0' maxOccurs='1'>
          <xs:element name='resource' type='resourceType'/>
          <xs:element name='jid' type='fullJIDType'/>
        </xs:choice>
        <xs:element name='required'
                    minOccurs='0'
                    maxOccurs='1'
                    type='empty'/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='unbind'>
    <xs:complexType>
      <xs:sequence minOccurs='0'>
        <xs:element name='resource' type='resourceType'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='resourceType'>
    <xs:restriction base='xs:string'>
      <xs:minLength value='1'/>
      <xs:maxLength value='1023'/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name='fullJIDType'>
    <xs:restriction base='xs:string'>
      <xs:minLength value='8'/>
      <xs:maxLength value='3071'/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Dialback namespace" anchor="def-dialback">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:server:dialback'
    xmlns='jabber:server:dialback'
    elementFormDefault='qualified'>

  <xs:element name='result'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:token'>
          <xs:attribute name='from' type='xs:string' use='required'/>
          <xs:attribute name='to' type='xs:string' use='required'/>
          <xs:attribute name='type' use='optional'>
            <xs:simpleType>
              <xs:restriction base='xs:NCName'>
                <xs:enumeration value='invalid'/>
                <xs:enumeration value='valid'/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='verify'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:token'>
          <xs:attribute name='from' type='xs:string' use='required'/>
          <xs:attribute name='id' type='xs:NMTOKEN' use='required'/>
          <xs:attribute name='to' type='xs:string' use='required'/>
          <xs:attribute name='type' use='optional'>
            <xs:simpleType>
              <xs:restriction base='xs:NCName'>
                <xs:enumeration value='invalid'/>
                <xs:enumeration value='valid'/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Server dialback stream feature namespace" anchor="def-dialbackfeature">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:features:dialback'
    xmlns='urn:xmpp:features:dialback'
    elementFormDefault='qualified'>

  <xs:element name='dialback'>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='required'
                    minOccurs='0'
                    maxOccurs='1'
                    type='empty'/>
      </xs:sequence>
    </xs:complexType>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
      <section title="Stanza error namespace" anchor="def-stanzaerror">
        <figure>
          <artwork><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-stanzas'
    xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'
    elementFormDefault='qualified'>

  <xs:element name='bad-request' type='empty'/>
  <xs:element name='conflict' type='empty'/>
  <xs:element name='feature-not-implemented' type='empty'/>
  <xs:element name='forbidden' type='empty'/>
  <xs:element name='gone' type='xs:string'/>
  <xs:element name='internal-server-error' type='empty'/>
  <xs:element name='item-not-found' type='empty'/>
  <xs:element name='jid-malformed' type='empty'/>
  <xs:element name='not-acceptable' type='empty'/>
  <xs:element name='not-allowed' type='empty'/>
  <xs:element name='not-modified' type='empty'/>
  <xs:element name='payment-required' type='empty'/>
  <xs:element name='recipient-unavailable' type='empty'/>
  <xs:element name='redirect' type='xs:string'/>
  <xs:element name='registration-required' type='empty'/>
  <xs:element name='remote-server-not-found' type='empty'/>
  <xs:element name='remote-server-timeout' type='empty'/>
  <xs:element name='resource-constraint' type='empty'/>
  <xs:element name='service-unavailable' type='empty'/>
  <xs:element name='subscription-required' type='empty'/>
  <xs:element name='undefined-condition' type='empty'/>
  <xs:element name='unexpected-request' type='empty'/>

  <xs:group name='stanzaErrorGroup'>
    <xs:choice>
      <xs:element ref='bad-request'/>
      <xs:element ref='conflict'/>
      <xs:element ref='feature-not-implemented'/>
      <xs:element ref='forbidden'/>
      <xs:element ref='gone'/>
      <xs:element ref='internal-server-error'/>
      <xs:element ref='item-not-found'/>
      <xs:element ref='jid-malformed'/>
      <xs:element ref='not-acceptable'/>
      <xs:element ref='not-allowed'/>
      <xs:element ref='not-modified'/>
      <xs:element ref='payment-required'/>
      <xs:element ref='recipient-unavailable'/>
      <xs:element ref='redirect'/>
      <xs:element ref='registration-required'/>
      <xs:element ref='remote-server-not-found'/>
      <xs:element ref='remote-server-timeout'/>
      <xs:element ref='resource-constraint'/>
      <xs:element ref='service-unavailable'/>
      <xs:element ref='subscription-required'/>
      <xs:element ref='undefined-condition'/>
      <xs:element ref='unexpected-request'/>
    </xs:choice>
  </xs:group>

  <xs:element name='text'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute ref='xml:lang' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:simpleType name='empty'>
    <xs:restriction base='xs:string'>
      <xs:enumeration value=''/>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
          ]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Contact Addresses" anchor="contact">
      <t>Consistent with <xref target='MAILBOXES'/>, an organization that offers an XMPP service SHOULD provide an Internet mailbox of "XMPP" for inquiries related to that service, where the host portion of the resulting mailto URI SHOULD be the organization's domain, not necessarily the domain of the XMPP service itself (e.g., the XMPP service might be offered at im.example.net but the Internet mailbox should be &lt;xmpp@example.net&gt;).</t>
      <t>In addition, the XMPP service SHOULD provide a way to discover the XMPP contact address(es) of the service administrator(s), as specified in <xref target='XEP-0157'/>.</t>
    </section>

    <section title="Differences From RFC 3920" anchor="diffs">
      <t>Based on consensus derived from implementation and deployment experience as well as formal interoperability testing, the following modifications were made from RFC 3920.  In addition, several other changes were made to more clearly specify and explain the protocols.</t>
      <t>
        <list style='symbols'>
          <t>Corrected the ABNF syntax for JIDs to prevent zero-length node identifiers, domain identifiers, and resource identifiers.</t>
          <t>Corrected the nameprep processing rules to require use of the UseSTD3ASCIIRules flag.</t>
          <t>Encouraged use of the 'from' and 'to' attributes stream headers.</t>
          <t>More clearly specified stream closing handshake.</t>
          <t>Specified recommended stream reconnection algorithm.</t>
          <t>Specified return of &lt;restricted-xml/&gt; stream error in response to receipt of restricted XML.</t> 
          <t>Specified that SASL mechanisms must be sent both before and after negotiation of TLS and of SASL security layers.</t>
          <t>Specified that TLS plus SASL PLAIN is a mandatory-to-implement technology for client-to-server connections, since implementation of SASL EXTERNAL is uncommon in XMPP clients, in part because underlying security features such as X.509 certificates are not yet widely deployed.</t>
          <t>Added the &lt;malformed-request/&gt; SASL error condition to handle an error case discussed in RFC 4422.</t>
          <t>More clearly specified binding of multiple resources to the same stream.</t>
          <t>Added the &lt;not-modified/&gt; stanza error condition to enable potential ETags usage.</t>
          <t>Added the &lt;unknown-sender/&gt; stanza error condition to provide appropriate handling of stanzas when multiple resources are bound to the same stream.</t>
          <t>Added section on advertisement of server dialback support, including server dialback stream feature.</t>
          <t>Recommended use of HMAC-SHA256 for generation of server dialback key.</t>
        </list>
      </t>
    </section>

  </back>

</rfc>
