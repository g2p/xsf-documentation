<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE jep SYSTEM '../jep.dtd' [
  <!ENTITY % ents SYSTEM '../jep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='../jep.xsl'?>
<jep>
	<header>
		<title>Server-Based Privacy Rules</title>
		<abstract>Note: This JEP has been superseded by the XMPP IM Internet-Draft; please refer to that document for the most up-to-date protocol.</abstract>
                &LEGALNOTICE;
		<number>0016</number>
		<status>Retracted</status>
		<type>Standards Track</type>
		<jig>Standards JIG</jig>
		<dependencies>None</dependencies>
                <supersedes>None</supersedes>
                <supersededby>XMPP IM</supersededby>
                <shortname>None</shortname>
		&pgmillard;
                <revision>
                        <version>1.3</version>
                        <date>2004-07-26</date>
                        <initials>psa</initials>
                        <remark>Formally retracted this proposal in favor of XMPP IM.</remark>
                </revision>
		<revision>
			<version>1.2</version>
			<date>2003-03-12</date>
			<initials>psa</initials>
			<remark>Changed status to Deprecated since this protocol is now included in the XMPP IM Internet-Draft.</remark>
		</revision>
		<revision>
			<version>1.1</version>
			<date>2002-11-17</date>
			<initials>pgm</initials>
			<remark>Added remarks about default handling, and where list processing should take place.</remark>
		</revision>
		<revision>
			<version>1.0</version>
			<date>2002-10-22</date>
			<initials>psa</initials>
			<remark>Changed status to Draft.</remark>
		</revision>
		<revision>
			<version>0.4</version>
			<date>2002-10-03</date>
			<initials>pgm</initials>
			<remark>Elaborated on various JID possibilities.</remark>
		</revision>
		<revision>
			<version>0.3</version>
			<date>2002-07-31</date>
			<initials>pgm</initials>
			<remark>Added info describing current session issues</remark>
		</revision>
		<revision>
			<version>0.2</version>
			<date>2002-07-30</date>
			<initials>pgm</initials>
			<remark>Added whitelists, subscription filtering, and multiple list capabilities. Changed block to deny.</remark>
		</revision>
		<revision>
			<version>0.1</version>
			<date>2002-01-18</date>
			<initials>pgm</initials>
			<remark>Initial version.</remark>
		</revision>
	</header>
	<section1 topic="Introduction">
          <p><em>Note: This JEP has been superseded by &xmppim;; please refer to that document for the most up-to-date protocol!</em></p>
		<p>Almost all types of Instant Messaging (IM) applications have found it necessary to develop some method for a user to block the receipt of messages and packets from other users (the rationale for such blockage depends on the needs of the individual user). The method for implementing this functionality in the current Jabber system is for each client application to keep its own "blacklist" of the Jabber IDs from which the user does not wish to receive messages. This current implementation has the following drawbacks:</p>
		<ol>
			<li>The XML packets are blocked at the client network endpoint. The unwanted packets need to traverse the entire Jabber network before they are blocked from being delivered. However, these packets could be blocked at the server and never delivered "across the wire" to the client, which becomes especially important for clients that have bandwidth restrictions or in situations where bandwidth is expensive.</li>
			<li>Currently there exists no Jabber standard enabling clients to share their individual blacklists. Thus blacklist entries are not portable across clients and if a user accesses their account with a different client, the user must re-enter the blacklist entries.</li>
			<li>Most implementations have no way of blocking specific types of packets -- they typically block only message packets.</li>
		</ol>
		<p>The solution to these shortfalls is to have a common blacklist which is stored on the Jabber server along with the other information which clients receive from the server (primarily the roster).</p>
	</section1>
	<section1 topic="Protocol Details">
		<p>This document proposes the addition of a new namespace to handle the storage and retrieval of the server-side blacklist and whitelist information. The proposed 'jabber:iq:privacy' namespace would be consistent with the existing jabber:* namespaces and use the &lt;query/&gt; element as a direct child under the main &lt;iq/&gt; element. A client application would use &lt;iq type="get"&gt; to retrieve the lists from the server, and use &lt;iq type="set"&gt; to add or edit items in a specific list. Each list is a combination of multiple items. Each item can be of type allow or deny. For this document, these lists will be called &quot;zebra lists&quot;.</p>
		<p>Each &lt;query/&gt; element would have one or more &lt;list&gt; elements which would contain the information for an entire zebra list. The &lt;query&gt; element also contains an &lt;active&gt; element and a &lt;default&gt; element. These elements contain the name of the currently active zebra list or the name of the default zebra list. A client application may perform a get request with an empty &lt;active&gt; element and/or and empty &lt;default&gt; which indicates that it only wants to know which list is currently active or the default list. A client application may also specify a default list to be used for offline processing and when no active list is directly specified. To fetch the currently active list and the rules for each list, the client application performs a simple blank get request.</p>
		<p>The &lt;default&gt; element is used when processing packets and the client is offline, and is used whenver the client connection (session) does not specify a specific list to be active.</p>
		<p>Each &lt;item&gt; element in the zebra list MAY contain a jid attribute (the Jabber ID, i.e. user@host, of the contact which is to be blocked or allowed), MAY contain a subscription attribute, and MUST contain a type attribute. If no jid attribute is specified, then the rule MUST apply to all jids. The possible values of the type attribute would be either "deny", "allow". To remove items from the list, simply send back the list tag with the various &lt;item&gt; elements missing.</p>
		<p>If the &lt;item&gt; element contains a subscription attribute, it means that the rule applies to all jids in the current users roster which have matching subscription elements. Note that a subscription of "both" MUST be treated the same as "from" and "to" together. </p>
		<p>If the &lt;item&gt; element contains no child elements, then all packets would be blocked or allowed. This includes: messages, presence packets, and iq packets. The &lt;item&gt; elements MAY contain the following empty child elements:</p>
		<ul>
			<li>The &lt;message/&gt; element (blocks or allows all message packets).</li>
			<li>The &lt;presence/&gt; element (blocks or allows all presence packets).</li>
			<li>The &lt;iq/&gt; element (blocks or allows all iq packets).</li>
		</ul>
		<p>When a message or other XML packet is blocked according to the entries in the list, the server MUST bounce the packet back to the original sender. The bounced packet MUST be of type="error" and contain a child &lt;error/&gt; element with a code attribute of 405.</p>
		<p>If a &lt;list&gt; element is sent that contains no child elements, the list of that name is removed. If the active list is not reset during the list removal, and the list removed was the active list, the user is returned back to a default state of allow all packets.</p>
	</section1>
	<section1 topic="Implementation Notes and Rules">
		<p>Setting your active zebra list is effective for the current session only, but the storage of the lists is for the user. During usage, a client application should set the active list before sending available presence or fetching the roster. If a client does not set the active zebra list for the current session, the default rules of allowing all packets would apply to that session.
		</p>
		<p>When changing or editing in a specific zebra list, the client application MUST send back all items in the list in the desired order. Server side components that are performing the packet filtering MUST preserve the order of the individual &lt;item&gt; tags and process the rules in that order. All lists MUST have at least one rule that SHOULD specify the default action. The client application MAY send back an &lt;active&gt; element indicating the new currently active list. If no &lt;active&gt; element is sent, the currently active list is used.</p>
		<p>When a client application wishes to just change the currently active zebra list, they MUST NOT send back all of the lists and their contents. The client application SHOULD send back just the new &lt;active&gt; element. If the named list does not exist, the server MUST send back an error using error code 406 (Not Acceptable).</p>
		<p>Client applications can NOT set the default or active list, and alter the actual lists in the same packet. If a client connection attempts to modify both things at once, the server implementation must send back a iq-error using error code 406.</p>
		<p>Implementations of zebra lists MAY choose to allow specific packet types to be checked. If a client attempts to set an item with a specific packet type (message, presence, or iq) and the implementation does not support that feature, the server MUST send back the &lt;iq/&gt; as a type="error" using an error code of 406 (Not Acceptable).</p>
		<p>Implementation of zebra lists SHOULD NOT "push" new lists and additions to existing clients already connected using the same JID (as you would get jabber:iq:roster pushes). If a client application wants to know the current zebra list information, it SHOULD send a get request.</p>
		<p>When a jabber ID is specified on a rule and the ID does not conform to user@host, the following rules apply:</p>
		<ul>
			<li>JIDs of the form 'domain.com' must apply to all users from that domain (ie, *@domain.com). Note that the asterisk (*) is a legal user character, thus, 'domain.com' is different from '*@domain.com'</li>
			<li>JIDs of the form 'user@domain.com/resource' apply to that specific resource. Packets from other resources from that user MUST not match the rule.</li>
			<li>JIDs of the form 'service.domain.com/resource' apply to that specific resource of that service. (As opposed to 'service.domain.com', which matches for '*@service.domain.com'.)</li>
		</ul>
		<p>If a packet does not match any rules in the active list, the default action is to allow.</p>
	</section1>
	<section1 topic="Retrieving the zebra lists">
		<p>The following protocol segments illustrate the exchange of packets between the client application and the server in order to retrieve the zebra list information.</p>
		<example caption="Client Requests the zebra lists"><![CDATA[
<iq type="get" id="1">
  <query xmlns="jabber:iq:privacy"/>
</iq>]]></example>
		<example caption="Server Replies to the zebra lists request"><![CDATA[
<iq type="result" id="1">
  <query xmlns="jabber:iq:privacy">
    <active name="home"/>
    <list name="home">
      <item jid="romeo@jabber.org" type="deny"/>
      <item jid="juliet@jabber.org" type="deny"/>
      <item type="allow"/>
    </list>
    <list name="work">
    	<item type="allow" subscription="from"/>
    	<item type="allow" subscription="to"/>
    	<item type="deny"/>
    </list>
  </query>
</iq>]]></example>
	</section1>
	<section1 topic="Changing the currently active zebra list">
		<p>The following protocol segments illustrate the exchange of packets used to change the active zebra list.</p>
		<example caption="Client changes active list"><![CDATA[
<iq type="set" id="2">
  <query xmlns="jabber:iq:privacy">
    <active name="work"/>
  </query>
</iq>]]></example>
		<example caption="Server Replies to the change request">
&lt;iq type="result" id="2"/&gt;
    </example>
	</section1>
	<section1 topic="Adding or Changing a zebra list">
		<p>The following protocol segments illustrate the exchange of packets used to add or edit a zebra list.</p>
		<example caption="Changing a zebra list"><![CDATA[
<iq type="set" id="3">
  <query xmlns="jabber:iq:privacy">
    <list name="home">
      <item jid="romeo@jabber.org" type="deny"/>
      <item jid="juliet@jabber.org" type="deny"/>
      <item jid="mercutio@jabber.org" type="deny"/>
      <item type="allow"/>
    </list>
  </query>
</iq>]]></example>
		<example caption="Server Replies to the change request">
&lt;iq type="result" id="3"/&gt;
    </example>
	</section1>
	<section1 topic="Removing an entire zebra list">
		<p>The following protocol segments illustrate how a client application would remove a zebra list.</p>
		<example caption="Client Requests Removal of a zebra list"><![CDATA[
<iq type="set" id="4">
  <query xmlns="jabber:iq:privacy">
    <list name="home"/>
  </query>
</iq>]]></example>
		<example caption="Server replies to remove request">
&lt;iq type="result" id="4"/&gt;
    </example>
	</section1>
	<section1 topic="Blocked User Sending a Message">
		<p>The following protocol segments illustrate the exchange of message packets when the sender is blocked by the currently active zebra list.</p>
		<example caption="Blocked User Sends a Message"><![CDATA[
<message to="jill@jabber.org" id="msg_1">
  <body>Hey, I just wanted to chat!</body>
</message>]]></example>
		<example caption="Recipient's Server Bounces Message Back to Blocked Sender"><![CDATA[
<message id="msg_1" type="error">
  <body>Hey, I just wanted to chat!</body>
  <error code="405">Not Allowed</error>
</message>]]></example>
	</section1>
	<section1 topic="Protocol DTD">
		<example caption="jabber:iq:privacy DTD"><![CDATA[<!ELEMENT query (active?, list*)>
<!ATTLIST query
	xmlns CDATA #REQUIRED
>
<!ELEMENT active (#PCDATA)>
<!ATTLIST active
	name CDATA #REQUIRED
>
<!ELEMENT list (item*)>
<!ATTLIST list
	name CDATA #REQUIRED
>
<!ELEMENT item (iq?, message?, presence?)>
<!ATTLIST item
	jid CDATA #IMPLIED
	type (allow | deny) #REQUIRED
	subscription (from | to) #IMPLIED
>
<!Element iq (#PCDATA)>
<!Element message (#PCDATA)>
<!Element presence (#PCDATA)>

]]></example>
	</section1>
	<section1 topic="Future considerations">
		<p>In the future, it may be desirable at some point to allow clients to filter specific iq namespaces. The protocol could easily handle this capability by doing something like the following:</p>
		<example caption="Client Requests to Filter a Specific IQ Namespace"><![CDATA[<iq type="set" id="6">
  <query xmlns="jabber:iq:privacy">
    <list name="home">
      <item jid="romeo@jabber.org" type="deny"/>
      <item jid="juliet@jabber.org" type="deny"/>
      <item jid="mercutio@jabber.org" type="deny">
      	<iq>jabber:iq:oob</iq>
      <item type="allow"/>
    </list>
  </query>
</iq>]]></example>
		<example caption="Server Replies to Filter Namespace Request">
&lt;iq type="result" id="6"/&gt;
    </example>
        <p>In the future, it may be desirable to have be able to block normal presence/availability packets, while still allowing subscription packets through the zebra list.</p>
		<p>In the current open source Jabber server, there is a JSM module called mod_filter which has the capability to implement this type of functionality. However, most servers with large user bases have found it impossible to use mod_filter because of the load that it imposes on packet processing. Using normal whitelist/blacklist operations should make the processing much simpler than mod_filter's processing of an unknown set of rules various rules (not just blocking).</p>
	</section1>

<section1 topic='Author Note' anchor='authornote'>
  <p>Peter Millard, the author of this specification from version 0.1 through version 0.3, died on April 26, 2006.</p>
</section1>

</jep>
