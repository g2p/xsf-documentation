<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
<!ENTITY esupy "e<span class='super'>y</span>">
<!ENTITY dsupx "d<span class='super'>x</span>">
<!ENTITY gsupx "g<span class='super'>x</span>">
<!ENTITY gsupy "g<span class='super'>y</span>">
<!ENTITY NsubA "N<span class='sub'>A</span>">
<!ENTITY NsubB "N<span class='sub'>B</span>">
<!ENTITY CsubA "C<span class='sub'>A</span>">
<!ENTITY CsubB "C<span class='sub'>B</span>">
<!ENTITY MsubA "M<span class='sub'>A</span>">
<!ENTITY MsubB "M<span class='sub'>B</span>">
<!ENTITY KMsubA "KM<span class='sub'>A</span>">
<!ENTITY KMsubB "KM<span class='sub'>B</span>">
<!ENTITY KCsubA "KC<span class='sub'>A</span>">
<!ENTITY KCsubB "KC<span class='sub'>B</span>">
<!ENTITY KSsubA "KS<span class='sub'>A</span>">
<!ENTITY KSsubB "KS<span class='sub'>B</span>">
<!ENTITY twosup32 "2<span class='super'>32</span>">
<!ENTITY twosup2n "2<span class='super'>2n-1</span>">
<!ENTITY CBeCAx2n1 "&CsubB; = &CsubA; XOR 2<span class='super'>n-1</span>">
<!ENTITY IDA "ID<span class='sub'>A</span>">
<!ENTITY IDB "ID<span class='sub'>B</span>">
<!ENTITY formA "form<span class='sub'>A</span>">
<!ENTITY formB "form<span class='sub'>B</span>">
<!ENTITY macA "mac<span class='sub'>A</span>">
<!ENTITY macB "mac<span class='sub'>B</span>">
<!ENTITY signA "sign<span class='sub'>A</span>">
<!ENTITY signB "sign<span class='sub'>B</span>">
<!ENTITY signsA "signs<span class='sub'>A</span>">
<!ENTITY signsB "signs<span class='sub'>B</span>">
<!ENTITY pubKeyA "pubKey<span class='sub'>A</span>">
<!ENTITY pubKeyB "pubKey<span class='sub'>B</span>">
<!ENTITY signKeyA "signKey<span class='sub'>A</span>">
<!ENTITY signKeyB "signKey<span class='sub'>B</span>">
<!ENTITY pubKeysA "pubKeys<span class='sub'>A</span>">
<!ENTITY signKeysA "signKeys<span class='sub'>A</span>">
<!ENTITY x1xZ "x<span class='sub'>1</span>...x<span class='sub'>Z</span>">
<!ENTITY e1eZ "e<span class='sub'>1</span>...e<span class='sub'>Z</span>">
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>Encrypted Sessions</title>
  <abstract>This document specifies an XMPP protocol extension for session-based, end-to-end encryption.</abstract>
  &LEGALNOTICE;
  <number>0116</number>
  <status>Experimental</status>
  <type>Standards Track</type>
  <jig>Standards JIG</jig>
  <dependencies>
    <spec>XMPP Core</spec>
    <spec>RFC 2104</spec>
    <spec>RFC 2409</spec>
    <spec>RFC 3526</spec>
    <spec>RFC 3548</spec>
    <spec>xml-c14n</spec>
    <spec>XEP-0004</spec>
    <spec>XEP-0020</spec>
    <spec>XEP-0030</spec>
    <spec>XEP-0068</spec>
    <spec>XEP-0155</spec>
  </dependencies>
  <supersedes>None</supersedes>
  <supersededby>None</supersededby>
  <shortname>esession</shortname>
  &ianpaterson;
  &stpeter;
  &dizzyd;
  <revision>
    <version>0.11</version>
    <date>2006-10-02</date>
    <initials>ip</initials>
    <remark><p>Harmonised session termination with the protocol added to XEP-0155; added XML schema; minor clarifications</p></remark>
  </revision>
  <revision>
    <version>0.10</version>
    <date>2006-07-18</date>
    <initials>ip</initials>
    <remark><p>Added Upgradability requirement; added expires field to offline options; updated in line with latest version of PEP; moved some content to new XEPs (0187, 0188 and 0189)</p></remark>
  </revision>
  <revision>
    <version>0.9</version>
    <date>2005-11-29</date>
    <initials>ip</initials>
    <remark><p>Modified protocol in line with SIGMA: added Identity Protection requirement, no pre-indication of acceptable keys, send multiple values of e with ESession request, offline options published via SPPS, added LZW compression</p></remark>
  </revision>
  <revision>
    <version>0.8</version>
    <date>2005-09-27</date>
    <initials>ip</initials>
    <remark><p>Added diagramatic synopses; Added match_resource field; replaced req_mac and kid fields with prev_hash; Alice specifies initial counter (doubles as nonce); many other improvements</p></remark>
  </revision>
  <revision>
    <version>0.7</version>
    <date>2005-08-26</date>
    <initials>ip</initials>
    <remark><p>Simplified XML normalization; added Synopsis and Efficiency requirement; defined signature formats</p></remark>
  </revision>
  <revision>
    <version>0.6</version>
    <date>2005-08-12</date>
    <initials>ip</initials>
    <remark><p>Extended termination procedure; added object encryption/signing requirement and special case; clarified expired MAC publishing; added Flexible Offline Message Retrieval to Open Issues.</p></remark>
  </revision>
  <revision>
    <version>0.5</version>
    <date>2005-08-10</date>
    <initials>ip</initials>
    <remark><p>Added flexibility requirement; added late signature of initial request; added termination MAC.</p></remark>
  </revision>
  <revision>
    <version>0.4</version>
    <date>2005-08-09</date>
    <initials>ip</initials>
    <remark><p>Added (offline) replay protection; required offline Created header; compression is NOT RECOMMENDED; added second set of offline options for subscribers; added JIDs to session key generation; unencrypted sessions; added secure option; sign whole data form; HMAC whole &lt;encrypted/&gt; element; added ESession termination; option to distribute public keys within session negotiation; added Integrity requirement; several clarifications</p></remark>
  </revision>
  <revision>
    <version>0.3</version>
    <date>2005-08-02</date>
    <initials>ip/psa</initials>
    <remark><p>Restored status to Experimental; complete rewrite; new Introduction, Background, Requirements and Security Considerations; new OTR-inspired protocol; XEP-0155-based negotiation; counter mode encryption; more secure hashes; offline sessions; re-keying; mac publishing; preliminary key and options publishing protocol.</p></remark>
  </revision>
  <revision>
    <version>0.2</version>
    <date>2004-07-26</date>
    <initials>psa</initials>
    <remark><p>At the request of the author, changed status to Retracted.</p></remark>
  </revision>
  <revision>
    <version>0.1</version>
    <date>2003-09-09</date>
    <initials>dss/psa</initials>
    <remark><p>Initial version.</p></remark>
  </revision>
</header>

<section1 topic='Introduction' anchor='intro'>
  <p>End-to-end encryption is a desirable feature for any communication technology. Ideally, such a technology would design encryption in from the beginning and would forbid unencrypted communications. Realistically, most communication technologies have not been designed in that manner, and Jabber/XMPP technologies are no exception. In particular, the original Jabber technologies developed in 1999 did not include end-to-end encryption by default. PGP-based encryption of message bodies and signing of presence information was added as an extension to the core protocols in the year 2000; this extension is documented in &xep0027;. When the core protocols were formalized within the Internet Standards Process by the IETF's XMPP Working Group in 2003, a different extension was defined using S/MIME-based signing and encryption of CPIM-formatted messages (see &rfc3862;) and PIDF-formatted presence information (see &rfc3863;); this extension is specified in &rfc3923;.</p>
  <p>For reasons described in &xep0188;, the foregoing proposals (and others not mentioned) have not been widely implemented and deployed. This is unfortunate, since an open communication protocol needs to enable end-to-end encryption in order to be seriously considered for deployment by a broad range of users.</p>
  <p>This proposal describes a different approach to end-to-end encryption for use by entities that communicate using XMPP. The requirements and the consequent cryptographic design that underpin this protocol are described in <cite>Cryptographic Design of Encrypted Sessions</cite>. The basic concept is that of an encrypted session which acts as a secure tunnel between two endpoints. Once the tunnel is established, the content of each one-to-one XML stanza exchanged between the endpoints will be encrypted and then transmitted within a "wrapper" stanza.</p>
</section1>

<section1 topic="Dramatis Personae" anchor='personae'>
  <p>This document introduces two characters to help the reader follow the necessary exchanges:</p>
  <ol start='1'>
    <li>"Alice" is the name of the initiator of the ESession. Within the scope of this document, we stipulate that her fully-qualified JID is: &lt;alice@example.org/pda&gt;.</li>
    <li>"Bob" is the name of the other participant in the ESession started by Alice. Within the scope of this document, his fully-qualified JID is: &lt;bob@example.com/laptop&gt;.</li>
    <li>"Aunt Tillie" the archetypal typical user (i.e. non-technical, with only very limited knowledge of how to use a computer, and averse to performing any procedures that are not familiar).</li>
  </ol>
  <p>While Alice and Bob are introduced as "end users", they are simply meant to be examples of Jabber entities. Any directly addressable Jabber entity may participate in an ESession.</p>
</section1>

<section1 topic='Discovering Support' anchor='disco'>
  <p>Before attempting to engage in an ESession with Bob, Alice SHOULD discover whether he supports this protocol, using either &xep0030; or the presence-based profile of <cite>XEP-0030</cite> specified in &xep0115;.</p>
  <p>The normal course of events is for Alice to authenticate with her server, retrieve her roster (see <cite>RFC 3921</cite>), send initial presence to her server, and then receive presence information from all the contacts in her roster. If the presence information she receives from some contacts does not include capabilities data (per <cite>XEP-0115</cite>), Alice SHOULD then send a service discovery information ("disco#info") request to each of those contacts (in accordance with <cite>XEP-0030</cite>). Such initial service discovery stanzas MUST NOT be considered part of encrypted communication sessions for the purposes of this document, since they perform a "bootstrapping" function that is a prerequisite to encrypted communications. The disco#info request sent from Alice to Bob might look as follows:</p>
  <example caption='Alice Queries Bob for ESession Support via Disco'><![CDATA[
<iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com/laptop'
    id='disco1'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>
  ]]></example>
  <p>If Bob sends a disco#info reply and he supports the protocol defined herein, then he MUST include a service discovery feature variable of "http://jabber.org/protocol/esession".</p>
  <example caption='Bob Returns disco#info Data'><![CDATA[
<iq type='result'
    from='bob@example.com/laptop'
    to='alice@example.org/pda'
    id='disco1'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    <identity category='client' type='pc'/>
    ...
    <feature var='http://jabber.org/protocol/esession'/>
    ...
  </query>
</iq>
  ]]></example>
</section1>

<section1 topic="Online ESession Negotiation" anchor='init'>
    <p>The process for establishing a secure session over an insecure transport is essentially a negotiation of various ESession algorithms and other parameters, combined with a translation into XMPP syntax of the &sigma; approach to key exchange (see <cite>Cryptographic Design of Encrypted Sessions</cite>).</p>
    <p>If Alice believes Bob may be online then she SHOULD use the protocol specified in &xep0155; and in this section to negotiate the ESession options and the keys.</p>
    <p>Note: If Alice believes Bob is offline then she SHOULD NOT use this negotiation protocol. However, she MAY use the protocol specified in <cite>Offline Encrypted Sessions</cite> to establish the ESession options and keys. Alternatively, she MAY send stanzas without encryption - in which case her client MUST make absolutely clear to her that the stanzas will not be protected and give her the option not to send the stanzas.</p>
    <p>Note: In any case, Alice MUST NOT initiate a new ESession with Bob if she already has one established with him.</p>
    <section2 topic="ESession Request" anchor='init-online-request'>
      <p>In addition to the "accept", "otr" and "secure" fields specified in <cite>Chat Session Negotiation</cite>, Alice MUST send to Bob each of the ESession options (see list below) that she is willing to use, in her order of preference (see <link url='#sec-mandatory'>Mandatory to Implement Technologies</link>). Note: Alice SHOULD NOT include a "reason" field since Aunt Tillie may not be aware the ESession request is <em>not</em> encrypted.</p>
      <ol>
        <li><p>The list of Modular Exponential (MODP) group numbers (as specified in &rfc2409; or &rfc3526;) that MAY be used for Diffie-Hellman key exchange (valid group numbers include 1,2,3,4,5,14,15,16,17 and 18)</p></li>
        <li><p>Symmetric block cipher algorithm names</p></li>
        <li><p>Hash algorithm names</p></li>
        <li><p>Signature algorithm names</p></li>
        <li><p>Compression algorithm names</p></li>
        <li><p>The list of stanza types that MAY be encrypted and decrypted</p></li>
        <li><p>Whether or not the other entity MUST send the fingerprint of its public signature-verification key instead of the full key <note>If the entity already possesses one of the other entity's public keys then it is RECOMMENDED that only the fingerprint is requested from the other entity - since this saves bandwidth.</note></p></li>
        <li><p>The different versions of this protocol that are supported <note>This version of this document describes version 1.0 of this protocol.</note></p></li>
        <li><p>The minimum number of stanzas that MUST be exchanged before an entity MAY initiate a key re-exchange (1 - every stanza, 100 - every hundred stanzas). Note: This value MUST be less than &twosup32; (see <link url='#sec-rekey'>Re-Keying Limits</link>)</p></li>
      </ol>
      <p>Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p). For each MODP group that Alice specifies she MUST perform the following computations to calculate her Diffie-Hellman keys (where n is the number of bits per cipher block for the block cipher algorithm with the largest block size out of those she specified):</p>
      <ol>
        <li><p>Generate a secret random number x (where &twosup2n; &lt; x &lt; p - 1)</p></li>
        <li><p>Calculate e = &gsupx; mod p</p></li>
      </ol>
      <p>Alice MUST send all her calculated values of e to Bob (in the same order as the associated MODP groups are being sent). She MUST also specify randomly generated Base64 encoded (in accordance with Section 3 of &rfc3548;) value of &NsubA; (her ESession ID).</p>
      <example caption='Alice Requests an ESession'><![CDATA[
<message from='alice@example.org/pda' to='bob@example.com'>
  <feature xmlns='http://jabber.org/protocol/feature-neg'>
    <x type='form' xmlns='jabber:x:data'>
      <field type="hidden" var="FORM_TYPE">
        <value>http://jabber.org/protocol/chatneg</value>
      </field>
      <field type="boolean" var="accept">
        <value>1</value>
      </field>
      <field type="boolean" var="otr">
        <value>0</value>
      </field>
      <field type="boolean" var="secure">
        <value>0</value>
      </field>
      <field type="list-single" var="modp">
        <option><value>5</value></option>
        <option><value>14</value></option>
        <option><value>2</value></option>
      </field>
      <field type="list-single" var="crypt_algs">
        <option><value>aes256-ctr</value></option>
        <option><value>twofish256-ctr</value></option>
        <option><value>aes128-ctr</value></option>
      </field>
      <field type="list-single" var="hash_algs">
        <option><value>whirlpool</value></option>
        <option><value>sha256</value></option>
      </field>
      <field type="list-single" var="sign_algs">
        <option><value>rsa</value></option>
        <option><value>dsa</value></option>
      </field>
      <field type="list-single" var="compress">
        <option><value>none</value></option>
      </field>
      <field type="list-multi" var="stanzas">
        <option><value>message</value></option>
        <option><value>iq</value></option>
        <option><value>presence</value></option>
      </field>
      <field type="boolean" var="pk_hash">
        <value>0</value>
      </field>
      <field type="list-single" var="ver">
        <option><value>1.3</value></option>
        <option><value>1.2</value></option>
      </field>
      <field type="text-single" var="rekey_freq">
        <value>1</value>
      </field>
      <field var="my_nonce">
        <value> ** Base64 encoded ESession ID ** </value>
      </field>
      <field var="keys">
        <value> ** Base64 encoded value of e5 ** </value>
        <value> ** Base64 encoded value of e14 ** </value>
        <value> ** Base64 encoded value of e2 ** </value>
      </field>
    </x>
  </feature>
  <amp xmlns='http://jabber.org/protocol/amp' per-hop='true'>
    <rule action='drop' condition='deliver' value='stored'/>
  </amp>
</message>
      ]]></example>
      <p>If Bob does not support one or more of the options in each ESession field, then he SHOULD return a &feature; error (but he MAY return no error if, for example, he does not want to reveal his presence to Alice for whatever reason):</p>
      <example caption='Bob Informs Alice that Her Options Are Not Supported'><![CDATA[
<message type='error'
         from='bob@example.com/laptop'
         to='alice@example.org/pda'>
  <feature xmlns='http://jabber.org/protocol/feature-neg'>
    ...
  </feature>
  <error type='cancel'>
    <feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
    <unsupported-options xmlns='http://jabber.org/protocol/esession#error'/>
  </error>
</message>
      ]]></example>
      <p>Either Bob or Alice MAY attempt to initiate a new ESession after any error during the negotiation process. However, both MUST consider the previous negotiation to have failed and MUST discard any information learned through the previous negotiation.</p>
      <p>If Bob is unwilling to start an ESession, but he <em>is</em> ready to initiate a one-to-one chat session with Alice (see <cite>Chat Session Negotiation</cite>), then he SHOULD accept the Chat Session and terminate the ESession negotiation by <em>not</em> including a 'nonce' field in his response.</p>
      <example caption='Bob Accepts Chat Session'><![CDATA[
<message from='bob@example.com/laptop' to='alice@example.org/pda'>
  <feature xmlns='http://jabber.org/protocol/feature-neg'>
    <x type='submit' xmlns='jabber:x:data'>
      <field var="FORM_TYPE">
        <value>http://jabber.org/protocol/chatneg</value>
      </field>
      <field var="accept"><value>1</value></field>
      <field var="otr"><value>1</value></field>
      <field var="secure"><value>0</value></field>
    </x>
  </feature>
</message>
      ]]></example>
    </section2>
    <section2 topic="Diffie-Hellman Preparation (Bob)" anchor='init-online-bobprep'>
      <p>If Bob supports one or more of each of Alice's ESession options and is willing to start an ESession with Alice, then he MUST select one of the options from each of the ESession fields he received from Alice including one hash algorithm ("HASH"), and one of the MODP groups and Alice's corresponding value of e (see &rfc3766; or <cite>RFC 3526</cite> for recommendations regarding balancing the sizes of symmetric cipher blocks and Diffie-Hellman moduli).</p>
      <p>Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p). Bob SHOULD return a &feature; error unless: 1 &lt; e &lt; p - 1</p>
      <p>Bob MUST then perform the following computations (where n is the number of bits per cipher block for the selected block cipher algorithm):</p>
      <ol start='1'>
        <li><p>Generate a random number &NsubB; (his ESession ID)</p></li>
        <li><p>Generate an n-bit random number &CsubA; (the block cipher counter for stanzas sent from Alice to Bob)</p></li>
        <li><p>Set &CBeCAx2n1; (where &CsubB; is the block counter for stanzas sent from Bob to Alice)</p></li>
        <li><p>Generate a secret random number y (where &twosup2n; &lt; y &lt; p - 1)</p></li>
        <li><p>Calculate d = &gsupy; mod p</p></li>
        <li><p>Calculate K = HASH(&esupy; mod p) (the shared secret)</p></li>
      </ol>
    </section2>

    <section2 topic="Generating Session Keys" anchor='init-keys'>
      <p>Bob MUST use the shared secret ("K") and the selected hash algorithm ("HASH") to generate two sets of three keys, one set for each direction of the ESession.</p>
      <p>For stanzas that Alice will send to Bob, the keys are calculated as:</p>
      <ol>
        <li><p>Encryption key &KCsubA; = HASH(K, 0)</p></li>
        <li><p>Integrity key &KMsubA; = HASH(K, 2)</p></li>
        <!--  <note>&KMsubA; is a hash of &KCsubA; (not K) to ensure that if an attacker recovers the decryption key she will not be able to cryptographically convince anyone that it was not her who created the stanza.</note> -->
        <li><p>SIGMA key &KSsubA; = HASH(K, 4)</p></li>
      </ol>
      <p>For stanzas that Bob will send to Alice the keys are calculated as:</p>
      <ol start='4'>
        <li><p>Encryption key &KCsubB; = HASH(K, 1)</p></li>
        <li><p>Integrity key &KMsubB; = HASH(K, 3)</p></li>
        <li><p>SIGMA key &KSsubB; = HASH(K, 5)</p></li>
      </ol>
      <p>Once the sets of keys have been calculated the value of K MUST be securely destroyed.</p>
      <p>Note: As many bits of key data as are needed for each key MUST be taken from the least significant bits of the hash output. When negotiating a hash, entities MUST ensure that the hash output is no shorter than the required key data. For algorithms with variable-length keys the maximum length (up to the hash output length) SHOULD be used.</p>
    </section2>

    <section2 topic="Hiding Identity" anchor='init-hide'>
      <p>Bob MUST perform the following steps before he can prove his identity to Alice while protecting it from third parties.</p>
      <ol>
        <li><p>Select &pubKeyB;, the public key Alice should use to authenticate his signature with the signature algorithm he selected ("SIGN").</p></li>
        <li><p>Set &formB; to the <link url='#sign-normal'>Normalized</link>&#160;<em>content</em> of the reponse data form he will send back to Alice (including his responses for all the fields he received from Alice).</p>
            <p>Bob MUST encapsulate the Base64 encoded values of &CsubA; and Alice's &NsubA; in two new 'counter' and 'nonce' fields and add them to &formB;. Note: The 'pk_hash' field specifies whether or not Alice MUST send the fingerprint of her public signature-verification key instead of her full key. Note: The value of the 'rekey_freq' field MUST be less than &twosup32; and greater than or equal to the value specified by Alice. Note: Bob MUST place his Base64 encoded values of &NsubB; and d in the 'my_nonce' and 'keys' fields. Bob MUST NOT return Alice's values of e.</p></li>
        <li><p>Concatenate Alice's ESession ID, Bob's ESession ID, d, &pubKeyB; and &formB;, and calculate the HMAC (as defined in Section 2 of &rfc2104;) of the resulting byte string using the selected hash algorithm ("HASH") and the key &KSsubB;.</p>
            <code>&macB; = <em>HMAC</em>(HASH, &KSsubB;, {&NsubA;, &NsubB;, d, &pubKeyB;, &formB;})</code></li>
        <li><p>Calculate &signB;, the signature of the HMAC result using his private signature key that corresponds to &pubKeyB;</p>
            <code>&signB; = SIGN(&signKeyB;, &macB;)</code></li>
        <li><p>If the value of the 'pk_hash' field that Alice sent Bob was true then Bob SHOULD set &pubKeyB; to the key's fingerprint</p>
            <code>if (pk_hash) &pubKeyB; = HASH(&pubKeyB;)</code></li>
        <li><p>Concatenate &pubKeyB; and &signB; and encrypt the resulting byte string with the agreed algorithm ("CIPHER") in counter mode (see &nistfips800-38a;), using the encryption key &KCsubB; and block counter &CsubB;. Note: &CsubB; MUST be incremented by 1 for each encrypted block or partial block (i.e. &CsubB; = (&CsubB; + 1) mod 2<span class='super'>n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm).</p>
            <code>&IDB; = CIPHER(&KCsubB;, &CsubB;, {&pubKeyB;, &signB;})</code></li>
        <li><p>Calculate the HMAC of the encrypted identity (&IDB;) and the value of Bob's block cipher counter &CsubB;&#160;<em>before</em> the encryption above using the selected hash algorithm ("HASH") and the integrity key &KMsubB;.</p>
            <code>&MsubB; = <em>HMAC</em>(HASH, &KMsubB;, &CsubB;, &IDB;)</code></li>
      </ol>
    </section2>

    <section2 topic="ESession Response" anchor='init-online-response'>
    <p>Bob responds to Alice by sending her &formB;.</p>
    <example caption='Bob Responds to Alice (4-Message Negotiation)'><![CDATA[
<message from='bob@example.com/laptop' to='alice@example.org/pda'>
  <feature xmlns='http://jabber.org/protocol/feature-neg'>
    <x type='submit' xmlns='jabber:x:data'>
      <field var="FORM_TYPE">
        <value>http://jabber.org/protocol/chatneg</value>
      </field>
      <field var="accept"><value>1</value></field>
      <field var="otr"><value>1</value></field>
      <field var="secure"><value>0</value></field>
      <field var="modp"><value>5</value></field>
      <field var="crypt_algs"><value>aes256-ctr</value></field>
      <field var="hash_algs"><value>sha256</value></field>
      <field var="sign_algs"><value>rsa</value></field>
      <field var="compress"><value>none</value></field>
      <field var="stanzas"><value>message</value></field>
      <field var="pk_hash"><value>1</value></field>
      <field var="ver"><value>1.3</value></field>
      <field var="rekey_freq"><value>50</value></field>
      <field var="my_nonce">
        <value> ** Base64 encoded ESession ID ** </value>
      </field>
      <field var="keys">
        <value> ** Base64 encoded value of d ** </value>
      </field>
      <field var="nonce">
        <value> ** Base64 encoded ESession ID ** </value>
      </field>
      <field var="counter">
        <value> ** Base64 encoded block counter ** </value>
      </field>
    </x>
  </feature>
</message>
    ]]></example>
    <p>If Bob prefers the RECOMMENDED 3-message ESession negotiation, where Alice's identity is protected from active attacks instead of his own, then he should encapsulate the Base64 encoded values of &IDB; and &MsubB; in data form fields ('identity' and 'mac'), and append the new fields to &formB; before sending it to Alice.</p>
    <example caption='Bob Responds to Alice (3-Message Negotiation)'><![CDATA[
<message from='bob@example.com/laptop' to='alice@example.org/pda'>
  <feature xmlns='http://jabber.org/protocol/feature-neg'>
    <x type='submit' xmlns='jabber:x:data'>
      <field var="FORM_TYPE">
        <value>http://jabber.org/protocol/chatneg</value>
      </field>
      <field var="accept"><value>1</value></field>
      <field var="otr"><value>1</value></field>
      <field var="secure"><value>0</value></field>
      <field var="modp"><value>5</value></field>
      <field var="crypt_algs"><value>aes256-ctr</value></field>
      <field var="hash_algs"><value>sha256</value></field>
      <field var="sign_algs"><value>rsa</value></field>
      <field var="compress"><value>none</value></field>
      <field var="stanzas"><value>message</value></field>
      <field var="pk_hash"><value>1</value></field>
      <field var="ver"><value>1.3</value></field>
      <field var="rekey_freq"><value>50</value></field>
      <field var="my_nonce">
        <value> ** Base64 encoded ESession ID ** </value>
      </field>
      <field var="keys">
        <value> ** Base64 encoded value of d ** </value>
      </field>
      <field var="nonce">
        <value> ** Base64 encoded ESession ID ** </value>
      </field>
      <field var="counter">
        <value> ** Base64 encoded block counter ** </value>
      </field>
      <field var="identity">
        <value> ** Encrypted identity ** </value>
      </field>
      <field var="mac">
        <value> ** Integrity of identity ** </value>
      </field>
    </x>
  </feature>
</message>
    ]]></example>
    </section2>

    <section2 topic="Diffie-Hellman Preparation (Alice)" anchor='init-online-aliceprep'>
      <p>After Alice receives Bob's response, she MUST use the value of d and the ESession options specified in Bob's response to perform the following steps (where p and g are the constants associated with the selected MODP group, HASH is the selected hash algorithm, and n is the number of bits per cipher block for the agreed block cipher algorithm):</p>
      <ol start='1'>
        <li><p>Return a &feature; error to Bob if she is not prepared to support any of the ESession options specified by Bob (if any of the options were not included in her initial ESession request)</p></li>
        <li><p>Return a &feature; error to Bob unless: 1 &lt; d &lt; p - 1</p></li>
        <li><p>Set &CBeCAx2n1; (where &CsubB; is the block counter for stanzas sent from Bob to Alice)</p></li>
        <li><p>Select her values of x and e that correspond to the selected MODP group (from all the values of x and e she calculated previously)</p></li>
        <li><p>Calculate K = HASH(&dsupx; mod p) (the shared secret)</p></li>
        <li><p>Generate the session keys (&KCsubA;, &KMsubA;, &KSsubA;, &KCsubB;, &KMsubB; and &KSsubB;) in the same way as Bob did (see <link url='#init-keys'>Generating Session Keys</link>)</p></li>
      </ol>
    </section2>
    <section2 topic="Verifying Bob's Identity" anchor='init-online-bobid'>
      <p>If Bob included 'identity' and 'mac' fields in his response then Alice MUST also perform the following steps:</p>
      <ol start='1'>
        <li><p>Calculate the HMAC of the encrypted identity (&IDB;) and the value of Bob's block cipher counter using HASH and the integrity key &KMsubB;.</p>
            <code>&MsubB; = <em>HMAC</em>(HASH, &KMsubB;, &CsubB;, &IDB;)</code></li>
        <li><p>Return a &feature; error to Bob unless the value of &MsubB; she calculated matches the one she received in the 'mac' field</p></li>
        <li><p>Obtain &pubKeyB; and &signB; by decrypting &IDB; with the agreed symmetric block cipher algorithm ("DECIPHER") in counter mode, using the encryption key &KCsubB; and block counter &CsubB;. Note: &CsubB; MUST be incremented by 1 for each encrypted block or partial block (i.e. &CsubB; = (&CsubB; + 1) mod 2<span class='super'>n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm).</p>
            <code>{&pubKeyB;, &signB;} = DECIPHER(&KCsubB;, &CsubB;, &IDB;)</code></li>
        <li><p>If the value of the 'pk_hash' field she sent to Bob in her <link url='#init-online-request'>ESession Request</link> was true, then Alice SHOULD change the value of &pubKeyB; to be her copy of the public key whose HASH matches the value of &pubKeyB; that she received from Bob. Note: If she cannot find a copy of the public key then Alice MUST terminate the ESession. She MAY then request a new ESession with the 'pk_hash' field set to false.</p></li>
        <li><p>Return a &feature; error to Bob unless she can confirm (or has previously confirmed) that &pubKeyB; really is Bob's public key, for examples, via secure out-of-band communication, or through a third-party authority (see <link url='#sec-keys'>Verifying Keys</link>).</p></li>
        <li><p>Set the value of &formB; to be the <link url='#sign-normal'>Normalized</link>&#160;<em>content</em> of the form she received from Bob without any 'identity' or 'mac' fields.</p></li>
        <li><p>Concatenate Alice's ESession ID, Bob's ESession ID, d, &pubKeyB; and &formB;, and calculate the HMAC of the resulting byte string using HASH and the key &KSsubB;.</p>
            <code>&macB; = <em>HMAC</em>(HASH, &KSsubB;, {&NsubA;, &NsubB;, d, &pubKeyB;, &formB;})</code></li>
        <li><p>Return a &feature; error to Bob unless she can use &pubKeyB; with the selected signature verification algorithm ("VERIFY") to confirm that &signB; is the signature of the HMAC result (see <link url='#sign'>Signature Verification</link>).</p>
            <code>VERIFY(&signB;, &pubKeyB;, &macB;)</code></li>
      </ol>
    </section2>

    <section2 topic="ESession Completion" anchor='init-online-complete'>
      <p>Alice MUST then prove her identity to Bob while protecting it from third parties. She MUST perform the steps equivalent to those Bob performed above (see <link url='#init-hide'>Hiding Identity</link> for a more detailed description). Alice's calculations are summarised below (pay attention to the order of &NsubB; and &NsubA; when calculating &macA;). Note: &formA; is the <link url='#sign-normal'>Normalized</link>&#160;<em>content</em> of the <link url='#init-online-request'>ESession Request</link> data form that she sent to Bob previously.</p>
      <code>&macA; = <em>HMAC</em>(HASH, &KSsubA;, {&NsubB;, &NsubA;, e, &pubKeyA;, &formA;})</code>
      <code>&signA; = SIGN(&signKeyA;, &macA;)</code>
      <code>if (pk_hash) &pubKeyA; = HASH(&pubKeyA;)</code>
      <code>&IDA; = CIPHER(&KCsubA;, &CsubA;, {&pubKeyA;, &signA;})</code>
      <code>&MsubA; = <em>HMAC</em>(HASH, &KMsubA;, &CsubA;, &IDA;)</code>

      <p>Alice MUST send the Base64 encoded values of &NsubB;, &IDA; and &MsubA; to Bob. If Alice has already confirmed Bob's identity (i.e. if Bob included 'identity' and 'mac' fields in his response), then she MAY also send encrypted content (see <link url='#exchange'>Exchanging Stanzas</link>) in the same stanza as the proof of her identity.</p>
      <example caption='Alice Sends Bob Her Identity'><![CDATA[
<message from='alice@example.org/pda' to='bob@example.com/laptop'>
  <feature xmlns='http://jabber.org/protocol/feature-neg'>
    <x type='result' xmlns='jabber:x:data'>
      <field var="FORM_TYPE"><value>http://jabber.org/protocol/chatneg</value></field>
      <field var="nonce"><value> ** Base64 encoded ESession ID ** </value></field>
      <field var="identity"><value> ** Encrypted identity ** </value></field>
      <field var="mac"><value> ** Integrity of identity ** </value></field>
    </x>
  </feature>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data> ** Base64 encoded m_final ** </data>
    <mac> ** Base64 encoded a_mac ** </mac>
  </encrypted>
</message>
      ]]></example>
      <p>If Alice also includes a 'terminate' field with its value set to "1" or "true" (see <link url='#terminate'>ESession Termination</link>) within the form then the ESession is terminated immediately. Note: This special case, where a single stanza is encrypted and sent in isolation, is equivalent to object encryption (or object signing if no encryption is specified) and offers several significant advantages over non-session approaches - including perfect forward secrecy.</p>
      <p>After receiving Alice's identity Bob MUST verify it by performing steps equivalent to those described in the section <link url='#init-online-bobid'>Verifying Bob's Identity</link> above. Some of Bob's calculations are summarised below (pay attention to the order of &NsubB; and &NsubA; when calculating &macA;). Note: &formA; is the <link url='#sign-normal'>Normalized</link>&#160;<em>content</em> of the <link url='#init-online-request'>ESession Request</link> data form (the <em>first</em> form) that Alice sent him. Note: If Bob sends an error to Alice then he SHOULD ignore any encrypted content he received in the stanza.</p>
      <code>&MsubA; = <em>HMAC</em>(HASH, &KMsubA;, &CsubA;, &IDA;)</code>
      <code>{&pubKeyA;, &signA;} = DECIPHER(&KCsubA;, &CsubA;, &IDA;)</code>
      <code>&macA; = <em>HMAC</em>(HASH, &KSsubA;, {&NsubB;, &NsubA;, e, &pubKeyA;, &formA;})</code>
      <code>VERIFY(&signA;, &pubKeyA;, &macA;)</code>
      <p>If Alice has already confirmed Bob's identity (i.e. if Bob included 'identity' and 'mac' fields in his response above), then the ESession negotiation is complete.</p>
      <p>Otherwise, one more step is necessary. Bob MUST send Alice the Base64 encoded values of &NsubA;, &IDB; and &MsubB; that he calculated previously (see <link url='#init-hide'>Hiding Identity</link>). Note: He MAY also send encrypted content (see <link url='#exchange'>Exchanging Stanzas</link>) in the same stanza.</p>
      <example caption='Bob Sends Alice His Identity'><![CDATA[
<message from='bob@example.com/laptop' to='alice@example.org/pda'>
  <init xmlns='http://jabber.org/protocol/esession#init'>
    <x type='result' xmlns='jabber:x:data'>
      <field var="FORM_TYPE"><value>http://jabber.org/protocol/chatneg</value></field>
      <field var="nonce"><value> ** Base64 encoded ESession ID ** </value></field>
      <field var="identity"><value> ** Encrypted identity ** </value></field>
      <field var="mac"><value> ** Integrity of identity ** </value></field>
    </x>
  </init>
</message>
      ]]></example>
      <p>After receiving Bob's identity Alice MUST verify it by performing steps described in the section <link url='#init-online-bobid'>Verifying Bob's Identity</link> above. Note: If Alice sends an error to Bob then she SHOULD ignore any encrypted content she received in the stanza.</p>
    </section2>
</section1>


<section1 topic="Exchanging Stanzas" anchor='exchange'>
  <section2 topic="Encryptable Content" anchor='exchange-separate'>
    <p>Once ESession negotiation is complete, Alice and Bob MUST exchange only encrypted forms of the one-to-one stanza types they agreed upon (e.g., &MESSAGE; and &IQ; stanzas).</p>
    <p>Either Alice or Bob MAY send encrypted stanzas. Here we describe the process where Alice sends Bob an encrypted stanza. She MUST only encrypt the XML content that would normally be ignored by the intermediate servers. She MUST NOT encrypt stanza wrapper elements or <cite>Advanced Message Processing</cite> elements.</p>
  <example caption='Unencrypted Stanza'><![CDATA[
<message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'>
  <body>Hello, Bob!</body>
  <amp xmlns='http://jabber.org/protocol/amp'>
    <rule action='error' condition='match-resource' value='exact'/>
  </amp>
  <active xmlns='http://jabber.org/protocol/chatstates'/>
</message>
]]></example>

  <example caption='XML Content to be Encrypted'><![CDATA[
<body>Hello, Bob!</body>
<active xmlns='http://jabber.org/protocol/chatstates'/>
]]></example>
  </section2>
  <section2 topic="Encryption" anchor='exchange-encrypt'>

    <p>Alice MUST perform the following steps to encrypt the XML content. Note: if there is no XML content to be encrypted (e.g. if this is an empty <link url='#rekey'>Re-Keying</link> stanza), then &CsubA; MUST be incremented by 1 (see below), and only the last two steps (normalization and MAC calculation) should be performed.</p>
    <ol start='1'>
      <li><p>Serialize the XML content she wishes to send into an array of UTF-8 bytes, m. <note>Although counter mode encryption requires no padding, implementations MAY still disguise the length of m by appending a random number of white-space characters.</note></p></li>
      <li>
        <p>Compress m using the negotiated algorithm. If a compression algorithm other than 'none' was agreed, the compression context is typically initialized after key exchange and passed from one stanza to the next, with only a partial flush at the end of each stanza. <note>If Bob were to receive a stanza out-of-order, then he would fail to decrypt the stanza and be forced to terminate the ESession.</note></p>
        <code>m_compressed = compress(m)</code>
      </li>
      <li>
        <p>Encrypt the data with the agreed algorithm in counter mode, using the encryption key &KCsubA;. Note: &CsubA; MUST be incremented by 1 for each encrypted block or partial block (i.e. &CsubA; = (&CsubA; + 1) mod 2<span class='super'>n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm). Note: if the block cipher algorithm 'none' was agreed (see <link url='#sec-unencrypted'>Unencrypted ESessions</link>) then encryption MUST NOT be performed and &CsubA; MUST be incremented by 1 (for replay protection).</p>
        <code>m_final = encrypt(&KCsubA;, &CsubA;, m_compressed)</code>
      </li>
      <li>
        <p>Alice MUST now create the <link url='#sign-normal'>Normalized</link> XML <em>content</em> of the &lt;encrypted/&gt; XML element. If there is encrypted XML content, the XML MUST include the Base64 encoded value of m_final wrapped in a &lt;data/&gt; element. Note: the &lt;encrypted/&gt; element MAY also contain one &lt;key/&gt; element and one or more &lt;old/&gt; elements (see <link url='#rekey'>Re-Keying</link>).</p>
        <code>m_content = '&lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;'</code>
      </li>
      <li>
        <p>The XML content and the value of Alice's block cipher counter &CsubA; <em>before</em> the data was encrypted, are now processed through the HMAC algorithm, along with the agreed hash algorithm ("HASH") and the integrity key &KMsubA;.</p>
        <code>a_mac = <em>HMAC</em>(HASH, &KMsubA;, m_content, &CsubA;)</code>
      </li>
    </ol>

  </section2>
  <section2 topic="Sending an Encrypted Stanza" anchor='exchange-send'>
    <p>Before sending the stanza to Bob, Alice MUST wrap m_content and the Base64 encoded value of a_mac (wrapped in a &lt;mac/&gt; element) inside an &lt;encrypted/&gt; element and insert it into the stanza in place of the original content. There MUST NOT be more than one &lt;encrypted/&gt; element per stanza.</p>
    <example caption='Message Stanza with Encrypted Content'><![CDATA[
<message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data> ** Base64 encoded m_final ** </data>
    <mac> ** Base64 encoded a_mac ** </mac>
  </encrypted>
  <amp xmlns='http://jabber.org/protocol/amp' per-hop='true'>
    <rule action='error' condition='match-resource' value='exact'/>
  </amp>
</message>
    ]]></example>
  </section2>
  <section2 topic="Decryption" anchor='exchange-decrypt'>

    <p>When Bob receives the stanza from Alice, he extracts and Base64 decodes the values of m_final and a_mac from the content and performs the following steps.</p>
    <ol start='1'>
      <li>
        <p>Remove the &lt;mac/&gt; element from the &lt;encrypted/&gt; element and <link url='#sign-normal'>Normalize</link> the remaining XML <em>content</em>. Calculate the Message Authentication Code (MAC) for the content.</p>
        <code>b_mac = <em>HMAC</em>(HASH, &KMsubA;, m_content, &CsubA;)</code>
      </li>
      <li>
        <p>Verify that b_mac and a_mac match. If they are not identical, the content has been tampered with and Bob MUST terminate the ESession, he MAY send a &notacceptable; error to Alice. <note>If Bob were to receive a stanza out-of-order, then the MACs would not match because the values of &CsubA; would not be synchronized.</note></p>
      </li>
      <li>
        <p>Decrypt m_final using the agreed algorithm, &KCsubA; and &CsubA;. Note: &CsubA; MUST be incremented by 1 for each decrypted block (see <link url='#exchange-encrypt'>Encryption</link>). Note: if the block cipher algorithm 'none' was agreed decryption MUST NOT be performed and &CsubA; MUST be incremented by 1.</p>
        <code>m_compressed = decrypt(&KCsubA;, &CsubA;, m_final)</code>
      </li>
      <li>
        <p>Decompress m_compressed using the negotiated algorithm (usually 'none').</p>
        <code>m = decompress(m_compressed)</code>
      </li>
      <li>
        <p>Replace the &lt;encrypted/&gt; element in the serialized XML stanza with m and feed the stanza into an XML parser. If the parser returns an XML format error then Bob MUST terminate the ESession, he MAY send a &notacceptable; error to Alice. <note>Bob MUST NOT send a stream error to his server since intermediate entities are not responsible for encoded content.</note></p>
      </li>
    </ol>
  </section2>
  </section1>

<section1 topic='Re-Key Exchange' anchor='rekey'>
<p>Once an attacker has discovered an encryption key it could be used to decrypt all stanzas within a session, including stanzas that were intercepted <em>before</em> the key was discovered. To reduce the window of vulnerability, both Alice and Bob SHOULD change their values of x and y and re-exchange the encryption key as regularly as possible. They MUST also destroy all copies of keys as soon as they are no longer needed.</p>
<p>Note: Although most entities are capable of re-keying after each stanza, clients running in constrained runtime environments may require a few seconds to re-key. During ESession negotiation these clients MAY negotiate the minimum number of stanzas to be exchanged between re-keys at the cost of a larger window of vulnerability. Entities MUST NOT initiate key re-exchanges more frequently than the agreed limit.</p>

  <section2 topic='Re-Key Initiation' anchor='rekey-init'>
    <p>Either Alice or Bob MAY initiate a key re-exchange. Here we describe the process initiated by Alice. First she MUST calculate new values for the encryption parameters:</p>
    <ol start='1'>
      <li><p>Generate a secret random number x (where &twosup2n; &lt; x &lt; p - 1, where n is the number of bits per cipher block for the agreed block cipher algorithm)</p></li>
      <li><p>Calculate e = &gsupx; mod p</p></li>
      <li><p>Calculate K = &dsupx; mod p (the new shared secret)</p></li>
      <li><p>Calculate &KCsubA;, &KMsubA;, &KCsubB;, &KMsubB; from K (see <link url='#init-keys'>Generating Session Keys</link>)</p></li>
    </ol>
    <p>To avoid extra stanzas, the new value of e SHOULD be sent to Bob along with an encrypted stanza. Note: Alice MUST NOT use the new &KCsubA; and &KMsubA; to encrypt this stanza or to calculate the MAC. However, she MUST use them when sending subsequent stanzas.</p>
    <p>Note: There is no need for Alice to provide a signature because the calculation of the MAC includes the new value of e, see <link url='#exchange'>Exchanging Stanzas</link>).</p>
    <example caption='Alice Sends Re-Key Stanza'><![CDATA[
<message from='alice@example.org/pda' to='bob@example.com/laptop'>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data> ** Base64 encoded m_final ** </data>
    <key> ** Base64 encoded value of new e ** </key>
    <mac> ** Base64 encoded a_mac ** </mac>
  </encrypted>
</message>
    ]]></example>
    <p>Note: Bob may not receive the new key before he sends his next stanzas (they may cross in transit). So, before destroying her old values of &KCsubB; and &KMsubB;, Alice MUST wait until either she receives a stanza encrypted with the new key, or a reasonable time has passed (60 seconds should cover a network round-trip and calculations by a constrained client). Similarly she MUST wait before destroying her old value of x, in case Bob sends two stanzas before receiving Alice's new key (the first stanza might include a re-key).</p>
  </section2>
  <section2 topic='Re-Key Acceptance' anchor='rekey-accept'>
    <p>After Bob has received a stanza with a new value of e, has confirmed it is greater than one, and has decrypted the stanza with the old value of &KCsubA;, he MUST securely destroy all copies of &KCsubA; and &KCsubB; and perform the following calculations with the new value of e:</p>
    <ol start='1'>
      <li><p>Calculate K = &esupy; mod p</p></li>
      <li><p>Calculate &KCsubA;, &KMsubA;, &KCsubB;, &KMsubB; from K (see <link url='#init-keys'>Generating Session Keys</link>)</p></li>
    </ol>
    <p>He MUST use these new values to encrypt and decrypt all subsequent stanzas. <note>If an entity fails to receive any stanza that includes a new key in the correct order, then it will fail to decrypt the next stanza it receives and be forced to terminate the ESession.</note></p>
    <p>The next time Bob sends Alice a stanza he MUST specify the number of rekeys he has received from her since he sent her his last stanza. He does that by setting the 'rekeys' attribute of the &lt;data/&gt; element. Note: The default value of the 'rekeys' attribute is zero.</p>
    <example caption="Bob's First Stanza After Receiving a Re-Key"><![CDATA[
<message from='bob@example.com/laptop' to='alice@example.org/pda'>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data rekeys='1'> ** Base64 encoded m_final ** </data>
    <mac> ** Base64 encoded b_mac ** </mac>
  </encrypted>
</message>
    ]]></example>
    <p>When Alice receives the stanza from Bob she MUST use the 'rekeys' attribute to decide which of her values of &KCsubB; and &KMsubB; (or x) she should use to decrypt the stanza - otherwise she would not know if Bob received her rekey(s) before he sent the stanza. Once she is sure Bob has received her rekey(s) she MUST discard all her older values of &KCsubB;, &KMsubB; and x.</p>
  </section2>
  <section2 topic='Publishing Old MAC Values' anchor='rekey-publish'>
    <p>Once the expired MAC keys have been published, anyone could create valid arbitrary stanzas with them. This prevents anyone being able to prove the authenticity of a transcript of the ESession in the future.</p>
    <p>Either entity MAY publish old values of &KMsubA; and/or &KMsubB; within any encrypted stanza as long as it knows that all the stanzas that MAY use the old values have been received and validated. Note: A 'man-in-the-middle' could delay the delivery of stanzas indefinitely. So, before Alice publishes &KMsubA; (and &KMsubB;), she MUST wait until she has both sent a re-key to Bob and received a stanza from Bob encrypted with her new key. (She MAY also publish &KMsubB; after she has received a re-key from Bob.)</p>
    <example caption='Publishing Expired MAC Keys'><![CDATA[
<message from='alice@example.org/pda' to='bob@example.com/laptop'>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data> ** Base64 encoded m_final ** </data>
    <old> ** Base64 encoded old MAC key ** </old>
    <old> ** Base64 encoded old MAC key ** </old>
    <mac> ** Base64 encoded a_mac ** </mac>
  </encrypted>
</message>
    ]]></example>
    <p>Entities SHOULD ignore any &lt;old/&gt; elements they receive.</p>
  </section2>
  </section1>

<section1 topic='ESession Termination' anchor='terminate'>
    <p>Either entity MAY terminate an ESession at any time. Entities MUST terminate all open ESessions before they go offline. To terminate an ESession Alice MUST send an encrypted stanza to Bob including within the encrypted XML of the &lt;data/&gt; element a chat negotiation form with a "terminate" field (as specified in the Termination section of <cite>Chat Session Negotiation</cite>). Note: She MAY publish old values of &KMsubA; and/or &KMsubB; within her termination stanza as long as she is sure all the stanzas that MAY use the old values have been received and validated (see <link url='#rekey-publish'>Publishing Old MAC Values</link>). She MUST then securely destroy all keys associated with the ESession.</p>
    <example caption='Alice Terminates an ESession'><![CDATA[
<message from='alice@example.org/pda' to='bob@example.com/laptop'>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data> ** Base64 encoded encrypted terminate form ** </data>
    <old> ** Base64 encoded old MAC key ** </old>
    <mac> ** Base64 encoded a_mac ** </mac>
  </encrypted>
</message>
    ]]></example>
    <p>When Bob receives a termination stanza he MUST verify the MAC (to be sure he received all the stanzas Alice sent him during the ESession) and immediately send an encrypted termination acknowledgement form (as specified in the Termination section of <cite>Chat Session Negotiation</cite>) back to Alice. Note: He MAY publish <em>any</em> old values of &KMsubA; or &KMsubB; within the acknowledgement stanza. He MUST then securely destroy all keys associated with the ESession.</p>
    <example caption='Bob Acknowledges ESession Termination'><![CDATA[
<message from='bob@example.com/laptop' to='alice@example.org/pda'>
  <encrypted xmlns='http://jabber.org/protocol/esession'>
    <data> ** Base64 encoded encrypted acknowledgement form ** </data>
    <old> ** Base64 encoded old MAC key ** </old>
    <mac> ** Base64 encoded b_mac ** </mac>
  </encrypted>
</message>
    ]]></example>
    <p>When Alice receives the stanza she MUST verify the MAC to be sure she received all the stanzas Bob sent her during the ESession. Once an entity has sent a termination or termination acknowledgement stanza it MUST NOT send another stanza within the ESession.</p>
  </section1>

<section1 topic='Signature Generation and Verification' anchor='sign'>
  <section2 topic='XML Normalization' anchor='sign-normal'>
    <p>Before the signature or MAC of a block of XML is generated or verified, all character data <em>between</em> all elements MUST be removed and the XML MUST be converted to canonical form (see &w3canon;).</p>
    <p>All the XML this protocol requires to be signed or MACed is very simple, so in this case, canonicalization SHOULD only require the following changes:</p>
    <ul>
      <li>Set attribute value delimiters to quotation marks (i.e. simply replace all single quotes in the serialized XML with double quotes)</li>
      <li>Impose lexicographic order on the attributes of "field" elements (i.e. ensure "type" is before "var")</li>
    </ul>
    <p>Implementations MAY conceivably also need to make the following changes. Note: Empty elements and special characters SHOULD NOT appear in the signed or MACed XML specified in this protocol.</p>
    <ul>
      <li>Ensure there are no character references</li>
      <li>Convert empty elements to start-end tag pairs</li>
      <li>Ensure there is no whitespace except for single spaces before attributes</li>
    </ul>
  </section2>
  <section2 topic='Hash' anchor='sign-hash'>
    <p>Before the signature or MAC of a block of XML is generated or verified, the agreed hash algorithm MUST be used to generate the hash of the normalized XML.</p>
    <code>m_hash = HASH(m_content)</code>
  </section2>
  <section2 topic='Generation' anchor='sign-calc'>
    <p>The signature generation depends on the type of private key being used.</p>
    <section3 topic='RSA' anchor='sign-rsa-gen'>
      <code>signature_rsa = rsa_sign(rsa_private_key, m_hash, hashOID)</code>
      <p>The multiprecision integer signature_rsa is the signature (see &rfc3447;).</p>
    </section3>
    <section3 topic='DSA' anchor='sign-dsa-gen'>
      <code>sig_dsa_r, sig_dsa_s = dsa_sign(dsa_private_key, m_hash)</code>
      <p>The multiprecision integers sig_dsa_r and sig_dsa_s are the signature (see &nistfips186-2;).</p>
    </section3>
  </section2>
  <section2 topic='Signature Format' anchor='sign-format'>
    <p>The signature formats are the same for all public key formats. All integers are stored in big-endian byte order.</p>
    <section3 topic='RSA' anchor='sign-rsa-format'>
      <p>Base64 encoding of the signature_rsa multiprecision integer (without any header or length prefix).</p>
    </section3>
    <section3 topic='DSA' anchor='sign-dsa-format'>
      <p>Base64 encoding of the following structure:</p>
      <ul>
        <li>number of bytes in sig_dsa_r (2-byte integer)</li>
        <li>sig_dsa_r</li>
        <li>number of bytes in sig_dsa_s (2-byte integer)</li>
        <li>sig_dsa_s</li>
      </ul>
    </section3>
  </section2>
  <section2 topic='Verification' anchor='sign-calc'>
    <p>The signature verification depends on the type of public key being used.</p>
    <section3 topic='RSA' anchor='sign-rsa-verify'>
      <p>The rsa_modulus and rsa_public_exponent multiprecision integers are extracted from the other entity's authenticated public key. The signature_rsa multiprecision integer is the signature received from the other entity.</p>
      <code>boolean = rsa_verify(signature_rsa, m_hash, hashOID, rsa_modulus, rsa_public_exponent)</code>
    </section3>
    <section3 topic='DSA' anchor='sign-dsa-verify'>
      <p>The dsa_p, dsa_q, dsa_g and dsa_y multiprecision integers are extracted from the other entity's authenticated public key. The sig_dsa_r and sig_dsa_s multiprecision integers are the signature received from the other entity.</p>
      <code>boolean = dsa_verify(sig_dsa_r, sig_dsa_s, m_hash, dsa_p, dsa_q, dsa_g, dsa_y)</code>
    </section3>
  </section2>
  </section1>

<section1 topic='Security Considerations' anchor='sec'>
  <section2 topic='Random Numbers' anchor='sec-prng'>
    <p>Weak pseudo-random number generators (PRNG) enable successful attacks. Implementors MUST use a cryptographically strong PRNG to generate all random numbers (see &rfc1750;).</p>
  </section2>
  <section2 topic='Re-Keying Limits' anchor='sec-rekey'>
    <p>After a key exchange an entity MUST NOT exchange a total of &twosup32; encrypted blocks before it initiates a key re-exchange (see &rfc4344;). Note: This limitation also ensures the same key and counter values are never used to encrypt two different blocks using counter mode (thus preventing simple attacks).</p>
    <p>In order to reduce the Perfect Forward Secrecy window of vulnerability, after an extended period of activity, entities SHOULD either re-key or terminate the ESession.</p>
  </section2>
  <section2 topic='Verifying Keys' anchor='sec-keys'>
    <p>The trust system outlined in this document is based on Alice trusting that the public key presented by Bob is <em>actually</em> Bob's key (and vice versa). Determining this trust may be done in a variety of ways depending on the entities' support for different public key (certificate) formats, signing algorithms and signing authorities. For instance, if Bob publishes a PGP/GPG public key, Alice MAY verify that his key is signed by another key that she knows to be good. Or, if Bob provides an X.509 certificate, she MAY check that his key has been signed by a Certificate Authority that she trusts.</p>
    <p>When trust cannot be achieved automatically, methods that are not transparent to the users may be employed. For example, Bob could communicate the SHA-256 fingerprint of his public key to Alice via secure out-of-band communication (e.g. face-to-face). This would enable Alice to confirm that the public key she receives in-band is valid. Note however that very few people bother to verify fingerprints in this way. So this method is exceptionally vulnerable to 'man-in-the-middle' attacks. In order to reduce the window of vulnerability, an entity SHOULD remember the fingerprints of all user-validated public keys and alert the user in the future if ever the fingerprint(s) it stored for an entity do not match any of the received public keys.</p>
    <p>Alternatively Alice and Bob could agree a shared secret via secure out-of-band communication, Bob could then use it to create an HMAC of his public key that only Alice could verify.</p>
    <p>Note: If no keys are acceptable to Alice (because Alice has never verified any of the keys, and because either the keys are not signed, or Alice does not support the signature algorithms of the keys, or she cannot parse the certificate formats, or she does not recognise the authorities that signed the keys) then, although the ESession can still be encrypted, she cannot be sure she is communicating with Bob.</p>
  </section2>
  <section2 topic='Replay Attacks' anchor='sec-replay'>
    <p>The block cipher counters maintained implicitly by Alice and Bob (&CsubA; and &CsubB;) prevent stanzas being replayed within any ESession. They ensure that the MAC will be different for all stanzas, even if the HMAC key and the content of the stanza are identical.</p>
    <p>Alice and Bob MUST ensure that the value of e or d they provide when negotiating each online ESession is unique. This prevents complete online ESessions being replayed.</p>
  </section2>
  <section2 topic='Unencrypted ESessions' anchor='sec-unencrypted'>
    <p>Organisations with full disclosure policies may require entities to disable encryption to enable the logging of all messages on their server. Unencrypted ESessions meet all the <link url='#reqs-sec'>Security Requirements</link> except for Confidentiality. Unencrypted ESessions enable Alice to to confirm <em>securely</em> with Bob that both client-server connections are secure. i.e. that the value of the 'secure' option (as specified in <cite>Chat Session Negotiation</cite>) has not been tampered with.</p>
  </section2>
  <section2 topic='Storage' anchor='sec-storage'>
    <p>If either entity stores a (re-encrypted) transcript of an ESession for future consultation then the Perfect Forward Secrecy offered by this protocol is lost. If the negotiated value of the 'otr' <cite>Chat Session Negotiation</cite> field is 'true' the entities SHOULD NOT store any part of the ESession content (not even in encrypted form).</p>
  </section2>
  <section2 topic='Extra Responsabilities of Implementors' anchor='sec-general'>
    <p>Cryptography plays only a small part in an entity's security. Even if it implements this protocol perfectly it may still be vulnerable to other attacks. For examples, an implementation might store ESession keys on swap space or save private keys to a file in cleartext! Implementors MUST take very great care when developing applications with secure technologies.</p>
  </section2>
  <section2 topic='Mandatory to Implement Technologies' anchor='sec-mandatory'>
    <p>An implementation of ESession MUST support the Diffie-Hellman Key Agreement and HMAC algorithms. Note: The parameter names mentioned below are related to secure shell; see <cite>SSH Transport Layer Encryption Modes</cite> for block cipher algorithm details; see the &ianassh; for other names.</p>
    <section3 topic='Block Cipher Algorithms' anchor='sec-mandatory-encryption'>
      <p>An implementation of ESession MUST support at least the following block cipher algorithm:</p>
      <ul>
        <li>aes128-ctr (see &nistfips197;)</li>
      </ul>
      <p>The block length of an block cipher algorithm's cipher SHOULD be at least 128 bits. An implementation of ESession MAY also support the following block cipher algorithms:</p>
      <ul>
        <li>aes256-ctr</li>
        <li>aes192-ctr</li>
        <li>twofish256-ctr (see &twofish;)</li>
        <li>twofish192-ctr</li>
        <li>twofish128-ctr</li>
        <li>serpent256-ctr (see &serpent;)</li>
        <li>serpent192-ctr</li>
        <li>serpent128-ctr</li>
        <li>none (no encryption, only signing)</li>
      </ul>
    </section3>
    <section3 topic='Key Signing Algorithms' anchor='sec-mandatory-sign'>
      <p>An implementation of ESession MUST support at least the following signing algorithm:</p>
      <ul>
        <li>rsa (see <cite>RFC 3447</cite>)</li>
      </ul>
      <p>An implementation of ESession SHOULD also support at least the following signing algorithm:</p>
      <ul>
        <li>dsa (see <cite>Digital Signature Standard</cite>)</li>
      </ul>
    </section3>
    <section3 topic='Public Signature-Verification-Key Formats' anchor='sec-mandatory-public'>
      <p>An implementation of ESession MUST support the following public key formats:</p>
      <ul>
        <li>ssh-rsa</li>
      </ul>
      <p>An implementation of ESession SHOULD also support at least the following public key formats:</p>
      <ul>
        <li>ssh-dss</li>
        <li>x509v3-sign-rsa (see &sshx509;)</li>
        <li>x509v3-sign-dss</li>
        <li>pgp-sign-rsa</li>
        <li>pgp-sign-dss</li>
      </ul>
      <p>An implementation of ESession MAY also support the following public key formats:</p>
      <ul>
        <li>spki-sign-rsa</li>
        <li>spki-sign-dss</li>
      </ul>
    </section3>
    <section3 topic='Hash Algorithms' anchor='sec-mandatory-hash'>
      <p>An implementation of ESession MUST support the following hash algorithm:</p>
      <ul>
        <li>sha256 (see &nistfips180-2;)</li>
      </ul>
      <p>An implementation of ESession SHOULD also support at least the following hash algorithm (sha1 and md5 are NOT RECOMMENDED):</p>
      <ul>
        <li>whirlpool (see &whirlpool;)</li>
      </ul>
    </section3>
    <section3 topic='Compression Algorithms' anchor='sec-mandatory-compress'>
      <p>An implementation of ESession MUST support the following compression algorithm:</p>
      <ul>
        <li>none (no compression, the output MUST be the same as the input)</li>
      </ul>
      <p>Support for other algorithms is NOT RECOMMENDED since compression partially defeats the <link url='#reqs-repudiate'>Repudiability</link> requirement of this document by making it more difficult for a third party (with some knowledge of the plaintext) to modify a transcript of an encrypted session in a meaningful way. However, encrypted content is pseudo-random and cannot be compressed, so, in those cases where bandwidth is severely constrained, an implementation of ESession MAY support the following algorithms to compress content before it is encrypted:</p>
      <ul>
        <li>lzw (see &ecma151;)</li>
        <li>zlib (see &rfc1950;)</li>
      </ul>
    </section3>
  </section2>
</section1>

<section1 topic='IANA Considerations' anchor='iana'>
  <p>This document requires no interaction with &IANA;. </p>
</section1>

<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
  <section2 topic='Namespaces' anchor='registrar-ns'>
    <p>Upon approval of this document, the &REGISTRAR; shall register the following namespaces:</p>
    <ul>
      <li>http://jabber.org/protocol/esession</li>
      <li>http://jabber.org/protocol/esession#init</li>
      <li>http://jabber.org/protocol/esession#error</li>
    </ul>
  </section2>
  <section2 topic='Field Standardization' anchor='registrar-formtype'>
    <p>&xep0068; defines a process for standardizing the fields used within Data Forms qualified by a particular namespace. The following fields shall be registered for use in <em>both</em> Encrypted Sessions and Chat Session Negotiation:</p>
    <code caption='Registry Submission'><![CDATA[
<form_type>
  <name>http://jabber.org/protocol/esession</name>
  <jep>XEP-0116</jep>
  <desc>ESession negotiation forms</desc>
  <field
      var='match_resource'
      type='text-single'
      label='Target resource for offline ESessions'/>
  <field
      var='modp'
      type='list-single'
      label='MODP group number'/>
  <field
      var='crypt_algs'
      type='list-single'
      label='Symmetric block cipher options'/>
  <field
      var='hash_algs'
      type='list-single'
      label='Hash algorithm options'/>
  <field
      var='sign_algs'
      type='list-single'
      label='Signature algorithm options'/>
  <field
      var='compress'
      type='list-single'
      label='Compression algorithm options'/>
  <field
      var='stanzas'
      type='list-multi'
      label='Stanzas types to encrypt'/>
  <field
      var='pk_hash'
      type='boolean'
      label='Respond with public key fingerprint'/>
  <field
      var='ver'
      type='list-single'
      label='Supported versions of XEP-0116'/>
  <field
      var='rekey_freq'
      type='text-single'
      label='Minimum number of stanzas between key exchanges'/>
  <field
      var='keys'
      type='hidden'
      label='Diffie-Hellman keys'/>
  <field
      var='my_nonce'
      type='hidden'
      label='ESession ID of Sender'/>
  <field
      var='expires'
      type='hidden'
      label='Expiry time of offline ESession options'/>
  <field
      var='nonce'
      type='hidden'
      label='ESession ID of Receiver'/>
  <field
      var='counter'
      type='hidden'
      label='Initial block counter'/>
  <field
      var='signs'
      type='list-single'
      label='Data form signatures'/>
</form_type>

<form_type>
  <name>http://jabber.org/protocol/chatneg</name>
  <jep>XEP-0155</jep>
  ...
</form_type>
    ]]></code>
  </section2>
</section1>
<section1 topic='XML Schemas' anchor='schema'>
  <code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>

<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='http://jabber.org/protocol/esession'
    xmlns='http://jabber.org/protocol/esession'
    elementFormDefault='qualified'>

  <xs:element name='data'>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base='xs:string'>
          <xs:attribute name='rekeys' type='xs:nonNegativeInteger' use='optional'/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>

  <xs:element name='encrypted'>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref='data' minOccurs='0' maxOccurs='1'/>
        <xs:element ref='key' minOccurs='0' maxOccurs='1'/>
        <xs:element ref='mac' minOccurs='0' maxOccurs='1'/>
        <xs:element ref='old' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name='key' type='xs:string'/>

  <xs:element name='mac' type='xs:string'/>

  <xs:element name='old' type='xs:string'/>

</xs:schema>
  ]]></code>
</section1>

<section1 topic='Open Issues' anchor='open'>
  <section2 topic='To Think About' anchor='open-tothink'>
    <ol>
      <li>Standardise on the X.509 public key and signature formats?</li>
      <li>What challenges exist to make the OTR Gaim Plugin use this protocol natively when talking to Jabber entities? Can these be mitigated by 'non-critical' protocol changes?</li>
      <li>Would anything in this protocol (e.g., its dependency on in-order stanza delivery) prevent an XMPP entity using it to exchange encrypted messages and presence with a user of a non-XMPP messaging system, assuming that the gateway both supports this protocol and is compatible with a purpose-built security plugin on the other user's client (e.g. a Gaim plugin connects to the gateway via a non-XMPP network)?</li>
      <li>Could use &xep0013; (FOMR) instead of AMP to prevent any offline ESessions Bob can't decrypt being delivered to him. (Each &lt;item/&gt; that corresponds to an ESession message would have to contain a &lt;ESessionID/&gt; child, to allow Bob to discover which of his stored values of y was used to encrypt the message.)</li>
    </ol>
  </section2>
  <section2 topic='To Do' anchor='open-todo'>
    <ol>
      <li>Ask the authors of AMP to explain how to achieve the match_resource functionality specified in XEP-0187.</li>
      <li>Define names for X.509 SubjectPublicKeyInfo public key formats (different to X.509 certificates). This format must be used when keys are distributed within session negotiation.</li>
      <li>Add non-repudiable signing option</li>
      <li>Perhaps the document needs to specify more carefully how block counters are handled between messages, especially in the event of partial blocks?</li>
      <li>Give examples of specific errors and discuss error scenarios throughout document (e.g., what should Bob do if he is not offline and he receives an offline key exchange stanza?).</li>
      <li>Define an <em>optional</em> protocol that would allow Alice to store values of &NsubA; and x (and the PKIDs she trusts) 'securely' on her own server (before she goes offline).</li>
    </ol>
  </section2>
</section1>

</xep>
